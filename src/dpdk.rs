/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _NETINET_IN_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SOCKET_H: ::std::os::raw::c_uint = 1;
pub const _SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _BITS_UIO_H: ::std::os::raw::c_uint = 1;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const PF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const PF_LOCAL: ::std::os::raw::c_uint = 1;
pub const PF_UNIX: ::std::os::raw::c_uint = 1;
pub const PF_FILE: ::std::os::raw::c_uint = 1;
pub const PF_INET: ::std::os::raw::c_uint = 2;
pub const PF_AX25: ::std::os::raw::c_uint = 3;
pub const PF_IPX: ::std::os::raw::c_uint = 4;
pub const PF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const PF_NETROM: ::std::os::raw::c_uint = 6;
pub const PF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const PF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const PF_X25: ::std::os::raw::c_uint = 9;
pub const PF_INET6: ::std::os::raw::c_uint = 10;
pub const PF_ROSE: ::std::os::raw::c_uint = 11;
pub const PF_DECnet: ::std::os::raw::c_uint = 12;
pub const PF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const PF_SECURITY: ::std::os::raw::c_uint = 14;
pub const PF_KEY: ::std::os::raw::c_uint = 15;
pub const PF_NETLINK: ::std::os::raw::c_uint = 16;
pub const PF_ROUTE: ::std::os::raw::c_uint = 16;
pub const PF_PACKET: ::std::os::raw::c_uint = 17;
pub const PF_ASH: ::std::os::raw::c_uint = 18;
pub const PF_ECONET: ::std::os::raw::c_uint = 19;
pub const PF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const PF_RDS: ::std::os::raw::c_uint = 21;
pub const PF_SNA: ::std::os::raw::c_uint = 22;
pub const PF_IRDA: ::std::os::raw::c_uint = 23;
pub const PF_PPPOX: ::std::os::raw::c_uint = 24;
pub const PF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const PF_LLC: ::std::os::raw::c_uint = 26;
pub const PF_IB: ::std::os::raw::c_uint = 27;
pub const PF_MPLS: ::std::os::raw::c_uint = 28;
pub const PF_CAN: ::std::os::raw::c_uint = 29;
pub const PF_TIPC: ::std::os::raw::c_uint = 30;
pub const PF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const PF_IUCV: ::std::os::raw::c_uint = 32;
pub const PF_RXRPC: ::std::os::raw::c_uint = 33;
pub const PF_ISDN: ::std::os::raw::c_uint = 34;
pub const PF_PHONET: ::std::os::raw::c_uint = 35;
pub const PF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const PF_CAIF: ::std::os::raw::c_uint = 37;
pub const PF_ALG: ::std::os::raw::c_uint = 38;
pub const PF_NFC: ::std::os::raw::c_uint = 39;
pub const PF_VSOCK: ::std::os::raw::c_uint = 40;
pub const PF_MAX: ::std::os::raw::c_uint = 41;
pub const AF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const AF_LOCAL: ::std::os::raw::c_uint = 1;
pub const AF_UNIX: ::std::os::raw::c_uint = 1;
pub const AF_FILE: ::std::os::raw::c_uint = 1;
pub const AF_INET: ::std::os::raw::c_uint = 2;
pub const AF_AX25: ::std::os::raw::c_uint = 3;
pub const AF_IPX: ::std::os::raw::c_uint = 4;
pub const AF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const AF_NETROM: ::std::os::raw::c_uint = 6;
pub const AF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const AF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const AF_X25: ::std::os::raw::c_uint = 9;
pub const AF_INET6: ::std::os::raw::c_uint = 10;
pub const AF_ROSE: ::std::os::raw::c_uint = 11;
pub const AF_DECnet: ::std::os::raw::c_uint = 12;
pub const AF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const AF_SECURITY: ::std::os::raw::c_uint = 14;
pub const AF_KEY: ::std::os::raw::c_uint = 15;
pub const AF_NETLINK: ::std::os::raw::c_uint = 16;
pub const AF_ROUTE: ::std::os::raw::c_uint = 16;
pub const AF_PACKET: ::std::os::raw::c_uint = 17;
pub const AF_ASH: ::std::os::raw::c_uint = 18;
pub const AF_ECONET: ::std::os::raw::c_uint = 19;
pub const AF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const AF_RDS: ::std::os::raw::c_uint = 21;
pub const AF_SNA: ::std::os::raw::c_uint = 22;
pub const AF_IRDA: ::std::os::raw::c_uint = 23;
pub const AF_PPPOX: ::std::os::raw::c_uint = 24;
pub const AF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const AF_LLC: ::std::os::raw::c_uint = 26;
pub const AF_IB: ::std::os::raw::c_uint = 27;
pub const AF_MPLS: ::std::os::raw::c_uint = 28;
pub const AF_CAN: ::std::os::raw::c_uint = 29;
pub const AF_TIPC: ::std::os::raw::c_uint = 30;
pub const AF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const AF_IUCV: ::std::os::raw::c_uint = 32;
pub const AF_RXRPC: ::std::os::raw::c_uint = 33;
pub const AF_ISDN: ::std::os::raw::c_uint = 34;
pub const AF_PHONET: ::std::os::raw::c_uint = 35;
pub const AF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const AF_CAIF: ::std::os::raw::c_uint = 37;
pub const AF_ALG: ::std::os::raw::c_uint = 38;
pub const AF_NFC: ::std::os::raw::c_uint = 39;
pub const AF_VSOCK: ::std::os::raw::c_uint = 40;
pub const AF_MAX: ::std::os::raw::c_uint = 41;
pub const SOL_RAW: ::std::os::raw::c_uint = 255;
pub const SOL_DECNET: ::std::os::raw::c_uint = 261;
pub const SOL_X25: ::std::os::raw::c_uint = 262;
pub const SOL_PACKET: ::std::os::raw::c_uint = 263;
pub const SOL_ATM: ::std::os::raw::c_uint = 264;
pub const SOL_AAL: ::std::os::raw::c_uint = 265;
pub const SOL_IRDA: ::std::os::raw::c_uint = 266;
pub const SOMAXCONN: ::std::os::raw::c_uint = 128;
pub const _BITS_SOCKADDR_H: ::std::os::raw::c_uint = 1;
pub const _SS_SIZE: ::std::os::raw::c_uint = 128;
pub const FIOSETOWN: ::std::os::raw::c_uint = 35073;
pub const SIOCSPGRP: ::std::os::raw::c_uint = 35074;
pub const FIOGETOWN: ::std::os::raw::c_uint = 35075;
pub const SIOCGPGRP: ::std::os::raw::c_uint = 35076;
pub const SIOCATMARK: ::std::os::raw::c_uint = 35077;
pub const SIOCGSTAMP: ::std::os::raw::c_uint = 35078;
pub const SIOCGSTAMPNS: ::std::os::raw::c_uint = 35079;
pub const SOL_SOCKET: ::std::os::raw::c_uint = 1;
pub const SO_DEBUG: ::std::os::raw::c_uint = 1;
pub const SO_REUSEADDR: ::std::os::raw::c_uint = 2;
pub const SO_TYPE: ::std::os::raw::c_uint = 3;
pub const SO_ERROR: ::std::os::raw::c_uint = 4;
pub const SO_DONTROUTE: ::std::os::raw::c_uint = 5;
pub const SO_BROADCAST: ::std::os::raw::c_uint = 6;
pub const SO_SNDBUF: ::std::os::raw::c_uint = 7;
pub const SO_RCVBUF: ::std::os::raw::c_uint = 8;
pub const SO_SNDBUFFORCE: ::std::os::raw::c_uint = 32;
pub const SO_RCVBUFFORCE: ::std::os::raw::c_uint = 33;
pub const SO_KEEPALIVE: ::std::os::raw::c_uint = 9;
pub const SO_OOBINLINE: ::std::os::raw::c_uint = 10;
pub const SO_NO_CHECK: ::std::os::raw::c_uint = 11;
pub const SO_PRIORITY: ::std::os::raw::c_uint = 12;
pub const SO_LINGER: ::std::os::raw::c_uint = 13;
pub const SO_BSDCOMPAT: ::std::os::raw::c_uint = 14;
pub const SO_REUSEPORT: ::std::os::raw::c_uint = 15;
pub const SO_PASSCRED: ::std::os::raw::c_uint = 16;
pub const SO_PEERCRED: ::std::os::raw::c_uint = 17;
pub const SO_RCVLOWAT: ::std::os::raw::c_uint = 18;
pub const SO_SNDLOWAT: ::std::os::raw::c_uint = 19;
pub const SO_RCVTIMEO: ::std::os::raw::c_uint = 20;
pub const SO_SNDTIMEO: ::std::os::raw::c_uint = 21;
pub const SO_SECURITY_AUTHENTICATION: ::std::os::raw::c_uint = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::std::os::raw::c_uint = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: ::std::os::raw::c_uint = 24;
pub const SO_BINDTODEVICE: ::std::os::raw::c_uint = 25;
pub const SO_ATTACH_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_DETACH_FILTER: ::std::os::raw::c_uint = 27;
pub const SO_GET_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_PEERNAME: ::std::os::raw::c_uint = 28;
pub const SO_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SCM_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SO_ACCEPTCONN: ::std::os::raw::c_uint = 30;
pub const SO_PEERSEC: ::std::os::raw::c_uint = 31;
pub const SO_PASSSEC: ::std::os::raw::c_uint = 34;
pub const SO_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SCM_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SO_MARK: ::std::os::raw::c_uint = 36;
pub const SO_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SCM_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SO_PROTOCOL: ::std::os::raw::c_uint = 38;
pub const SO_DOMAIN: ::std::os::raw::c_uint = 39;
pub const SO_RXQ_OVFL: ::std::os::raw::c_uint = 40;
pub const SO_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SCM_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SO_PEEK_OFF: ::std::os::raw::c_uint = 42;
pub const SO_NOFCS: ::std::os::raw::c_uint = 43;
pub const SO_LOCK_FILTER: ::std::os::raw::c_uint = 44;
pub const SO_SELECT_ERR_QUEUE: ::std::os::raw::c_uint = 45;
pub const SO_BUSY_POLL: ::std::os::raw::c_uint = 46;
pub const SO_MAX_PACING_RATE: ::std::os::raw::c_uint = 47;
pub const SO_BPF_EXTENSIONS: ::std::os::raw::c_uint = 48;
pub const SO_INCOMING_CPU: ::std::os::raw::c_uint = 49;
pub const SO_ATTACH_BPF: ::std::os::raw::c_uint = 50;
pub const SO_DETACH_BPF: ::std::os::raw::c_uint = 27;
pub const IP_OPTIONS: ::std::os::raw::c_uint = 4;
pub const IP_HDRINCL: ::std::os::raw::c_uint = 3;
pub const IP_TOS: ::std::os::raw::c_uint = 1;
pub const IP_TTL: ::std::os::raw::c_uint = 2;
pub const IP_RECVOPTS: ::std::os::raw::c_uint = 6;
pub const IP_RETOPTS: ::std::os::raw::c_uint = 7;
pub const IP_MULTICAST_IF: ::std::os::raw::c_uint = 32;
pub const IP_MULTICAST_TTL: ::std::os::raw::c_uint = 33;
pub const IP_MULTICAST_LOOP: ::std::os::raw::c_uint = 34;
pub const IP_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 35;
pub const IP_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 36;
pub const IP_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 37;
pub const IP_BLOCK_SOURCE: ::std::os::raw::c_uint = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 40;
pub const IP_MSFILTER: ::std::os::raw::c_uint = 41;
pub const MCAST_JOIN_GROUP: ::std::os::raw::c_uint = 42;
pub const MCAST_BLOCK_SOURCE: ::std::os::raw::c_uint = 43;
pub const MCAST_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 44;
pub const MCAST_LEAVE_GROUP: ::std::os::raw::c_uint = 45;
pub const MCAST_JOIN_SOURCE_GROUP: ::std::os::raw::c_uint = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: ::std::os::raw::c_uint = 47;
pub const MCAST_MSFILTER: ::std::os::raw::c_uint = 48;
pub const IP_MULTICAST_ALL: ::std::os::raw::c_uint = 49;
pub const IP_UNICAST_IF: ::std::os::raw::c_uint = 50;
pub const MCAST_EXCLUDE: ::std::os::raw::c_uint = 0;
pub const MCAST_INCLUDE: ::std::os::raw::c_uint = 1;
pub const IP_ROUTER_ALERT: ::std::os::raw::c_uint = 5;
pub const IP_PKTINFO: ::std::os::raw::c_uint = 8;
pub const IP_PKTOPTIONS: ::std::os::raw::c_uint = 9;
pub const IP_PMTUDISC: ::std::os::raw::c_uint = 10;
pub const IP_MTU_DISCOVER: ::std::os::raw::c_uint = 10;
pub const IP_RECVERR: ::std::os::raw::c_uint = 11;
pub const IP_RECVTTL: ::std::os::raw::c_uint = 12;
pub const IP_RECVTOS: ::std::os::raw::c_uint = 13;
pub const IP_MTU: ::std::os::raw::c_uint = 14;
pub const IP_FREEBIND: ::std::os::raw::c_uint = 15;
pub const IP_IPSEC_POLICY: ::std::os::raw::c_uint = 16;
pub const IP_XFRM_POLICY: ::std::os::raw::c_uint = 17;
pub const IP_PASSSEC: ::std::os::raw::c_uint = 18;
pub const IP_TRANSPARENT: ::std::os::raw::c_uint = 19;
pub const IP_ORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_RECVORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_MINTTL: ::std::os::raw::c_uint = 21;
pub const IP_NODEFRAG: ::std::os::raw::c_uint = 22;
pub const IP_CHECKSUM: ::std::os::raw::c_uint = 23;
pub const IP_BIND_ADDRESS_NO_PORT: ::std::os::raw::c_uint = 24;
pub const IP_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IP_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IP_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IP_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IP_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IP_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IP: ::std::os::raw::c_uint = 0;
pub const IP_DEFAULT_MULTICAST_TTL: ::std::os::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: ::std::os::raw::c_uint = 1;
pub const IP_MAX_MEMBERSHIPS: ::std::os::raw::c_uint = 20;
pub const IPV6_ADDRFORM: ::std::os::raw::c_uint = 1;
pub const IPV6_2292PKTINFO: ::std::os::raw::c_uint = 2;
pub const IPV6_2292HOPOPTS: ::std::os::raw::c_uint = 3;
pub const IPV6_2292DSTOPTS: ::std::os::raw::c_uint = 4;
pub const IPV6_2292RTHDR: ::std::os::raw::c_uint = 5;
pub const IPV6_2292PKTOPTIONS: ::std::os::raw::c_uint = 6;
pub const IPV6_CHECKSUM: ::std::os::raw::c_uint = 7;
pub const IPV6_2292HOPLIMIT: ::std::os::raw::c_uint = 8;
pub const IPV6_NEXTHOP: ::std::os::raw::c_uint = 9;
pub const IPV6_AUTHHDR: ::std::os::raw::c_uint = 10;
pub const IPV6_UNICAST_HOPS: ::std::os::raw::c_uint = 16;
pub const IPV6_MULTICAST_IF: ::std::os::raw::c_uint = 17;
pub const IPV6_MULTICAST_HOPS: ::std::os::raw::c_uint = 18;
pub const IPV6_MULTICAST_LOOP: ::std::os::raw::c_uint = 19;
pub const IPV6_JOIN_GROUP: ::std::os::raw::c_uint = 20;
pub const IPV6_LEAVE_GROUP: ::std::os::raw::c_uint = 21;
pub const IPV6_ROUTER_ALERT: ::std::os::raw::c_uint = 22;
pub const IPV6_MTU_DISCOVER: ::std::os::raw::c_uint = 23;
pub const IPV6_MTU: ::std::os::raw::c_uint = 24;
pub const IPV6_RECVERR: ::std::os::raw::c_uint = 25;
pub const IPV6_V6ONLY: ::std::os::raw::c_uint = 26;
pub const IPV6_JOIN_ANYCAST: ::std::os::raw::c_uint = 27;
pub const IPV6_LEAVE_ANYCAST: ::std::os::raw::c_uint = 28;
pub const IPV6_IPSEC_POLICY: ::std::os::raw::c_uint = 34;
pub const IPV6_XFRM_POLICY: ::std::os::raw::c_uint = 35;
pub const IPV6_RECVPKTINFO: ::std::os::raw::c_uint = 49;
pub const IPV6_PKTINFO: ::std::os::raw::c_uint = 50;
pub const IPV6_RECVHOPLIMIT: ::std::os::raw::c_uint = 51;
pub const IPV6_HOPLIMIT: ::std::os::raw::c_uint = 52;
pub const IPV6_RECVHOPOPTS: ::std::os::raw::c_uint = 53;
pub const IPV6_HOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RTHDRDSTOPTS: ::std::os::raw::c_uint = 55;
pub const IPV6_RECVRTHDR: ::std::os::raw::c_uint = 56;
pub const IPV6_RTHDR: ::std::os::raw::c_uint = 57;
pub const IPV6_RECVDSTOPTS: ::std::os::raw::c_uint = 58;
pub const IPV6_DSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_RECVPATHMTU: ::std::os::raw::c_uint = 60;
pub const IPV6_PATHMTU: ::std::os::raw::c_uint = 61;
pub const IPV6_DONTFRAG: ::std::os::raw::c_uint = 62;
pub const IPV6_RECVTCLASS: ::std::os::raw::c_uint = 66;
pub const IPV6_TCLASS: ::std::os::raw::c_uint = 67;
pub const IPV6_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 20;
pub const IPV6_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 21;
pub const IPV6_RXHOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RXDSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IPV6_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IPV6_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IPV6_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IPV6_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IPV6_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IPV6: ::std::os::raw::c_uint = 41;
pub const SOL_ICMPV6: ::std::os::raw::c_uint = 58;
pub const IPV6_RTHDR_LOOSE: ::std::os::raw::c_uint = 0;
pub const IPV6_RTHDR_STRICT: ::std::os::raw::c_uint = 1;
pub const IPV6_RTHDR_TYPE_0: ::std::os::raw::c_uint = 0;
pub const IN_CLASSA_NET: ::std::os::raw::c_uint = 4278190080;
pub const IN_CLASSA_NSHIFT: ::std::os::raw::c_uint = 24;
pub const IN_CLASSA_HOST: ::std::os::raw::c_uint = 16777215;
pub const IN_CLASSA_MAX: ::std::os::raw::c_uint = 128;
pub const IN_CLASSB_NET: ::std::os::raw::c_uint = 4294901760;
pub const IN_CLASSB_NSHIFT: ::std::os::raw::c_uint = 16;
pub const IN_CLASSB_HOST: ::std::os::raw::c_uint = 65535;
pub const IN_CLASSB_MAX: ::std::os::raw::c_uint = 65536;
pub const IN_CLASSC_NET: ::std::os::raw::c_uint = 4294967040;
pub const IN_CLASSC_NSHIFT: ::std::os::raw::c_uint = 8;
pub const IN_CLASSC_HOST: ::std::os::raw::c_uint = 255;
pub const IN_LOOPBACKNET: ::std::os::raw::c_uint = 127;
pub const INET_ADDRSTRLEN: ::std::os::raw::c_uint = 16;
pub const INET6_ADDRSTRLEN: ::std::os::raw::c_uint = 46;
pub const _TERMIOS_H: ::std::os::raw::c_uint = 1;
pub const NCCS: ::std::os::raw::c_uint = 32;
pub const _HAVE_STRUCT_TERMIOS_C_ISPEED: ::std::os::raw::c_uint = 1;
pub const _HAVE_STRUCT_TERMIOS_C_OSPEED: ::std::os::raw::c_uint = 1;
pub const VINTR: ::std::os::raw::c_uint = 0;
pub const VQUIT: ::std::os::raw::c_uint = 1;
pub const VERASE: ::std::os::raw::c_uint = 2;
pub const VKILL: ::std::os::raw::c_uint = 3;
pub const VEOF: ::std::os::raw::c_uint = 4;
pub const VTIME: ::std::os::raw::c_uint = 5;
pub const VMIN: ::std::os::raw::c_uint = 6;
pub const VSWTC: ::std::os::raw::c_uint = 7;
pub const VSTART: ::std::os::raw::c_uint = 8;
pub const VSTOP: ::std::os::raw::c_uint = 9;
pub const VSUSP: ::std::os::raw::c_uint = 10;
pub const VEOL: ::std::os::raw::c_uint = 11;
pub const VREPRINT: ::std::os::raw::c_uint = 12;
pub const VDISCARD: ::std::os::raw::c_uint = 13;
pub const VWERASE: ::std::os::raw::c_uint = 14;
pub const VLNEXT: ::std::os::raw::c_uint = 15;
pub const VEOL2: ::std::os::raw::c_uint = 16;
pub const IGNBRK: ::std::os::raw::c_uint = 1;
pub const BRKINT: ::std::os::raw::c_uint = 2;
pub const IGNPAR: ::std::os::raw::c_uint = 4;
pub const PARMRK: ::std::os::raw::c_uint = 8;
pub const INPCK: ::std::os::raw::c_uint = 16;
pub const ISTRIP: ::std::os::raw::c_uint = 32;
pub const INLCR: ::std::os::raw::c_uint = 64;
pub const IGNCR: ::std::os::raw::c_uint = 128;
pub const ICRNL: ::std::os::raw::c_uint = 256;
pub const IUCLC: ::std::os::raw::c_uint = 512;
pub const IXON: ::std::os::raw::c_uint = 1024;
pub const IXANY: ::std::os::raw::c_uint = 2048;
pub const IXOFF: ::std::os::raw::c_uint = 4096;
pub const IMAXBEL: ::std::os::raw::c_uint = 8192;
pub const IUTF8: ::std::os::raw::c_uint = 16384;
pub const OPOST: ::std::os::raw::c_uint = 1;
pub const OLCUC: ::std::os::raw::c_uint = 2;
pub const ONLCR: ::std::os::raw::c_uint = 4;
pub const OCRNL: ::std::os::raw::c_uint = 8;
pub const ONOCR: ::std::os::raw::c_uint = 16;
pub const ONLRET: ::std::os::raw::c_uint = 32;
pub const OFILL: ::std::os::raw::c_uint = 64;
pub const OFDEL: ::std::os::raw::c_uint = 128;
pub const NLDLY: ::std::os::raw::c_uint = 256;
pub const NL0: ::std::os::raw::c_uint = 0;
pub const NL1: ::std::os::raw::c_uint = 256;
pub const CRDLY: ::std::os::raw::c_uint = 1536;
pub const CR0: ::std::os::raw::c_uint = 0;
pub const CR1: ::std::os::raw::c_uint = 512;
pub const CR2: ::std::os::raw::c_uint = 1024;
pub const CR3: ::std::os::raw::c_uint = 1536;
pub const TABDLY: ::std::os::raw::c_uint = 6144;
pub const TAB0: ::std::os::raw::c_uint = 0;
pub const TAB1: ::std::os::raw::c_uint = 2048;
pub const TAB2: ::std::os::raw::c_uint = 4096;
pub const TAB3: ::std::os::raw::c_uint = 6144;
pub const BSDLY: ::std::os::raw::c_uint = 8192;
pub const BS0: ::std::os::raw::c_uint = 0;
pub const BS1: ::std::os::raw::c_uint = 8192;
pub const FFDLY: ::std::os::raw::c_uint = 32768;
pub const FF0: ::std::os::raw::c_uint = 0;
pub const FF1: ::std::os::raw::c_uint = 32768;
pub const VTDLY: ::std::os::raw::c_uint = 16384;
pub const VT0: ::std::os::raw::c_uint = 0;
pub const VT1: ::std::os::raw::c_uint = 16384;
pub const XTABS: ::std::os::raw::c_uint = 6144;
pub const CBAUD: ::std::os::raw::c_uint = 4111;
pub const B0: ::std::os::raw::c_uint = 0;
pub const B50: ::std::os::raw::c_uint = 1;
pub const B75: ::std::os::raw::c_uint = 2;
pub const B110: ::std::os::raw::c_uint = 3;
pub const B134: ::std::os::raw::c_uint = 4;
pub const B150: ::std::os::raw::c_uint = 5;
pub const B200: ::std::os::raw::c_uint = 6;
pub const B300: ::std::os::raw::c_uint = 7;
pub const B600: ::std::os::raw::c_uint = 8;
pub const B1200: ::std::os::raw::c_uint = 9;
pub const B1800: ::std::os::raw::c_uint = 10;
pub const B2400: ::std::os::raw::c_uint = 11;
pub const B4800: ::std::os::raw::c_uint = 12;
pub const B9600: ::std::os::raw::c_uint = 13;
pub const B19200: ::std::os::raw::c_uint = 14;
pub const B38400: ::std::os::raw::c_uint = 15;
pub const EXTA: ::std::os::raw::c_uint = 14;
pub const EXTB: ::std::os::raw::c_uint = 15;
pub const CSIZE: ::std::os::raw::c_uint = 48;
pub const CS5: ::std::os::raw::c_uint = 0;
pub const CS6: ::std::os::raw::c_uint = 16;
pub const CS7: ::std::os::raw::c_uint = 32;
pub const CS8: ::std::os::raw::c_uint = 48;
pub const CSTOPB: ::std::os::raw::c_uint = 64;
pub const CREAD: ::std::os::raw::c_uint = 128;
pub const PARENB: ::std::os::raw::c_uint = 256;
pub const PARODD: ::std::os::raw::c_uint = 512;
pub const HUPCL: ::std::os::raw::c_uint = 1024;
pub const CLOCAL: ::std::os::raw::c_uint = 2048;
pub const CBAUDEX: ::std::os::raw::c_uint = 4096;
pub const B57600: ::std::os::raw::c_uint = 4097;
pub const B115200: ::std::os::raw::c_uint = 4098;
pub const B230400: ::std::os::raw::c_uint = 4099;
pub const B460800: ::std::os::raw::c_uint = 4100;
pub const B500000: ::std::os::raw::c_uint = 4101;
pub const B576000: ::std::os::raw::c_uint = 4102;
pub const B921600: ::std::os::raw::c_uint = 4103;
pub const B1000000: ::std::os::raw::c_uint = 4104;
pub const B1152000: ::std::os::raw::c_uint = 4105;
pub const B1500000: ::std::os::raw::c_uint = 4106;
pub const B2000000: ::std::os::raw::c_uint = 4107;
pub const B2500000: ::std::os::raw::c_uint = 4108;
pub const B3000000: ::std::os::raw::c_uint = 4109;
pub const B3500000: ::std::os::raw::c_uint = 4110;
pub const B4000000: ::std::os::raw::c_uint = 4111;
pub const __MAX_BAUD: ::std::os::raw::c_uint = 4111;
pub const CIBAUD: ::std::os::raw::c_uint = 269418496;
pub const CMSPAR: ::std::os::raw::c_uint = 1073741824;
pub const CRTSCTS: ::std::os::raw::c_uint = 2147483648;
pub const ISIG: ::std::os::raw::c_uint = 1;
pub const ICANON: ::std::os::raw::c_uint = 2;
pub const XCASE: ::std::os::raw::c_uint = 4;
pub const ECHO: ::std::os::raw::c_uint = 8;
pub const ECHOE: ::std::os::raw::c_uint = 16;
pub const ECHOK: ::std::os::raw::c_uint = 32;
pub const ECHONL: ::std::os::raw::c_uint = 64;
pub const NOFLSH: ::std::os::raw::c_uint = 128;
pub const TOSTOP: ::std::os::raw::c_uint = 256;
pub const ECHOCTL: ::std::os::raw::c_uint = 512;
pub const ECHOPRT: ::std::os::raw::c_uint = 1024;
pub const ECHOKE: ::std::os::raw::c_uint = 2048;
pub const FLUSHO: ::std::os::raw::c_uint = 4096;
pub const PENDIN: ::std::os::raw::c_uint = 16384;
pub const IEXTEN: ::std::os::raw::c_uint = 32768;
pub const EXTPROC: ::std::os::raw::c_uint = 65536;
pub const TCOOFF: ::std::os::raw::c_uint = 0;
pub const TCOON: ::std::os::raw::c_uint = 1;
pub const TCIOFF: ::std::os::raw::c_uint = 2;
pub const TCION: ::std::os::raw::c_uint = 3;
pub const TCIFLUSH: ::std::os::raw::c_uint = 0;
pub const TCOFLUSH: ::std::os::raw::c_uint = 1;
pub const TCIOFLUSH: ::std::os::raw::c_uint = 2;
pub const TCSANOW: ::std::os::raw::c_uint = 0;
pub const TCSADRAIN: ::std::os::raw::c_uint = 1;
pub const TCSAFLUSH: ::std::os::raw::c_uint = 2;
pub const TTYDEF_IFLAG: ::std::os::raw::c_uint = 11554;
pub const TTYDEF_OFLAG: ::std::os::raw::c_uint = 6149;
pub const TTYDEF_LFLAG: ::std::os::raw::c_uint = 35355;
pub const TTYDEF_CFLAG: ::std::os::raw::c_uint = 1440;
pub const TTYDEF_SPEED: ::std::os::raw::c_uint = 13;
pub const CEOL: u8 = b'\x00';
pub const CERASE: ::std::os::raw::c_uint = 127;
pub const CSTATUS: u8 = b'\x00';
pub const CMIN: ::std::os::raw::c_uint = 1;
pub const CQUIT: ::std::os::raw::c_uint = 28;
pub const CTIME: ::std::os::raw::c_uint = 0;
pub const CBRK: u8 = b'\x00';
pub const vt100_bell: &'static [u8; 2usize] = b"\x07\x00";
pub const vt100_bs: &'static [u8; 2usize] = b"\x08\x00";
pub const vt100_bs_clear: &'static [u8; 7usize] = b"\x08 \\010\x00";
pub const vt100_tab: &'static [u8; 2usize] = b"\t\x00";
pub const vt100_crnl: &'static [u8; 3usize] = b"\n\r\x00";
pub const vt100_clear_right: &'static [u8; 5usize] = b"\x1b[0K\x00";
pub const vt100_clear_left: &'static [u8; 5usize] = b"\x1b[1K\x00";
pub const vt100_clear_down: &'static [u8; 5usize] = b"\x1b[0J\x00";
pub const vt100_clear_up: &'static [u8; 5usize] = b"\x1b[1J\x00";
pub const vt100_clear_line: &'static [u8; 5usize] = b"\x1b[2K\x00";
pub const vt100_clear_screen: &'static [u8; 5usize] = b"\x1b[2J\x00";
pub const vt100_up_arr: &'static [u8; 4usize] = b"\x1b[A\x00";
pub const vt100_down_arr: &'static [u8; 4usize] = b"\x1b[B\x00";
pub const vt100_right_arr: &'static [u8; 4usize] = b"\x1b[C\x00";
pub const vt100_left_arr: &'static [u8; 4usize] = b"\x1b[D\x00";
pub const vt100_multi_right: &'static [u8; 6usize] = b"\x1b[%uC\x00";
pub const vt100_multi_left: &'static [u8; 6usize] = b"\x1b[%uD\x00";
pub const vt100_suppr: &'static [u8; 5usize] = b"\x1b[3~\x00";
pub const vt100_home: &'static [u8; 8usize] = b"\x1bM\\033E\x00";
pub const vt100_word_left: &'static [u8; 3usize] = b"\x1bb\x00";
pub const vt100_word_right: &'static [u8; 3usize] = b"\x1bf\x00";
pub const CMDLINE_KEY_UP_ARR: ::std::os::raw::c_uint = 0;
pub const CMDLINE_KEY_DOWN_ARR: ::std::os::raw::c_uint = 1;
pub const CMDLINE_KEY_RIGHT_ARR: ::std::os::raw::c_uint = 2;
pub const CMDLINE_KEY_LEFT_ARR: ::std::os::raw::c_uint = 3;
pub const CMDLINE_KEY_BKSPACE: ::std::os::raw::c_uint = 4;
pub const CMDLINE_KEY_RETURN: ::std::os::raw::c_uint = 5;
pub const CMDLINE_KEY_CTRL_A: ::std::os::raw::c_uint = 6;
pub const CMDLINE_KEY_CTRL_E: ::std::os::raw::c_uint = 7;
pub const CMDLINE_KEY_CTRL_K: ::std::os::raw::c_uint = 8;
pub const CMDLINE_KEY_CTRL_Y: ::std::os::raw::c_uint = 9;
pub const CMDLINE_KEY_CTRL_C: ::std::os::raw::c_uint = 10;
pub const CMDLINE_KEY_CTRL_F: ::std::os::raw::c_uint = 11;
pub const CMDLINE_KEY_CTRL_B: ::std::os::raw::c_uint = 12;
pub const CMDLINE_KEY_SUPPR: ::std::os::raw::c_uint = 13;
pub const CMDLINE_KEY_TAB: ::std::os::raw::c_uint = 14;
pub const CMDLINE_KEY_CTRL_D: ::std::os::raw::c_uint = 15;
pub const CMDLINE_KEY_CTRL_L: ::std::os::raw::c_uint = 16;
pub const CMDLINE_KEY_RETURN2: ::std::os::raw::c_uint = 17;
pub const CMDLINE_KEY_META_BKSPACE: ::std::os::raw::c_uint = 18;
pub const CMDLINE_KEY_WLEFT: ::std::os::raw::c_uint = 19;
pub const CMDLINE_KEY_WRIGHT: ::std::os::raw::c_uint = 20;
pub const CMDLINE_KEY_HELP: ::std::os::raw::c_uint = 21;
pub const CMDLINE_KEY_CTRL_W: ::std::os::raw::c_uint = 22;
pub const CMDLINE_KEY_CTRL_P: ::std::os::raw::c_uint = 23;
pub const CMDLINE_KEY_CTRL_N: ::std::os::raw::c_uint = 24;
pub const CMDLINE_KEY_META_D: ::std::os::raw::c_uint = 25;
pub const CMDLINE_VT100_BUF_SIZE: ::std::os::raw::c_uint = 8;
pub const RDLINE_BUF_SIZE: ::std::os::raw::c_uint = 512;
pub const RDLINE_PROMPT_SIZE: ::std::os::raw::c_uint = 32;
pub const RDLINE_VT100_BUF_SIZE: ::std::os::raw::c_uint = 8;
pub const RDLINE_HISTORY_BUF_SIZE: ::std::os::raw::c_uint = 8192;
pub const RDLINE_HISTORY_MAX_LINE: ::std::os::raw::c_uint = 64;
pub const RDLINE_RES_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RDLINE_RES_VALIDATED: ::std::os::raw::c_uint = 1;
pub const RDLINE_RES_COMPLETE: ::std::os::raw::c_uint = 2;
pub const RDLINE_RES_NOT_RUNNING: ::std::os::raw::c_int = -1;
pub const RDLINE_RES_EOF: ::std::os::raw::c_int = -2;
pub const RDLINE_RES_EXITED: ::std::os::raw::c_int = -3;
pub const CMDLINE_PARSE_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CMDLINE_PARSE_AMBIGUOUS: ::std::os::raw::c_int = -1;
pub const CMDLINE_PARSE_NOMATCH: ::std::os::raw::c_int = -2;
pub const CMDLINE_PARSE_BAD_ARGS: ::std::os::raw::c_int = -3;
pub const CMDLINE_PARSE_COMPLETE_FINISHED: ::std::os::raw::c_uint = 0;
pub const CMDLINE_PARSE_COMPLETE_AGAIN: ::std::os::raw::c_uint = 1;
pub const CMDLINE_PARSE_COMPLETED_BUFFER: ::std::os::raw::c_uint = 2;
pub const CMDLINE_PARSE_RESULT_BUFSIZE: ::std::os::raw::c_uint = 8192;
pub const CMDLINE_IPADDR_V4: ::std::os::raw::c_uint = 1;
pub const CMDLINE_IPADDR_V6: ::std::os::raw::c_uint = 2;
pub const CMDLINE_IPADDR_NETWORK: ::std::os::raw::c_uint = 4;
pub const PORTLIST_TOKEN_SIZE: ::std::os::raw::c_uint = 128;
pub const PORTLIST_MAX_TOKENS: ::std::os::raw::c_uint = 32;
pub const STR_TOKEN_SIZE: ::std::os::raw::c_uint = 128;
pub const STR_MULTI_TOKEN_SIZE: ::std::os::raw::c_uint = 4096;
pub const TOKEN_STRING_MULTI: &'static [u8; 1usize] = b"\x00";
pub const _INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const ____gwchar_t_defined: ::std::os::raw::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const _CTYPE_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _ERRNO_H: ::std::os::raw::c_uint = 1;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EAGAIN: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EDEADLK: ::std::os::raw::c_uint = 35;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 36;
pub const ENOLCK: ::std::os::raw::c_uint = 37;
pub const ENOSYS: ::std::os::raw::c_uint = 38;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 39;
pub const ELOOP: ::std::os::raw::c_uint = 40;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 11;
pub const ENOMSG: ::std::os::raw::c_uint = 42;
pub const EIDRM: ::std::os::raw::c_uint = 43;
pub const ECHRNG: ::std::os::raw::c_uint = 44;
pub const EL2NSYNC: ::std::os::raw::c_uint = 45;
pub const EL3HLT: ::std::os::raw::c_uint = 46;
pub const EL3RST: ::std::os::raw::c_uint = 47;
pub const ELNRNG: ::std::os::raw::c_uint = 48;
pub const EUNATCH: ::std::os::raw::c_uint = 49;
pub const ENOCSI: ::std::os::raw::c_uint = 50;
pub const EL2HLT: ::std::os::raw::c_uint = 51;
pub const EBADE: ::std::os::raw::c_uint = 52;
pub const EBADR: ::std::os::raw::c_uint = 53;
pub const EXFULL: ::std::os::raw::c_uint = 54;
pub const ENOANO: ::std::os::raw::c_uint = 55;
pub const EBADRQC: ::std::os::raw::c_uint = 56;
pub const EBADSLT: ::std::os::raw::c_uint = 57;
pub const EDEADLOCK: ::std::os::raw::c_uint = 35;
pub const EBFONT: ::std::os::raw::c_uint = 59;
pub const ENOSTR: ::std::os::raw::c_uint = 60;
pub const ENODATA: ::std::os::raw::c_uint = 61;
pub const ETIME: ::std::os::raw::c_uint = 62;
pub const ENOSR: ::std::os::raw::c_uint = 63;
pub const ENONET: ::std::os::raw::c_uint = 64;
pub const ENOPKG: ::std::os::raw::c_uint = 65;
pub const EREMOTE: ::std::os::raw::c_uint = 66;
pub const ENOLINK: ::std::os::raw::c_uint = 67;
pub const EADV: ::std::os::raw::c_uint = 68;
pub const ESRMNT: ::std::os::raw::c_uint = 69;
pub const ECOMM: ::std::os::raw::c_uint = 70;
pub const EPROTO: ::std::os::raw::c_uint = 71;
pub const EMULTIHOP: ::std::os::raw::c_uint = 72;
pub const EDOTDOT: ::std::os::raw::c_uint = 73;
pub const EBADMSG: ::std::os::raw::c_uint = 74;
pub const EOVERFLOW: ::std::os::raw::c_uint = 75;
pub const ENOTUNIQ: ::std::os::raw::c_uint = 76;
pub const EBADFD: ::std::os::raw::c_uint = 77;
pub const EREMCHG: ::std::os::raw::c_uint = 78;
pub const ELIBACC: ::std::os::raw::c_uint = 79;
pub const ELIBBAD: ::std::os::raw::c_uint = 80;
pub const ELIBSCN: ::std::os::raw::c_uint = 81;
pub const ELIBMAX: ::std::os::raw::c_uint = 82;
pub const ELIBEXEC: ::std::os::raw::c_uint = 83;
pub const EILSEQ: ::std::os::raw::c_uint = 84;
pub const ERESTART: ::std::os::raw::c_uint = 85;
pub const ESTRPIPE: ::std::os::raw::c_uint = 86;
pub const EUSERS: ::std::os::raw::c_uint = 87;
pub const ENOTSOCK: ::std::os::raw::c_uint = 88;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 89;
pub const EMSGSIZE: ::std::os::raw::c_uint = 90;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 91;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 92;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 94;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 95;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 96;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 97;
pub const EADDRINUSE: ::std::os::raw::c_uint = 98;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 99;
pub const ENETDOWN: ::std::os::raw::c_uint = 100;
pub const ENETUNREACH: ::std::os::raw::c_uint = 101;
pub const ENETRESET: ::std::os::raw::c_uint = 102;
pub const ECONNABORTED: ::std::os::raw::c_uint = 103;
pub const ECONNRESET: ::std::os::raw::c_uint = 104;
pub const ENOBUFS: ::std::os::raw::c_uint = 105;
pub const EISCONN: ::std::os::raw::c_uint = 106;
pub const ENOTCONN: ::std::os::raw::c_uint = 107;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 108;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 109;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 110;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 111;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 112;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 113;
pub const EALREADY: ::std::os::raw::c_uint = 114;
pub const EINPROGRESS: ::std::os::raw::c_uint = 115;
pub const ESTALE: ::std::os::raw::c_uint = 116;
pub const EUCLEAN: ::std::os::raw::c_uint = 117;
pub const ENOTNAM: ::std::os::raw::c_uint = 118;
pub const ENAVAIL: ::std::os::raw::c_uint = 119;
pub const EISNAM: ::std::os::raw::c_uint = 120;
pub const EREMOTEIO: ::std::os::raw::c_uint = 121;
pub const EDQUOT: ::std::os::raw::c_uint = 122;
pub const ENOMEDIUM: ::std::os::raw::c_uint = 123;
pub const EMEDIUMTYPE: ::std::os::raw::c_uint = 124;
pub const ECANCELED: ::std::os::raw::c_uint = 125;
pub const ENOKEY: ::std::os::raw::c_uint = 126;
pub const EKEYEXPIRED: ::std::os::raw::c_uint = 127;
pub const EKEYREVOKED: ::std::os::raw::c_uint = 128;
pub const EKEYREJECTED: ::std::os::raw::c_uint = 129;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 130;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 131;
pub const ERFKILL: ::std::os::raw::c_uint = 132;
pub const EHWPOISON: ::std::os::raw::c_uint = 133;
pub const ENOTSUP: ::std::os::raw::c_uint = 95;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _MM_HINT_T0: ::std::os::raw::c_uint = 3;
pub const _MM_HINT_T1: ::std::os::raw::c_uint = 2;
pub const _MM_HINT_T2: ::std::os::raw::c_uint = 1;
pub const _MM_HINT_NTA: ::std::os::raw::c_uint = 0;
pub const _MM_EXCEPT_INVALID: ::std::os::raw::c_uint = 1;
pub const _MM_EXCEPT_DENORM: ::std::os::raw::c_uint = 2;
pub const _MM_EXCEPT_DIV_ZERO: ::std::os::raw::c_uint = 4;
pub const _MM_EXCEPT_OVERFLOW: ::std::os::raw::c_uint = 8;
pub const _MM_EXCEPT_UNDERFLOW: ::std::os::raw::c_uint = 16;
pub const _MM_EXCEPT_INEXACT: ::std::os::raw::c_uint = 32;
pub const _MM_EXCEPT_MASK: ::std::os::raw::c_uint = 63;
pub const _MM_MASK_INVALID: ::std::os::raw::c_uint = 128;
pub const _MM_MASK_DENORM: ::std::os::raw::c_uint = 256;
pub const _MM_MASK_DIV_ZERO: ::std::os::raw::c_uint = 512;
pub const _MM_MASK_OVERFLOW: ::std::os::raw::c_uint = 1024;
pub const _MM_MASK_UNDERFLOW: ::std::os::raw::c_uint = 2048;
pub const _MM_MASK_INEXACT: ::std::os::raw::c_uint = 4096;
pub const _MM_MASK_MASK: ::std::os::raw::c_uint = 8064;
pub const _MM_ROUND_NEAREST: ::std::os::raw::c_uint = 0;
pub const _MM_ROUND_DOWN: ::std::os::raw::c_uint = 8192;
pub const _MM_ROUND_UP: ::std::os::raw::c_uint = 16384;
pub const _MM_ROUND_TOWARD_ZERO: ::std::os::raw::c_uint = 24576;
pub const _MM_ROUND_MASK: ::std::os::raw::c_uint = 24576;
pub const _MM_FLUSH_ZERO_MASK: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_ON: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_OFF: ::std::os::raw::c_uint = 0;
pub const _MM_DENORMALS_ZERO_ON: ::std::os::raw::c_uint = 64;
pub const _MM_DENORMALS_ZERO_OFF: ::std::os::raw::c_uint = 0;
pub const _MM_DENORMALS_ZERO_MASK: ::std::os::raw::c_uint = 64;
pub const _MM_FROUND_TO_NEAREST_INT: ::std::os::raw::c_uint = 0;
pub const _MM_FROUND_TO_NEG_INF: ::std::os::raw::c_uint = 1;
pub const _MM_FROUND_TO_POS_INF: ::std::os::raw::c_uint = 2;
pub const _MM_FROUND_TO_ZERO: ::std::os::raw::c_uint = 3;
pub const _MM_FROUND_CUR_DIRECTION: ::std::os::raw::c_uint = 4;
pub const _MM_FROUND_RAISE_EXC: ::std::os::raw::c_uint = 0;
pub const _MM_FROUND_NO_EXC: ::std::os::raw::c_uint = 8;
pub const _MM_FROUND_NINT: ::std::os::raw::c_uint = 0;
pub const _MM_FROUND_FLOOR: ::std::os::raw::c_uint = 1;
pub const _MM_FROUND_CEIL: ::std::os::raw::c_uint = 2;
pub const _MM_FROUND_TRUNC: ::std::os::raw::c_uint = 3;
pub const _MM_FROUND_RINT: ::std::os::raw::c_uint = 4;
pub const _MM_FROUND_NEARBYINT: ::std::os::raw::c_uint = 12;
pub const _SIDD_UBYTE_OPS: ::std::os::raw::c_uint = 0;
pub const _SIDD_UWORD_OPS: ::std::os::raw::c_uint = 1;
pub const _SIDD_SBYTE_OPS: ::std::os::raw::c_uint = 2;
pub const _SIDD_SWORD_OPS: ::std::os::raw::c_uint = 3;
pub const _SIDD_CMP_EQUAL_ANY: ::std::os::raw::c_uint = 0;
pub const _SIDD_CMP_RANGES: ::std::os::raw::c_uint = 4;
pub const _SIDD_CMP_EQUAL_EACH: ::std::os::raw::c_uint = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: ::std::os::raw::c_uint = 12;
pub const _SIDD_POSITIVE_POLARITY: ::std::os::raw::c_uint = 0;
pub const _SIDD_NEGATIVE_POLARITY: ::std::os::raw::c_uint = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: ::std::os::raw::c_uint = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: ::std::os::raw::c_uint = 48;
pub const _SIDD_LEAST_SIGNIFICANT: ::std::os::raw::c_uint = 0;
pub const _SIDD_MOST_SIGNIFICANT: ::std::os::raw::c_uint = 64;
pub const _SIDD_BIT_MASK: ::std::os::raw::c_uint = 0;
pub const _SIDD_UNIT_MASK: ::std::os::raw::c_uint = 64;
pub const RTE_EXEC_ENV: &'static [u8; 9usize] = b"linuxapp\x00";
pub const RTE_ARCH: &'static [u8; 7usize] = b"x86_64\x00";
pub const RTE_MACHINE: &'static [u8; 7usize] = b"native\x00";
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\x00";
pub const RTE_BUILD_SHARED_LIB: ::std::os::raw::c_uint = 1;
pub const RTE_NEXT_ABI: ::std::os::raw::c_uint = 1;
pub const RTE_CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_EAL: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_LCORE: ::std::os::raw::c_uint = 128;
pub const RTE_MAX_NUMA_NODES: ::std::os::raw::c_uint = 8;
pub const RTE_MAX_MEMSEG: ::std::os::raw::c_uint = 256;
pub const RTE_MAX_MEMZONE: ::std::os::raw::c_uint = 2560;
pub const RTE_MAX_TAILQ: ::std::os::raw::c_uint = 32;
pub const RTE_LOG_HISTORY: ::std::os::raw::c_uint = 256;
pub const RTE_BACKTRACE: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_IGB_UIO: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_VFIO: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: ::std::os::raw::c_uint = 1;
pub const RTE_ENABLE_AVX: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 1usize] = b"\x00";
pub const RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_KVARGS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ETHER: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_ETHPORTS: ::std::os::raw::c_uint = 32;
pub const RTE_MAX_QUEUES_PER_PORT: ::std::os::raw::c_uint = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: ::std::os::raw::c_uint = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ENA_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_EM_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IGB_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IXGBE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_I40E_ITR_INTERVAL: ::std::os::raw::c_int = -1;
pub const RTE_LIBRTE_FM10K_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MLX4_SGE_WR_N: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_MLX4_MAX_INLINE: ::std::os::raw::c_uint = 0;
pub const RTE_LIBRTE_MLX4_TX_MP_CACHE: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_MLX4_SOFT_COUNTERS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MLX5_TX_MP_CACHE: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_CXGBE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CXGBE_TPUT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ENIC_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_NFP_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_BNXT_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_SFC_EFX_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_SZEDATA2_AS: ::std::os::raw::c_uint = 0;
pub const RTE_LIBRTE_THUNDERX_NICVF_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_LIO_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_DPAA2_USE_PHYS_IOVA: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_VIRTIO_USER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_RING: ::std::os::raw::c_uint = 1;
pub const RTE_PMD_RING_MAX_RX_RINGS: ::std::os::raw::c_uint = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: ::std::os::raw::c_uint = 16;
pub const RTE_LIBRTE_PMD_PCAP: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_QEDE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\x00";
pub const RTE_LIBRTE_PMD_AF_PACKET: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ARK_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ARK_PAD_TX: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_AVP_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_AVP_DEBUG_DRIVER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_TAP: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_NULL: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_FAILSAFE: ::std::os::raw::c_uint = 1;
pub const RTE_PMD_PACKET_PREFETCH: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CRYPTODEV: ::std::os::raw::c_uint = 1;
pub const RTE_CRYPTO_MAX_DEVS: ::std::os::raw::c_uint = 64;
pub const RTE_CRYPTODEV_NAME_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_QAT_PMD_MAX_NB_SESSIONS: ::std::os::raw::c_uint = 2048;
pub const RTE_LIBRTE_PMD_CRYPTO_SCHEDULER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_EVENTDEV: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_MAX_DEVS: ::std::os::raw::c_uint = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_PMD_SKELETON_EVENTDEV: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_SW_EVENTDEV: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_SSOVF: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_RING: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MEMPOOL: ::std::os::raw::c_uint = 1;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: ::std::os::raw::c_uint = 512;
pub const RTE_DRIVER_MEMPOOL_RING: ::std::os::raw::c_uint = 1;
pub const RTE_DRIVER_MEMPOOL_STACK: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MBUF: ::std::os::raw::c_uint = 1;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] =
    b"ring_mp_mc\x00";
pub const RTE_MBUF_REFCNT_ATOMIC: ::std::os::raw::c_uint = 1;
pub const RTE_PKTMBUF_HEADROOM: ::std::os::raw::c_uint = 128;
pub const RTE_LIBRTE_TIMER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CFGFILE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CMDLINE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_HASH: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_EFD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_JOBSTATS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_METRICS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_BITRATE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_LATENCY_STATS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_LPM: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ACL: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_POWER: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_LCORE_FREQS: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_NET: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IP_FRAG: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_GRO: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_METER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_SCHED: ::std::os::raw::c_uint = 1;
pub const RTE_SCHED_PORT_N_GRINDERS: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_DISTRIBUTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_REORDER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PORT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_TABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PIPELINE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_KNI: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_KNI: ::std::os::raw::c_uint = 1;
pub const RTE_KNI_KMOD: ::std::os::raw::c_uint = 1;
pub const RTE_KNI_PREEMPT_DEFAULT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PDUMP: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VHOST: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VHOST_NUMA: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_VHOST: ::std::os::raw::c_uint = 1;
pub const RTE_APP_CRYPTO_PERF: ::std::os::raw::c_uint = 1;
pub const RTE_APP_EVENTDEV: ::std::os::raw::c_uint = 1;
pub const RTE_EXEC_ENV_LINUXAPP: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_X86_64: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_X86: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_64: ::std::os::raw::c_uint = 1;
pub const RTE_TOOLCHAIN_GCC: ::std::os::raw::c_uint = 1;
pub const DOM0_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const DOM0_MM_DEV: &'static [u8; 13usize] = b"/dev/dom0_mm\x00";
pub const DOM0_CONTIG_NUM_ORDER: ::std::os::raw::c_uint = 9;
pub const DOM0_NUM_MEMSEG: ::std::os::raw::c_uint = 512;
pub const DOM0_MEMBLOCK_SIZE: ::std::os::raw::c_uint = 2097152;
pub const DOM0_CONFIG_MEMSIZE: ::std::os::raw::c_uint = 4096;
pub const DOM0_NUM_MEMBLOCK: ::std::os::raw::c_uint = 2048;
pub const SOCKET_ID_ANY: ::std::os::raw::c_int = -1;
pub const RTE_CACHE_LINE_MASK: ::std::os::raw::c_uint = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: ::std::os::raw::c_uint = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_LOGTYPE_EAL: ::std::os::raw::c_uint = 0;
pub const RTE_LOGTYPE_MALLOC: ::std::os::raw::c_uint = 1;
pub const RTE_LOGTYPE_RING: ::std::os::raw::c_uint = 2;
pub const RTE_LOGTYPE_MEMPOOL: ::std::os::raw::c_uint = 3;
pub const RTE_LOGTYPE_TIMER: ::std::os::raw::c_uint = 4;
pub const RTE_LOGTYPE_PMD: ::std::os::raw::c_uint = 5;
pub const RTE_LOGTYPE_HASH: ::std::os::raw::c_uint = 6;
pub const RTE_LOGTYPE_LPM: ::std::os::raw::c_uint = 7;
pub const RTE_LOGTYPE_KNI: ::std::os::raw::c_uint = 8;
pub const RTE_LOGTYPE_ACL: ::std::os::raw::c_uint = 9;
pub const RTE_LOGTYPE_POWER: ::std::os::raw::c_uint = 10;
pub const RTE_LOGTYPE_METER: ::std::os::raw::c_uint = 11;
pub const RTE_LOGTYPE_SCHED: ::std::os::raw::c_uint = 12;
pub const RTE_LOGTYPE_PORT: ::std::os::raw::c_uint = 13;
pub const RTE_LOGTYPE_TABLE: ::std::os::raw::c_uint = 14;
pub const RTE_LOGTYPE_PIPELINE: ::std::os::raw::c_uint = 15;
pub const RTE_LOGTYPE_MBUF: ::std::os::raw::c_uint = 16;
pub const RTE_LOGTYPE_CRYPTODEV: ::std::os::raw::c_uint = 17;
pub const RTE_LOGTYPE_EFD: ::std::os::raw::c_uint = 18;
pub const RTE_LOGTYPE_EVENTDEV: ::std::os::raw::c_uint = 19;
pub const RTE_LOGTYPE_USER1: ::std::os::raw::c_uint = 24;
pub const RTE_LOGTYPE_USER2: ::std::os::raw::c_uint = 25;
pub const RTE_LOGTYPE_USER3: ::std::os::raw::c_uint = 26;
pub const RTE_LOGTYPE_USER4: ::std::os::raw::c_uint = 27;
pub const RTE_LOGTYPE_USER5: ::std::os::raw::c_uint = 28;
pub const RTE_LOGTYPE_USER6: ::std::os::raw::c_uint = 29;
pub const RTE_LOGTYPE_USER7: ::std::os::raw::c_uint = 30;
pub const RTE_LOGTYPE_USER8: ::std::os::raw::c_uint = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: ::std::os::raw::c_uint = 32;
pub const RTE_LOG_EMERG: ::std::os::raw::c_uint = 1;
pub const RTE_LOG_ALERT: ::std::os::raw::c_uint = 2;
pub const RTE_LOG_CRIT: ::std::os::raw::c_uint = 3;
pub const RTE_LOG_ERR: ::std::os::raw::c_uint = 4;
pub const RTE_LOG_WARNING: ::std::os::raw::c_uint = 5;
pub const RTE_LOG_NOTICE: ::std::os::raw::c_uint = 6;
pub const RTE_LOG_INFO: ::std::os::raw::c_uint = 7;
pub const RTE_LOG_DEBUG: ::std::os::raw::c_uint = 8;
pub const ALIGNMENT_MASK: ::std::os::raw::c_uint = 15;
pub const RTE_BIG_ENDIAN: ::std::os::raw::c_uint = 1;
pub const RTE_LITTLE_ENDIAN: ::std::os::raw::c_uint = 2;
pub const RTE_BYTE_ORDER: ::std::os::raw::c_uint = 2;
pub const RTE_MEMZONE_2MB: ::std::os::raw::c_uint = 1;
pub const RTE_MEMZONE_1GB: ::std::os::raw::c_uint = 2;
pub const RTE_MEMZONE_16MB: ::std::os::raw::c_uint = 256;
pub const RTE_MEMZONE_16GB: ::std::os::raw::c_uint = 512;
pub const RTE_MEMZONE_256KB: ::std::os::raw::c_uint = 65536;
pub const RTE_MEMZONE_256MB: ::std::os::raw::c_uint = 131072;
pub const RTE_MEMZONE_512MB: ::std::os::raw::c_uint = 262144;
pub const RTE_MEMZONE_4GB: ::std::os::raw::c_uint = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: ::std::os::raw::c_uint = 4;
pub const RTE_MEMZONE_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const _SCHED_H: ::std::os::raw::c_uint = 1;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 0;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 1;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __defined_schedparam: ::std::os::raw::c_uint = 1;
pub const __CPU_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _PTHREAD_H: ::std::os::raw::c_uint = 1;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::std::os::raw::c_int = -1;
pub const RTE_MAGIC: ::std::os::raw::c_uint = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: ::std::os::raw::c_uint = 16;
pub const RTE_TAILQ_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const LCORE_ID_ANY: ::std::os::raw::c_uint = 4294967295;
pub const _RTE_RTM_H_: ::std::os::raw::c_uint = 1;
pub const RTE_XBEGIN_STARTED: ::std::os::raw::c_int = -1;
pub const RTE_XABORT_EXPLICIT: ::std::os::raw::c_uint = 1;
pub const RTE_XABORT_RETRY: ::std::os::raw::c_uint = 2;
pub const RTE_XABORT_CONFLICT: ::std::os::raw::c_uint = 4;
pub const RTE_XABORT_CAPACITY: ::std::os::raw::c_uint = 8;
pub const RTE_XABORT_DEBUG: ::std::os::raw::c_uint = 16;
pub const RTE_XABORT_NESTED: ::std::os::raw::c_uint = 32;
pub const RTE_RTM_MAX_RETRIES: ::std::os::raw::c_uint = 10;
pub const RTE_XABORT_LOCK_BUSY: ::std::os::raw::c_uint = 255;
pub const RTE_HEAP_NUM_FREELISTS: ::std::os::raw::c_uint = 13;
pub const MPLOCKED: &'static [u8; 8usize] = b"lock ; \x00";
pub const __ELASTERROR: ::std::os::raw::c_uint = 1000;
pub const RTE_ACL_MAX_CATEGORIES: ::std::os::raw::c_uint = 16;
pub const RTE_ACL_MAX_LEVELS: ::std::os::raw::c_uint = 64;
pub const RTE_ACL_MAX_FIELDS: ::std::os::raw::c_uint = 64;
pub const RTE_ACL_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\x00";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\x00";
pub const PROD_ALIGN: ::std::os::raw::c_uint = 128;
pub const CONS_ALIGN: ::std::os::raw::c_uint = 128;
pub const RING_F_SP_ENQ: ::std::os::raw::c_uint = 1;
pub const RING_F_SC_DEQ: ::std::os::raw::c_uint = 2;
pub const RING_F_EXACT_SZ: ::std::os::raw::c_uint = 4;
pub const __IS_SP: ::std::os::raw::c_uint = 1;
pub const __IS_MP: ::std::os::raw::c_uint = 0;
pub const __IS_SC: ::std::os::raw::c_uint = 1;
pub const __IS_MC: ::std::os::raw::c_uint = 0;
pub const RTE_MEMPOOL_HEADER_COOKIE1: ::std::os::raw::c_longlong =
    -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: ::std::os::raw::c_longlong =
    -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: ::std::os::raw::c_longlong =
    -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\x00";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\x00";
pub const MEMPOOL_PG_NUM_DEFAULT: ::std::os::raw::c_uint = 1;
pub const RTE_MEMPOOL_ALIGN: ::std::os::raw::c_uint = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: ::std::os::raw::c_uint = 63;
pub const MEMPOOL_F_NO_SPREAD: ::std::os::raw::c_uint = 1;
pub const MEMPOOL_F_NO_CACHE_ALIGN: ::std::os::raw::c_uint = 2;
pub const MEMPOOL_F_SP_PUT: ::std::os::raw::c_uint = 4;
pub const MEMPOOL_F_SC_GET: ::std::os::raw::c_uint = 8;
pub const MEMPOOL_F_POOL_CREATED: ::std::os::raw::c_uint = 16;
pub const MEMPOOL_F_NO_PHYS_CONTIG: ::std::os::raw::c_uint = 32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_MEMPOOL_MAX_OPS_IDX: ::std::os::raw::c_uint = 16;
pub const RTE_PTYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const RTE_PTYPE_L2_ETHER: ::std::os::raw::c_uint = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: ::std::os::raw::c_uint = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: ::std::os::raw::c_uint = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: ::std::os::raw::c_uint = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: ::std::os::raw::c_uint = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: ::std::os::raw::c_uint = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: ::std::os::raw::c_uint = 7;
pub const RTE_PTYPE_L2_MASK: ::std::os::raw::c_uint = 15;
pub const RTE_PTYPE_L3_IPV4: ::std::os::raw::c_uint = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: ::std::os::raw::c_uint = 48;
pub const RTE_PTYPE_L3_IPV6: ::std::os::raw::c_uint = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: ::std::os::raw::c_uint = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: ::std::os::raw::c_uint = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: ::std::os::raw::c_uint = 224;
pub const RTE_PTYPE_L3_MASK: ::std::os::raw::c_uint = 240;
pub const RTE_PTYPE_L4_TCP: ::std::os::raw::c_uint = 256;
pub const RTE_PTYPE_L4_UDP: ::std::os::raw::c_uint = 512;
pub const RTE_PTYPE_L4_FRAG: ::std::os::raw::c_uint = 768;
pub const RTE_PTYPE_L4_SCTP: ::std::os::raw::c_uint = 1024;
pub const RTE_PTYPE_L4_ICMP: ::std::os::raw::c_uint = 1280;
pub const RTE_PTYPE_L4_NONFRAG: ::std::os::raw::c_uint = 1536;
pub const RTE_PTYPE_L4_MASK: ::std::os::raw::c_uint = 3840;
pub const RTE_PTYPE_TUNNEL_IP: ::std::os::raw::c_uint = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: ::std::os::raw::c_uint = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: ::std::os::raw::c_uint = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: ::std::os::raw::c_uint = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: ::std::os::raw::c_uint = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: ::std::os::raw::c_uint = 24576;
pub const RTE_PTYPE_TUNNEL_MASK: ::std::os::raw::c_uint = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: ::std::os::raw::c_uint = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: ::std::os::raw::c_uint = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: ::std::os::raw::c_uint = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: ::std::os::raw::c_uint = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: ::std::os::raw::c_uint = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: ::std::os::raw::c_uint = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: ::std::os::raw::c_uint = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: ::std::os::raw::c_uint =
    4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: ::std::os::raw::c_uint = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: ::std::os::raw::c_uint =
    6291456;
pub const RTE_PTYPE_INNER_L3_MASK: ::std::os::raw::c_uint = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: ::std::os::raw::c_uint = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: ::std::os::raw::c_uint = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: ::std::os::raw::c_uint = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: ::std::os::raw::c_uint = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: ::std::os::raw::c_uint = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: ::std::os::raw::c_uint = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: ::std::os::raw::c_uint = 251658240;
pub const RTE_PTYPE_ALL_MASK: ::std::os::raw::c_uint = 268435455;
pub const PKT_RX_VLAN_PKT: ::std::os::raw::c_uint = 1;
pub const PKT_RX_RSS_HASH: ::std::os::raw::c_uint = 2;
pub const PKT_RX_FDIR: ::std::os::raw::c_uint = 4;
pub const PKT_RX_L4_CKSUM_BAD: ::std::os::raw::c_uint = 8;
pub const PKT_RX_IP_CKSUM_BAD: ::std::os::raw::c_uint = 16;
pub const PKT_RX_EIP_CKSUM_BAD: ::std::os::raw::c_uint = 32;
pub const PKT_RX_VLAN_STRIPPED: ::std::os::raw::c_uint = 64;
pub const PKT_RX_IP_CKSUM_MASK: ::std::os::raw::c_uint = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const PKT_RX_IP_CKSUM_GOOD: ::std::os::raw::c_uint = 128;
pub const PKT_RX_IP_CKSUM_NONE: ::std::os::raw::c_uint = 144;
pub const PKT_RX_L4_CKSUM_MASK: ::std::os::raw::c_uint = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const PKT_RX_L4_CKSUM_GOOD: ::std::os::raw::c_uint = 256;
pub const PKT_RX_L4_CKSUM_NONE: ::std::os::raw::c_uint = 264;
pub const PKT_RX_IEEE1588_PTP: ::std::os::raw::c_uint = 512;
pub const PKT_RX_IEEE1588_TMST: ::std::os::raw::c_uint = 1024;
pub const PKT_RX_FDIR_ID: ::std::os::raw::c_uint = 8192;
pub const PKT_RX_FDIR_FLX: ::std::os::raw::c_uint = 16384;
pub const PKT_RX_QINQ_STRIPPED: ::std::os::raw::c_uint = 32768;
pub const PKT_RX_QINQ_PKT: ::std::os::raw::c_uint = 32768;
pub const PKT_RX_LRO: ::std::os::raw::c_uint = 65536;
pub const PKT_RX_TIMESTAMP: ::std::os::raw::c_uint = 131072;
pub const PKT_TX_MACSEC: ::std::os::raw::c_ulonglong = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: ::std::os::raw::c_ulonglong = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: ::std::os::raw::c_ulonglong = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: ::std::os::raw::c_ulonglong = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: ::std::os::raw::c_ulonglong = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: ::std::os::raw::c_ulonglong =
    175921860444160;
pub const PKT_TX_TUNNEL_MASK: ::std::os::raw::c_ulonglong = 527765581332480;
pub const PKT_TX_QINQ_PKT: ::std::os::raw::c_ulonglong = 562949953421312;
pub const PKT_TX_TCP_SEG: ::std::os::raw::c_ulonglong = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: ::std::os::raw::c_ulonglong =
    2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: ::std::os::raw::c_uint = 0;
pub const PKT_TX_TCP_CKSUM: ::std::os::raw::c_ulonglong = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: ::std::os::raw::c_ulonglong = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const PKT_TX_L4_MASK: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const PKT_TX_IP_CKSUM: ::std::os::raw::c_ulonglong = 18014398509481984;
pub const PKT_TX_IPV4: ::std::os::raw::c_ulonglong = 36028797018963968;
pub const PKT_TX_IPV6: ::std::os::raw::c_ulonglong = 72057594037927936;
pub const PKT_TX_VLAN_PKT: ::std::os::raw::c_ulonglong = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: ::std::os::raw::c_ulonglong =
    288230376151711744;
pub const PKT_TX_OUTER_IPV4: ::std::os::raw::c_ulonglong = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: ::std::os::raw::c_ulonglong =
    1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: ::std::os::raw::c_ulonglong =
    468356769060487168;
pub const __RESERVED: ::std::os::raw::c_ulonglong = 2305843009213693952;
pub const IND_ATTACHED_MBUF: ::std::os::raw::c_ulonglong =
    4611686018427387904;
pub const CTRL_MBUF_FLAG: ::std::os::raw::c_longlong = -9223372036854775808;
pub const RTE_MBUF_PRIV_ALIGN: ::std::os::raw::c_uint = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: ::std::os::raw::c_uint = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: ::std::os::raw::c_uint = 2176;
pub const ETHER_ADDR_LEN: ::std::os::raw::c_uint = 6;
pub const ETHER_TYPE_LEN: ::std::os::raw::c_uint = 2;
pub const ETHER_CRC_LEN: ::std::os::raw::c_uint = 4;
pub const ETHER_HDR_LEN: ::std::os::raw::c_uint = 14;
pub const ETHER_MIN_LEN: ::std::os::raw::c_uint = 64;
pub const ETHER_MAX_LEN: ::std::os::raw::c_uint = 1518;
pub const ETHER_MTU: ::std::os::raw::c_uint = 1500;
pub const ETHER_MAX_VLAN_FRAME_LEN: ::std::os::raw::c_uint = 1522;
pub const ETHER_MAX_JUMBO_FRAME_LEN: ::std::os::raw::c_uint = 16128;
pub const ETHER_MAX_VLAN_ID: ::std::os::raw::c_uint = 4095;
pub const ETHER_MIN_MTU: ::std::os::raw::c_uint = 68;
pub const ETHER_LOCAL_ADMIN_ADDR: ::std::os::raw::c_uint = 2;
pub const ETHER_GROUP_ADDR: ::std::os::raw::c_uint = 1;
pub const ETHER_ADDR_FMT_SIZE: ::std::os::raw::c_uint = 18;
pub const ETHER_TYPE_IPv4: ::std::os::raw::c_uint = 2048;
pub const ETHER_TYPE_IPv6: ::std::os::raw::c_uint = 34525;
pub const ETHER_TYPE_ARP: ::std::os::raw::c_uint = 2054;
pub const ETHER_TYPE_RARP: ::std::os::raw::c_uint = 32821;
pub const ETHER_TYPE_VLAN: ::std::os::raw::c_uint = 33024;
pub const ETHER_TYPE_QINQ: ::std::os::raw::c_uint = 34984;
pub const ETHER_TYPE_1588: ::std::os::raw::c_uint = 35063;
pub const ETHER_TYPE_SLOW: ::std::os::raw::c_uint = 34825;
pub const ETHER_TYPE_TEB: ::std::os::raw::c_uint = 25944;
pub const ETHER_TYPE_LLDP: ::std::os::raw::c_uint = 35020;
pub const ARP_HRD_ETHER: ::std::os::raw::c_uint = 1;
pub const ARP_OP_REQUEST: ::std::os::raw::c_uint = 1;
pub const ARP_OP_REPLY: ::std::os::raw::c_uint = 2;
pub const ARP_OP_REVREQUEST: ::std::os::raw::c_uint = 3;
pub const ARP_OP_REVREPLY: ::std::os::raw::c_uint = 4;
pub const ARP_OP_INVREQUEST: ::std::os::raw::c_uint = 8;
pub const ARP_OP_INVREPLY: ::std::os::raw::c_uint = 9;
pub const RTE_AVP_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_AVP_ALIASSIZE: ::std::os::raw::c_uint = 128;
pub const RTE_AVP_DRIVER_TYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_DRIVER_TYPE_DPDK: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_DRIVER_TYPE_KERNEL: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_DRIVER_TYPE_QEMU: ::std::os::raw::c_uint = 3;
pub const RTE_AVP_MODE_HOST: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MODE_GUEST: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MODE_TRACE: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_FEATURE_VLAN_OFFLOAD: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_TX_VLAN_PKT: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_RX_VLAN_PKT: ::std::os::raw::c_uint = 2048;
pub const RTE_AVP_PCI_VENDOR_ID: ::std::os::raw::c_uint = 6900;
pub const RTE_AVP_PCI_DEVICE_ID: ::std::os::raw::c_uint = 4368;
pub const RTE_AVP_PCI_SUB_VENDOR_ID: ::std::os::raw::c_uint = 6900;
pub const RTE_AVP_PCI_SUB_DEVICE_ID: ::std::os::raw::c_uint = 4356;
pub const RTE_AVP_PCI_MMIO_BAR: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_PCI_MSIX_BAR: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_PCI_MEMORY_BAR: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_PCI_MEMMAP_BAR: ::std::os::raw::c_uint = 4;
pub const RTE_AVP_PCI_DEVICE_BAR: ::std::os::raw::c_uint = 5;
pub const RTE_AVP_PCI_MAX_BAR: ::std::os::raw::c_uint = 6;
pub const RTE_AVP_MMIO_BAR_NAME: &'static [u8; 9usize] = b"avp-mmio\x00";
pub const RTE_AVP_MSIX_BAR_NAME: &'static [u8; 9usize] = b"avp-msix\x00";
pub const RTE_AVP_MEMORY_BAR_NAME: &'static [u8; 11usize] = b"avp-memory\x00";
pub const RTE_AVP_MEMMAP_BAR_NAME: &'static [u8; 11usize] = b"avp-memmap\x00";
pub const RTE_AVP_DEVICE_BAR_NAME: &'static [u8; 11usize] = b"avp-device\x00";
pub const RTE_AVP_MIGRATION_MSIX_VECTOR: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MAX_MSIX_VECTORS: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MIGRATION_NONE: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MIGRATION_DETACHED: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MIGRATION_ATTACHED: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_MIGRATION_ERROR: ::std::os::raw::c_uint = 3;
pub const RTE_AVP_REGISTER_BASE: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_INTERRUPT_MASK_OFFSET: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_INTERRUPT_STATUS_OFFSET: ::std::os::raw::c_uint = 4;
pub const RTE_AVP_MIGRATION_STATUS_OFFSET: ::std::os::raw::c_uint = 8;
pub const RTE_AVP_MIGRATION_ACK_OFFSET: ::std::os::raw::c_uint = 12;
pub const RTE_AVP_MIGRATION_INTERRUPT_MASK: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_APP_INTERRUPTS_MASK: ::std::os::raw::c_uint = 4294967295;
pub const RTE_AVP_NO_INTERRUPTS_MASK: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MAX_MAPS: ::std::os::raw::c_uint = 2048;
pub const RTE_AVP_MEMMAP_MAGIC: ::std::os::raw::c_uint = 538122601;
pub const RTE_AVP_MEMMAP_VERSION_1: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MEMMAP_VERSION: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_DEVICE_MAGIC: ::std::os::raw::c_uint = 538122613;
pub const RTE_AVP_RELEASE_VERSION_1: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_RELEASE_VERSION: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MAJOR_VERSION_0: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MAJOR_VERSION_1: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MAJOR_VERSION_2: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_MAJOR_VERSION: ::std::os::raw::c_uint = 2;
pub const RTE_AVP_MINOR_VERSION_0: ::std::os::raw::c_uint = 0;
pub const RTE_AVP_MINOR_VERSION_1: ::std::os::raw::c_uint = 1;
pub const RTE_AVP_MINOR_VERSION_13: ::std::os::raw::c_uint = 13;
pub const RTE_AVP_MINOR_VERSION: ::std::os::raw::c_uint = 13;
pub const RTE_AVP_MAX_MEMPOOLS: ::std::os::raw::c_uint = 8;
pub const RTE_AVP_MAX_QUEUES: ::std::os::raw::c_uint = 8;
pub const RTE_AVP_MAX_MBUF_SEGMENTS: ::std::os::raw::c_uint = 5;
pub const RTE_AVP_DEVICE: &'static [u8; 4usize] = b"avp\x00";
pub const RTE_BITMAP_OPTIMIZATIONS: ::std::os::raw::c_uint = 1;
pub const RTE_BITMAP_SLAB_BIT_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_BITMAP_SLAB_BIT_SIZE_LOG2: ::std::os::raw::c_uint = 6;
pub const RTE_BITMAP_SLAB_BIT_MASK: ::std::os::raw::c_uint = 63;
pub const RTE_BITMAP_CL_BIT_SIZE: ::std::os::raw::c_uint = 512;
pub const RTE_BITMAP_CL_BIT_SIZE_LOG2: ::std::os::raw::c_uint = 9;
pub const RTE_BITMAP_CL_BIT_MASK: ::std::os::raw::c_uint = 511;
pub const RTE_BITMAP_CL_SLAB_SIZE: ::std::os::raw::c_uint = 8;
pub const RTE_BITMAP_CL_SLAB_SIZE_LOG2: ::std::os::raw::c_uint = 3;
pub const RTE_BITMAP_CL_SLAB_MASK: ::std::os::raw::c_uint = 7;
pub const RTE_DEV_NAME_MAX_LEN: ::std::os::raw::c_uint = 32;
pub const CFG_NAME_LEN: ::std::os::raw::c_uint = 64;
pub const CFG_VALUE_LEN: ::std::os::raw::c_uint = 256;
pub const CFG_DEFAULT_COMMENT_CHARACTER: u8 = b';';
pub const RTE_KVARGS_MAX: ::std::os::raw::c_uint = 32;
pub const RTE_KVARGS_PAIRS_DELIM: &'static [u8; 2usize] = b",\x00";
pub const RTE_KVARGS_KV_DELIM: &'static [u8; 2usize] = b"=\x00";
pub const RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO: ::std::os::raw::c_uint = 1;
pub const RTE_CRYPTODEV_FF_ASYMMETRIC_CRYPTO: ::std::os::raw::c_uint = 2;
pub const RTE_CRYPTODEV_FF_SYM_OPERATION_CHAINING: ::std::os::raw::c_uint = 4;
pub const RTE_CRYPTODEV_FF_CPU_SSE: ::std::os::raw::c_uint = 8;
pub const RTE_CRYPTODEV_FF_CPU_AVX: ::std::os::raw::c_uint = 16;
pub const RTE_CRYPTODEV_FF_CPU_AVX2: ::std::os::raw::c_uint = 32;
pub const RTE_CRYPTODEV_FF_CPU_AESNI: ::std::os::raw::c_uint = 64;
pub const RTE_CRYPTODEV_FF_HW_ACCELERATED: ::std::os::raw::c_uint = 128;
pub const RTE_CRYPTODEV_FF_CPU_AVX512: ::std::os::raw::c_uint = 256;
pub const RTE_CRYPTODEV_FF_MBUF_SCATTER_GATHER: ::std::os::raw::c_uint = 512;
pub const RTE_CRYPTODEV_FF_CPU_NEON: ::std::os::raw::c_uint = 1024;
pub const RTE_CRYPTODEV_FF_CPU_ARM_CE: ::std::os::raw::c_uint = 2048;
pub const RTE_CRYPTODEV_DETACHED: ::std::os::raw::c_uint = 0;
pub const RTE_CRYPTODEV_ATTACHED: ::std::os::raw::c_uint = 1;
pub const RTE_CRYPTODEV_NAME_MAX_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_MAX_RXTX_INTR_VEC_ID: ::std::os::raw::c_uint = 32;
pub const RTE_INTR_VEC_ZERO_OFFSET: ::std::os::raw::c_uint = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: ::std::os::raw::c_uint = 1;
pub const RTE_INTR_EVENT_ADD: ::std::os::raw::c_uint = 1;
pub const RTE_INTR_EVENT_DEL: ::std::os::raw::c_uint = 2;
pub const RTE_EPOLL_PER_THREAD: ::std::os::raw::c_int = -1;
pub const PCI_PRI_FMT: &'static [u8; 18usize] = b"%.4x:%.2x:%.2x.%x\x00";
pub const PCI_SHORT_PRI_FMT: &'static [u8; 13usize] = b"%.2x:%.2x.%x\x00";
pub const PCI_FMT_NVAL: ::std::os::raw::c_uint = 4;
pub const PCI_RESOURCE_FMT_NVAL: ::std::os::raw::c_uint = 3;
pub const PCI_MAX_RESOURCE: ::std::os::raw::c_uint = 6;
pub const PCI_ANY_ID: ::std::os::raw::c_uint = 65535;
pub const RTE_CLASS_ANY_ID: ::std::os::raw::c_uint = 16777215;
pub const RTE_PCI_DRV_NEED_MAPPING: ::std::os::raw::c_uint = 1;
pub const RTE_PCI_DRV_INTR_LSC: ::std::os::raw::c_uint = 8;
pub const RTE_PCI_DRV_INTR_RMV: ::std::os::raw::c_uint = 16;
pub const RTE_PCI_DRV_KEEP_MAPPED_RES: ::std::os::raw::c_uint = 32;
pub const RTE_CRYPTODEV_SCHEDULER_MAX_NB_SLAVES: ::std::os::raw::c_uint = 8;
pub const RTE_CRYPTODEV_SCHEDULER_MAX_NB_WORKER_CORES: ::std::os::raw::c_uint
          =
    64;
pub const RTE_CRYPTODEV_SCHEDULER_NAME_MAX_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_CRYPTODEV_SCHEDULER_DESC_MAX_LEN: ::std::os::raw::c_uint = 256;
pub const RTE_CRYPTODEV_VDEV_DEFAULT_MAX_NB_QUEUE_PAIRS:
          ::std::os::raw::c_uint =
    8;
pub const RTE_CRYPTODEV_VDEV_DEFAULT_MAX_NB_SESSIONS: ::std::os::raw::c_uint =
    2048;
pub const RTE_CRYPTODEV_VDEV_NAME: &'static [u8; 5usize] = b"name\x00";
pub const RTE_CRYPTODEV_VDEV_MAX_NB_QP_ARG: &'static [u8; 19usize] =
    b"max_nb_queue_pairs\x00";
pub const RTE_CRYPTODEV_VDEV_MAX_NB_SESS_ARG: &'static [u8; 16usize] =
    b"max_nb_sessions\x00";
pub const RTE_CRYPTODEV_VDEV_SOCKET_ID: &'static [u8; 10usize] =
    b"socket_id\x00";
pub const MS_PER_S: ::std::os::raw::c_uint = 1000;
pub const US_PER_S: ::std::os::raw::c_uint = 1000000;
pub const NS_PER_S: ::std::os::raw::c_uint = 1000000000;
pub const RTE_EFD_VALUE_NUM_BITS: ::std::os::raw::c_uint = 8;
pub const EFD_TARGET_GROUP_NUM_RULES: ::std::os::raw::c_uint = 22;
pub const EFD_MAX_GROUP_NUM_RULES: ::std::os::raw::c_uint = 28;
pub const EFD_MIN_BALANCED_NUM_RULES: ::std::os::raw::c_uint = 5;
pub const RTE_EFD_BURST_MAX: ::std::os::raw::c_uint = 32;
pub const RTE_EFD_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const EFD_LOOKUPTBL_SHIFT: ::std::os::raw::c_uint = 28;
pub const RTE_EFD_UPDATE_WARN_GROUP_FULL: ::std::os::raw::c_uint = 1;
pub const RTE_EFD_UPDATE_NO_CHANGE: ::std::os::raw::c_uint = 2;
pub const RTE_EFD_UPDATE_FAILED: ::std::os::raw::c_uint = 3;
pub const RTE_ETH_FLOW_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_FLOW_RAW: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_FLOW_IPV4: ::std::os::raw::c_uint = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: ::std::os::raw::c_uint = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: ::std::os::raw::c_uint = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: ::std::os::raw::c_uint = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: ::std::os::raw::c_uint = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: ::std::os::raw::c_uint = 7;
pub const RTE_ETH_FLOW_IPV6: ::std::os::raw::c_uint = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: ::std::os::raw::c_uint = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: ::std::os::raw::c_uint = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: ::std::os::raw::c_uint = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: ::std::os::raw::c_uint = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: ::std::os::raw::c_uint = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: ::std::os::raw::c_uint = 14;
pub const RTE_ETH_FLOW_IPV6_EX: ::std::os::raw::c_uint = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: ::std::os::raw::c_uint = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: ::std::os::raw::c_uint = 17;
pub const RTE_ETH_FLOW_PORT: ::std::os::raw::c_uint = 18;
pub const RTE_ETH_FLOW_VXLAN: ::std::os::raw::c_uint = 19;
pub const RTE_ETH_FLOW_GENEVE: ::std::os::raw::c_uint = 20;
pub const RTE_ETH_FLOW_NVGRE: ::std::os::raw::c_uint = 21;
pub const RTE_ETH_FLOW_MAX: ::std::os::raw::c_uint = 22;
pub const RTE_ETHTYPE_FLAGS_MAC: ::std::os::raw::c_uint = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: ::std::os::raw::c_uint = 2;
pub const RTE_FLEX_FILTER_MAXLEN: ::std::os::raw::c_uint = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: ::std::os::raw::c_uint = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: ::std::os::raw::c_uint = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: ::std::os::raw::c_uint = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: ::std::os::raw::c_uint = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: ::std::os::raw::c_uint = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: ::std::os::raw::c_uint = 32;
pub const RTE_5TUPLE_FLAGS: ::std::os::raw::c_uint = 31;
pub const RTE_2TUPLE_FLAGS: ::std::os::raw::c_uint = 20;
pub const TCP_URG_FLAG: ::std::os::raw::c_uint = 32;
pub const TCP_ACK_FLAG: ::std::os::raw::c_uint = 16;
pub const TCP_PSH_FLAG: ::std::os::raw::c_uint = 8;
pub const TCP_RST_FLAG: ::std::os::raw::c_uint = 4;
pub const TCP_SYN_FLAG: ::std::os::raw::c_uint = 2;
pub const TCP_FIN_FLAG: ::std::os::raw::c_uint = 1;
pub const TCP_FLAG_ALL: ::std::os::raw::c_uint = 63;
pub const ETH_TUNNEL_FILTER_OMAC: ::std::os::raw::c_uint = 1;
pub const ETH_TUNNEL_FILTER_OIP: ::std::os::raw::c_uint = 2;
pub const ETH_TUNNEL_FILTER_TENID: ::std::os::raw::c_uint = 4;
pub const ETH_TUNNEL_FILTER_IMAC: ::std::os::raw::c_uint = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: ::std::os::raw::c_uint = 16;
pub const ETH_TUNNEL_FILTER_IIP: ::std::os::raw::c_uint = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: ::std::os::raw::c_uint = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: ::std::os::raw::c_uint = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: ::std::os::raw::c_uint = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: ::std::os::raw::c_uint = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: ::std::os::raw::c_uint = 16;
pub const RTE_ETH_INSET_SIZE_MAX: ::std::os::raw::c_uint = 128;
pub const ETH_LINK_SPEED_AUTONEG: ::std::os::raw::c_uint = 0;
pub const ETH_LINK_SPEED_FIXED: ::std::os::raw::c_uint = 1;
pub const ETH_LINK_SPEED_10M_HD: ::std::os::raw::c_uint = 2;
pub const ETH_LINK_SPEED_10M: ::std::os::raw::c_uint = 4;
pub const ETH_LINK_SPEED_100M_HD: ::std::os::raw::c_uint = 8;
pub const ETH_LINK_SPEED_100M: ::std::os::raw::c_uint = 16;
pub const ETH_LINK_SPEED_1G: ::std::os::raw::c_uint = 32;
pub const ETH_LINK_SPEED_2_5G: ::std::os::raw::c_uint = 64;
pub const ETH_LINK_SPEED_5G: ::std::os::raw::c_uint = 128;
pub const ETH_LINK_SPEED_10G: ::std::os::raw::c_uint = 256;
pub const ETH_LINK_SPEED_20G: ::std::os::raw::c_uint = 512;
pub const ETH_LINK_SPEED_25G: ::std::os::raw::c_uint = 1024;
pub const ETH_LINK_SPEED_40G: ::std::os::raw::c_uint = 2048;
pub const ETH_LINK_SPEED_50G: ::std::os::raw::c_uint = 4096;
pub const ETH_LINK_SPEED_56G: ::std::os::raw::c_uint = 8192;
pub const ETH_LINK_SPEED_100G: ::std::os::raw::c_uint = 16384;
pub const ETH_SPEED_NUM_NONE: ::std::os::raw::c_uint = 0;
pub const ETH_SPEED_NUM_10M: ::std::os::raw::c_uint = 10;
pub const ETH_SPEED_NUM_100M: ::std::os::raw::c_uint = 100;
pub const ETH_SPEED_NUM_1G: ::std::os::raw::c_uint = 1000;
pub const ETH_SPEED_NUM_2_5G: ::std::os::raw::c_uint = 2500;
pub const ETH_SPEED_NUM_5G: ::std::os::raw::c_uint = 5000;
pub const ETH_SPEED_NUM_10G: ::std::os::raw::c_uint = 10000;
pub const ETH_SPEED_NUM_20G: ::std::os::raw::c_uint = 20000;
pub const ETH_SPEED_NUM_25G: ::std::os::raw::c_uint = 25000;
pub const ETH_SPEED_NUM_40G: ::std::os::raw::c_uint = 40000;
pub const ETH_SPEED_NUM_50G: ::std::os::raw::c_uint = 50000;
pub const ETH_SPEED_NUM_56G: ::std::os::raw::c_uint = 56000;
pub const ETH_SPEED_NUM_100G: ::std::os::raw::c_uint = 100000;
pub const ETH_LINK_HALF_DUPLEX: ::std::os::raw::c_uint = 0;
pub const ETH_LINK_FULL_DUPLEX: ::std::os::raw::c_uint = 1;
pub const ETH_LINK_DOWN: ::std::os::raw::c_uint = 0;
pub const ETH_LINK_UP: ::std::os::raw::c_uint = 1;
pub const ETH_LINK_FIXED: ::std::os::raw::c_uint = 0;
pub const ETH_LINK_AUTONEG: ::std::os::raw::c_uint = 1;
pub const ETH_MQ_RX_RSS_FLAG: ::std::os::raw::c_uint = 1;
pub const ETH_MQ_RX_DCB_FLAG: ::std::os::raw::c_uint = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: ::std::os::raw::c_uint = 4;
pub const ETH_RSS_IPV4: ::std::os::raw::c_uint = 4;
pub const ETH_RSS_FRAG_IPV4: ::std::os::raw::c_uint = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: ::std::os::raw::c_uint = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: ::std::os::raw::c_uint = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: ::std::os::raw::c_uint = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: ::std::os::raw::c_uint = 128;
pub const ETH_RSS_IPV6: ::std::os::raw::c_uint = 256;
pub const ETH_RSS_FRAG_IPV6: ::std::os::raw::c_uint = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: ::std::os::raw::c_uint = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: ::std::os::raw::c_uint = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: ::std::os::raw::c_uint = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: ::std::os::raw::c_uint = 8192;
pub const ETH_RSS_L2_PAYLOAD: ::std::os::raw::c_uint = 16384;
pub const ETH_RSS_IPV6_EX: ::std::os::raw::c_uint = 32768;
pub const ETH_RSS_IPV6_TCP_EX: ::std::os::raw::c_uint = 65536;
pub const ETH_RSS_IPV6_UDP_EX: ::std::os::raw::c_uint = 131072;
pub const ETH_RSS_PORT: ::std::os::raw::c_uint = 262144;
pub const ETH_RSS_VXLAN: ::std::os::raw::c_uint = 524288;
pub const ETH_RSS_GENEVE: ::std::os::raw::c_uint = 1048576;
pub const ETH_RSS_NVGRE: ::std::os::raw::c_uint = 2097152;
pub const ETH_RSS_IP: ::std::os::raw::c_uint = 41868;
pub const ETH_RSS_UDP: ::std::os::raw::c_uint = 133152;
pub const ETH_RSS_TCP: ::std::os::raw::c_uint = 66576;
pub const ETH_RSS_SCTP: ::std::os::raw::c_uint = 4160;
pub const ETH_RSS_TUNNEL: ::std::os::raw::c_uint = 3670016;
pub const ETH_RSS_PROTO_MASK: ::std::os::raw::c_uint = 4194300;
pub const ETH_RSS_RETA_SIZE_64: ::std::os::raw::c_uint = 64;
pub const ETH_RSS_RETA_SIZE_128: ::std::os::raw::c_uint = 128;
pub const ETH_RSS_RETA_SIZE_256: ::std::os::raw::c_uint = 256;
pub const ETH_RSS_RETA_SIZE_512: ::std::os::raw::c_uint = 512;
pub const RTE_RETA_GROUP_SIZE: ::std::os::raw::c_uint = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: ::std::os::raw::c_uint = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: ::std::os::raw::c_uint = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: ::std::os::raw::c_uint = 128;
pub const ETH_DCB_NUM_QUEUES: ::std::os::raw::c_uint = 128;
pub const ETH_DCB_PG_SUPPORT: ::std::os::raw::c_uint = 1;
pub const ETH_DCB_PFC_SUPPORT: ::std::os::raw::c_uint = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: ::std::os::raw::c_uint = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: ::std::os::raw::c_uint = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: ::std::os::raw::c_uint = 4;
pub const ETH_VLAN_STRIP_MASK: ::std::os::raw::c_uint = 1;
pub const ETH_VLAN_FILTER_MASK: ::std::os::raw::c_uint = 2;
pub const ETH_VLAN_EXTEND_MASK: ::std::os::raw::c_uint = 4;
pub const ETH_VLAN_ID_MAX: ::std::os::raw::c_uint = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: ::std::os::raw::c_uint = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: ::std::os::raw::c_uint = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: ::std::os::raw::c_uint = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: ::std::os::raw::c_uint = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: ::std::os::raw::c_uint = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: ::std::os::raw::c_uint = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: ::std::os::raw::c_uint = 16;
pub const ETH_MIRROR_MAX_VLANS: ::std::os::raw::c_uint = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: ::std::os::raw::c_uint = 1;
pub const ETH_MIRROR_UPLINK_PORT: ::std::os::raw::c_uint = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: ::std::os::raw::c_uint = 4;
pub const ETH_MIRROR_VLAN: ::std::os::raw::c_uint = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: ::std::os::raw::c_uint = 16;
pub const ETH_TXQ_FLAGS_NOMULTSEGS: ::std::os::raw::c_uint = 1;
pub const ETH_TXQ_FLAGS_NOREFCOUNT: ::std::os::raw::c_uint = 2;
pub const ETH_TXQ_FLAGS_NOMULTMEMP: ::std::os::raw::c_uint = 4;
pub const ETH_TXQ_FLAGS_NOVLANOFFL: ::std::os::raw::c_uint = 256;
pub const ETH_TXQ_FLAGS_NOXSUMSCTP: ::std::os::raw::c_uint = 512;
pub const ETH_TXQ_FLAGS_NOXSUMUDP: ::std::os::raw::c_uint = 1024;
pub const ETH_TXQ_FLAGS_NOXSUMTCP: ::std::os::raw::c_uint = 2048;
pub const ETH_TXQ_FLAGS_NOOFFLOADS: ::std::os::raw::c_uint = 3840;
pub const ETH_TXQ_FLAGS_NOXSUMS: ::std::os::raw::c_uint = 3584;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: ::std::os::raw::c_uint = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: ::std::os::raw::c_uint = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: ::std::os::raw::c_uint = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: ::std::os::raw::c_uint = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: ::std::os::raw::c_uint = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: ::std::os::raw::c_uint = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: ::std::os::raw::c_uint = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: ::std::os::raw::c_uint = 128;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: ::std::os::raw::c_uint = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: ::std::os::raw::c_uint = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: ::std::os::raw::c_uint = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: ::std::os::raw::c_uint = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: ::std::os::raw::c_uint = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: ::std::os::raw::c_uint = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: ::std::os::raw::c_uint = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: ::std::os::raw::c_uint = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: ::std::os::raw::c_uint = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: ::std::os::raw::c_uint = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: ::std::os::raw::c_uint = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: ::std::os::raw::c_uint = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: ::std::os::raw::c_uint = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: ::std::os::raw::c_uint = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: ::std::os::raw::c_uint = 16384;
pub const RTE_ETH_XSTATS_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const ETH_DCB_NUM_TCS: ::std::os::raw::c_uint = 8;
pub const ETH_MAX_VMDQ_POOL: ::std::os::raw::c_uint = 64;
pub const RTE_ETH_QUEUE_STATE_STOPPED: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: ::std::os::raw::c_uint = 1;
pub const ETH_L2_TUNNEL_ENABLE_MASK: ::std::os::raw::c_uint = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: ::std::os::raw::c_uint = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: ::std::os::raw::c_uint = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: ::std::os::raw::c_uint = 8;
pub const RTE_ETH_NAME_MAX_LEN: ::std::os::raw::c_uint = 32;
pub const RTE_ETH_DEV_DETACHABLE: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_DEV_INTR_LSC: ::std::os::raw::c_uint = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: ::std::os::raw::c_uint = 4;
pub const RTE_ETH_DEV_INTR_RMV: ::std::os::raw::c_uint = 8;
pub const RTE_ETH_RX_DESC_AVAIL: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_RX_DESC_DONE: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: ::std::os::raw::c_uint = 2;
pub const RTE_ETH_TX_DESC_FULL: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_TX_DESC_DONE: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: ::std::os::raw::c_uint = 2;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const _SYS_EVENTFD_H: ::std::os::raw::c_uint = 1;
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const _IOC_NRBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_TYPEBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZEBITS: ::std::os::raw::c_uint = 14;
pub const _IOC_DIRBITS: ::std::os::raw::c_uint = 2;
pub const _IOC_NRMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_TYPEMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_SIZEMASK: ::std::os::raw::c_uint = 16383;
pub const _IOC_DIRMASK: ::std::os::raw::c_uint = 3;
pub const _IOC_NRSHIFT: ::std::os::raw::c_uint = 0;
pub const _IOC_TYPESHIFT: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZESHIFT: ::std::os::raw::c_uint = 16;
pub const _IOC_DIRSHIFT: ::std::os::raw::c_uint = 30;
pub const _IOC_NONE: ::std::os::raw::c_uint = 0;
pub const _IOC_WRITE: ::std::os::raw::c_uint = 1;
pub const _IOC_READ: ::std::os::raw::c_uint = 2;
pub const IOC_IN: ::std::os::raw::c_uint = 1073741824;
pub const IOC_OUT: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::std::os::raw::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::std::os::raw::c_uint = 16;
pub const VIRTIO_CONFIG_S_ACKNOWLEDGE: ::std::os::raw::c_uint = 1;
pub const VIRTIO_CONFIG_S_DRIVER: ::std::os::raw::c_uint = 2;
pub const VIRTIO_CONFIG_S_DRIVER_OK: ::std::os::raw::c_uint = 4;
pub const VIRTIO_CONFIG_S_FEATURES_OK: ::std::os::raw::c_uint = 8;
pub const VIRTIO_CONFIG_S_FAILED: ::std::os::raw::c_uint = 128;
pub const VIRTIO_TRANSPORT_F_START: ::std::os::raw::c_uint = 28;
pub const VIRTIO_TRANSPORT_F_END: ::std::os::raw::c_uint = 33;
pub const VIRTIO_F_NOTIFY_ON_EMPTY: ::std::os::raw::c_uint = 24;
pub const VIRTIO_F_ANY_LAYOUT: ::std::os::raw::c_uint = 27;
pub const VIRTIO_F_VERSION_1: ::std::os::raw::c_uint = 32;
pub const VRING_DESC_F_NEXT: ::std::os::raw::c_uint = 1;
pub const VRING_DESC_F_WRITE: ::std::os::raw::c_uint = 2;
pub const VRING_DESC_F_INDIRECT: ::std::os::raw::c_uint = 4;
pub const VRING_USED_F_NO_NOTIFY: ::std::os::raw::c_uint = 1;
pub const VRING_AVAIL_F_NO_INTERRUPT: ::std::os::raw::c_uint = 1;
pub const VIRTIO_RING_F_INDIRECT_DESC: ::std::os::raw::c_uint = 28;
pub const VIRTIO_RING_F_EVENT_IDX: ::std::os::raw::c_uint = 29;
pub const VRING_AVAIL_ALIGN_SIZE: ::std::os::raw::c_uint = 2;
pub const VRING_USED_ALIGN_SIZE: ::std::os::raw::c_uint = 4;
pub const VRING_DESC_ALIGN_SIZE: ::std::os::raw::c_uint = 16;
pub const VHOST_VRING_F_LOG: ::std::os::raw::c_uint = 0;
pub const VHOST_PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const VHOST_VIRTIO: ::std::os::raw::c_uint = 175;
pub const VHOST_VRING_LITTLE_ENDIAN: ::std::os::raw::c_uint = 0;
pub const VHOST_VRING_BIG_ENDIAN: ::std::os::raw::c_uint = 1;
pub const VHOST_F_LOG_ALL: ::std::os::raw::c_uint = 26;
pub const VHOST_NET_F_VIRTIO_NET_HDR: ::std::os::raw::c_uint = 27;
pub const VHOST_SCSI_ABI_VERSION: ::std::os::raw::c_uint = 1;
pub const RTE_VHOST_USER_CLIENT: ::std::os::raw::c_uint = 1;
pub const RTE_VHOST_USER_NO_RECONNECT: ::std::os::raw::c_uint = 2;
pub const RTE_VHOST_USER_DEQUEUE_ZERO_COPY: ::std::os::raw::c_uint = 4;
pub const RTE_EVENT_DEV_CAP_QUEUE_QOS: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_DEV_CAP_EVENT_QOS: ::std::os::raw::c_uint = 2;
pub const RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED: ::std::os::raw::c_uint = 4;
pub const RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES: ::std::os::raw::c_uint = 8;
pub const RTE_EVENT_DEV_CAP_BURST_MODE: ::std::os::raw::c_uint = 16;
pub const RTE_EVENT_DEV_PRIORITY_HIGHEST: ::std::os::raw::c_uint = 0;
pub const RTE_EVENT_DEV_PRIORITY_NORMAL: ::std::os::raw::c_uint = 128;
pub const RTE_EVENT_DEV_PRIORITY_LOWEST: ::std::os::raw::c_uint = 255;
pub const RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_QUEUE_CFG_TYPE_MASK: ::std::os::raw::c_uint = 3;
pub const RTE_EVENT_QUEUE_CFG_ALL_TYPES: ::std::os::raw::c_uint = 0;
pub const RTE_EVENT_QUEUE_CFG_ATOMIC_ONLY: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_QUEUE_CFG_ORDERED_ONLY: ::std::os::raw::c_uint = 2;
pub const RTE_EVENT_QUEUE_CFG_PARALLEL_ONLY: ::std::os::raw::c_uint = 3;
pub const RTE_EVENT_QUEUE_CFG_SINGLE_LINK: ::std::os::raw::c_uint = 4;
pub const RTE_SCHED_TYPE_ORDERED: ::std::os::raw::c_uint = 0;
pub const RTE_SCHED_TYPE_ATOMIC: ::std::os::raw::c_uint = 1;
pub const RTE_SCHED_TYPE_PARALLEL: ::std::os::raw::c_uint = 2;
pub const RTE_EVENT_TYPE_ETHDEV: ::std::os::raw::c_uint = 0;
pub const RTE_EVENT_TYPE_CRYPTODEV: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_TYPE_TIMERDEV: ::std::os::raw::c_uint = 2;
pub const RTE_EVENT_TYPE_CPU: ::std::os::raw::c_uint = 3;
pub const RTE_EVENT_TYPE_MAX: ::std::os::raw::c_uint = 16;
pub const RTE_EVENT_OP_NEW: ::std::os::raw::c_uint = 0;
pub const RTE_EVENT_OP_FORWARD: ::std::os::raw::c_uint = 1;
pub const RTE_EVENT_OP_RELEASE: ::std::os::raw::c_uint = 2;
pub const RTE_EVENTDEV_NAME_MAX_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_EVENT_DEV_XSTATS_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_EVENTDEV_DETACHED: ::std::os::raw::c_uint = 0;
pub const RTE_EVENTDEV_ATTACHED: ::std::os::raw::c_uint = 1;
pub const RTE_TAILQ_EVENT_RING_NAME: &'static [u8; 15usize] =
    b"RTE_EVENT_RING\x00";
pub const CRC32_SW: ::std::os::raw::c_uint = 1;
pub const CRC32_SSE42: ::std::os::raw::c_uint = 2;
pub const CRC32_x64: ::std::os::raw::c_uint = 4;
pub const CRC32_SSE42_x64: ::std::os::raw::c_uint = 6;
pub const CRC32_ARM64: ::std::os::raw::c_uint = 8;
pub const RTE_FBK_HASH_INIT_VAL_DEFAULT: ::std::os::raw::c_uint = 4294967295;
pub const RTE_FBK_HASH_ENTRIES_MAX: ::std::os::raw::c_uint = 1048576;
pub const RTE_FBK_HASH_ENTRIES_PER_BUCKET_MAX: ::std::os::raw::c_uint = 256;
pub const RTE_FBK_HASH_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const IP_ICMP_ECHO_REPLY: ::std::os::raw::c_uint = 0;
pub const IP_ICMP_ECHO_REQUEST: ::std::os::raw::c_uint = 8;
pub const IPV4_MAX_PKT_LEN: ::std::os::raw::c_uint = 65535;
pub const IPV4_HDR_IHL_MASK: ::std::os::raw::c_uint = 15;
pub const IPV4_IHL_MULTIPLIER: ::std::os::raw::c_uint = 4;
pub const IPV4_HDR_DF_SHIFT: ::std::os::raw::c_uint = 14;
pub const IPV4_HDR_MF_SHIFT: ::std::os::raw::c_uint = 13;
pub const IPV4_HDR_FO_SHIFT: ::std::os::raw::c_uint = 3;
pub const IPV4_HDR_DF_FLAG: ::std::os::raw::c_uint = 16384;
pub const IPV4_HDR_MF_FLAG: ::std::os::raw::c_uint = 8192;
pub const IPV4_HDR_OFFSET_MASK: ::std::os::raw::c_uint = 8191;
pub const IPV4_HDR_OFFSET_UNITS: ::std::os::raw::c_uint = 8;
pub const RTE_GRO_MAX_BURST_ITEM_NUM: ::std::os::raw::c_uint = 128;
pub const RTE_GRO_TYPE_MAX_NUM: ::std::os::raw::c_uint = 64;
pub const RTE_GRO_TYPE_SUPPORT_NUM: ::std::os::raw::c_uint = 1;
pub const RTE_GRO_TCP_IPV4_INDEX: ::std::os::raw::c_uint = 0;
pub const RTE_GRO_TCP_IPV4: ::std::os::raw::c_uint = 1;
pub const RTE_HASH_ENTRIES_MAX: ::std::os::raw::c_uint = 1073741824;
pub const RTE_HASH_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_HASH_LOOKUP_BULK_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_HASH_LOOKUP_MULTI_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT: ::std::os::raw::c_uint = 1;
pub const RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD: ::std::os::raw::c_uint = 2;
pub const IP_FRAG_DEATH_ROW_LEN: ::std::os::raw::c_uint = 32;
pub const RTE_IPV6_EHDR_MF_SHIFT: ::std::os::raw::c_uint = 0;
pub const RTE_IPV6_EHDR_MF_MASK: ::std::os::raw::c_uint = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: ::std::os::raw::c_uint = 3;
pub const RTE_IPV6_EHDR_FO_MASK: ::std::os::raw::c_int = -8;
pub const RTE_IPV6_FRAG_USED_MASK: ::std::os::raw::c_int = -7;
pub const RTE_JHASH_GOLDEN_RATIO: ::std::os::raw::c_uint = 3735928559;
pub const RTE_JOBSTATS_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_KEEPALIVE_MAXCORES: ::std::os::raw::c_uint = 128;
pub const RTE_KNI_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const KNI_DEVICE: &'static [u8; 4usize] = b"kni\x00";
pub const RTE_METRICS_MAX_NAME_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_METRICS_GLOBAL: ::std::os::raw::c_int = -1;
pub const RTE_LPM6_MAX_DEPTH: ::std::os::raw::c_uint = 128;
pub const RTE_LPM6_IPV6_ADDR_SIZE: ::std::os::raw::c_uint = 16;
pub const RTE_LPM6_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_MAX_DEPTH: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_TBL24_NUM_ENTRIES: ::std::os::raw::c_uint = 16777216;
pub const RTE_LPM_TBL8_GROUP_NUM_ENTRIES: ::std::os::raw::c_uint = 256;
pub const RTE_LPM_MAX_TBL8_NUM_GROUPS: ::std::os::raw::c_uint = 16777216;
pub const RTE_LPM_TBL8_NUM_GROUPS: ::std::os::raw::c_uint = 256;
pub const RTE_LPM_TBL8_NUM_ENTRIES: ::std::os::raw::c_uint = 65536;
pub const RTE_LPM_VALID_EXT_ENTRY_BITMASK: ::std::os::raw::c_uint = 50331648;
pub const RTE_LPM_LOOKUP_SUCCESS: ::std::os::raw::c_uint = 16777216;
pub const RTE_TABLE_HASH_LRU_STRATEGY: ::std::os::raw::c_uint = 2;
pub const CRC32_ETH_POLYNOMIAL: ::std::os::raw::c_uint = 79764919;
pub const CRC16_CCITT_POLYNOMIAL: ::std::os::raw::c_uint = 4129;
pub const CRC_LUT_SIZE: ::std::os::raw::c_uint = 256;
pub const RTE_INTR_MODE_NONE_NAME: &'static [u8; 5usize] = b"none\x00";
pub const RTE_INTR_MODE_LEGACY_NAME: &'static [u8; 7usize] = b"legacy\x00";
pub const RTE_INTR_MODE_MSI_NAME: &'static [u8; 4usize] = b"msi\x00";
pub const RTE_INTR_MODE_MSIX_NAME: &'static [u8; 5usize] = b"msix\x00";
pub const RTE_PDUMP_ALL_QUEUES: ::std::os::raw::c_uint = 65535;
pub const RTE_PORT_IN_BURST_SIZE_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_TABLE_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_PORT_IN_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_PORT_OUT_MAX: ::std::os::raw::c_uint = 64;
pub const BNXT_VF_RESET: ::std::os::raw::c_uint = 1;
pub const BNXT_VF_SET_MAC_ADDR: ::std::os::raw::c_uint = 2;
pub const BNXT_VF_SET_VLAN: ::std::os::raw::c_uint = 3;
pub const BNXT_VF_SET_MTU: ::std::os::raw::c_uint = 4;
pub const BNXT_VF_SET_MRU: ::std::os::raw::c_uint = 5;
pub const RTE_PMD_I40E_DDP_NAME_SIZE: ::std::os::raw::c_uint = 32;
pub const RTE_PMD_I40E_DDP_OWNER_UNKNOWN: ::std::os::raw::c_uint = 255;
pub const RTE_PMD_I40E_PTYPE_USER_DEFINE_MASK: ::std::os::raw::c_uint =
    2147483648;
pub const RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE: ::std::os::raw::c_uint = 4;
pub const RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS: ::std::os::raw::c_uint = 4;
pub const RTE_SCHED_QUEUES_PER_PIPE: ::std::os::raw::c_uint = 16;
pub const RTE_SCHED_PIPE_PROFILES_PER_PORT: ::std::os::raw::c_uint = 256;
pub const RTE_SCHED_FRAME_OVERHEAD_DEFAULT: ::std::os::raw::c_uint = 24;
pub const RTE_RED_SCALING: ::std::os::raw::c_uint = 10;
pub const RTE_RED_S: ::std::os::raw::c_uint = 4194304;
pub const RTE_RED_MAX_TH_MAX: ::std::os::raw::c_uint = 1023;
pub const RTE_RED_WQ_LOG2_MIN: ::std::os::raw::c_uint = 1;
pub const RTE_RED_WQ_LOG2_MAX: ::std::os::raw::c_uint = 12;
pub const RTE_RED_MAXP_INV_MIN: ::std::os::raw::c_uint = 1;
pub const RTE_RED_MAXP_INV_MAX: ::std::os::raw::c_uint = 255;
pub const RTE_RED_2POW16: ::std::os::raw::c_uint = 65536;
pub const RTE_RED_WQ_LOG2_NUM: ::std::os::raw::c_uint = 12;
pub const RTE_SERVICE_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const RTE_SERVICE_CAP_MT_SAFE: ::std::os::raw::c_uint = 1;
pub const RTE_LPM_IPV6_ADDR_SIZE: ::std::os::raw::c_uint = 16;
pub const NSEC_PER_SEC: ::std::os::raw::c_uint = 1000000000;
pub const RTE_TIMER_STOP: ::std::os::raw::c_uint = 0;
pub const RTE_TIMER_PENDING: ::std::os::raw::c_uint = 1;
pub const RTE_TIMER_RUNNING: ::std::os::raw::c_uint = 2;
pub const RTE_TIMER_CONFIG: ::std::os::raw::c_uint = 3;
pub const RTE_TIMER_NO_OWNER: ::std::os::raw::c_int = -2;
pub const MAX_SKIPLIST_DEPTH: ::std::os::raw::c_uint = 10;
pub const RTE_TM_ETH_FRAMING_OVERHEAD: ::std::os::raw::c_uint = 20;
pub const RTE_TM_ETH_FRAMING_OVERHEAD_FCS: ::std::os::raw::c_uint = 24;
pub const RTE_TM_WRED_PROFILE_ID_NONE: ::std::os::raw::c_uint = 4294967295;
pub const RTE_TM_SHAPER_PROFILE_ID_NONE: ::std::os::raw::c_uint = 4294967295;
pub const RTE_TM_NODE_ID_NULL: ::std::os::raw::c_uint = 4294967295;
pub const RTE_TM_NODE_LEVEL_ID_ANY: ::std::os::raw::c_uint = 4294967295;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\x00";
pub const RTE_VER_YEAR: ::std::os::raw::c_uint = 17;
pub const RTE_VER_MONTH: ::std::os::raw::c_uint = 8;
pub const RTE_VER_MINOR: ::std::os::raw::c_uint = 0;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\x00";
pub const RTE_VER_RELEASE: ::std::os::raw::c_uint = 16;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::std::mem::align_of::<sockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize , concat !
               ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_padding as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
}
pub const MSG_OOB: _bindgen_ty_1 = _bindgen_ty_1::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_1 = _bindgen_ty_1::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_1 = _bindgen_ty_1::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_1 = _bindgen_ty_1::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_1 = _bindgen_ty_1::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_1 = _bindgen_ty_1::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_1 = _bindgen_ty_1::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_1 = _bindgen_ty_1::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_1 = _bindgen_ty_1::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_1 = _bindgen_ty_1::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_1 = _bindgen_ty_1::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_1 = _bindgen_ty_1::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_1 = _bindgen_ty_1::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = _bindgen_ty_1::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = _bindgen_ty_1::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_1 = _bindgen_ty_1::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_1 = _bindgen_ty_1::MSG_WAITFORONE;
pub const MSG_FASTOPEN: _bindgen_ty_1 = _bindgen_ty_1::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = _bindgen_ty_1::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::std::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::std::mem::align_of::<cmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = _bindgen_ty_2::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::std::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::std::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
pub const SHUT_RD: _bindgen_ty_3 = _bindgen_ty_3::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_3 = _bindgen_ty_3::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_3 = _bindgen_ty_3::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
extern "C" {
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> isize;
}
extern "C" {
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: usize,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( in_addr ) ));
    assert_eq! (::std::mem::align_of::<in_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_addr ) , "::" ,
                stringify ! ( s_addr ) ));
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>() , 44usize , concat ! (
               "Size of: " , stringify ! ( ip_opts ) ));
    assert_eq! (::std::mem::align_of::<ip_opts>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_dst as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_opts as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_opts ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq! (::std::mem::align_of::<ip_mreqn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_address as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_ifindex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_ifindex ) ));
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>() , 12usize , concat ! (
               "Size of: " , stringify ! ( in_pktinfo ) ));
    assert_eq! (::std::mem::align_of::<in_pktinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_pktinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_ifindex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_spec_dst as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_spec_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_addr ) ));
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self { *self }
}
pub const IPPROTO_IP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_6 =
    _bindgen_ty_6::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_6 =
    _bindgen_ty_6::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr32 ) ));
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq! (::std::mem::align_of::<in6_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __in6_u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr ) , "::" ,
                stringify ! ( __in6_u ) ));
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_family as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_addr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_zero as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_zero ) ));
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>() , 28usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in6>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_family as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_flowinfo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_flowinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_scope_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_scope_id ) ));
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_interface as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq_source>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_sourceaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_sourceaddr ) ));
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (::std::mem::align_of::<ipv6_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_interface as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_interface ) ));
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>() , 136usize , concat ! (
               "Size of: " , stringify ! ( group_req ) ));
    assert_eq! (::std::mem::align_of::<group_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_interface as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_group as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_group ) ));
}
#[repr(C)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>() , 264usize , concat !
               ( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq! (::std::mem::align_of::<group_source_req>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_group as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_source as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_source ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ip_msfilter ) ));
    assert_eq! (::std::mem::align_of::<ip_msfilter>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_msfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_fmode as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_numsrc as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_slist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_slist ) ));
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>() , 272usize , concat ! (
               "Size of: " , stringify ! ( group_filter ) ));
    assert_eq! (::std::mem::align_of::<group_filter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_group as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_fmode as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_numsrc as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_slist as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_slist ) ));
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(::std::mem::size_of::<termios>() , 60usize , concat ! (
               "Size of: " , stringify ! ( termios ) ));
    assert_eq! (::std::mem::align_of::<termios>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( termios ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_iflag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_iflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_oflag as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_oflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_cflag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_cflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_lflag as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_lflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_line as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_cc as * const _ as usize
                } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_cc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_ispeed as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_ispeed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_ospeed as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( termios ) , "::" ,
                stringify ! ( c_ospeed ) ));
}
impl Clone for termios {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(__fd: ::std::os::raw::c_int, __termios_p: *mut termios)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(__fd: ::std::os::raw::c_int,
                     __optional_actions: ::std::os::raw::c_int,
                     __termios_p: *const termios) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(__fd: ::std::os::raw::c_int,
                       __duration: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(__fd: ::std::os::raw::c_int,
                   __queue_selector: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(__fd: ::std::os::raw::c_int,
                  __action: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::std::os::raw::c_int) -> __pid_t;
}
/// This structure is the header of a cirbuf type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cirbuf {
    /// < total len of the fifo (number of elements)
    pub maxlen: ::std::os::raw::c_uint,
    /// < indice of the first elt
    pub start: ::std::os::raw::c_uint,
    /// < indice of the last elt
    pub end: ::std::os::raw::c_uint,
    /// < current len of fifo
    pub len: ::std::os::raw::c_uint,
    pub buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cirbuf() {
    assert_eq!(::std::mem::size_of::<cirbuf>() , 24usize , concat ! (
               "Size of: " , stringify ! ( cirbuf ) ));
    assert_eq! (::std::mem::align_of::<cirbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cirbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . maxlen as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cirbuf ) , "::" ,
                stringify ! ( maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . start as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cirbuf ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . end as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cirbuf ) , "::" ,
                stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . len as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cirbuf ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . buf as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cirbuf ) , "::" ,
                stringify ! ( buf ) ));
}
impl Clone for cirbuf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Init the circular buffer
    pub fn cirbuf_init(cbuf: *mut cirbuf, buf: *mut ::std::os::raw::c_char,
                       start: ::std::os::raw::c_uint,
                       maxlen: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at head of the circular buffer. Return 0 on success, or
/// a negative value on error.
    pub fn cirbuf_add_head_safe(cbuf: *mut cirbuf, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at head of the circular buffer. You _must_ check that you
/// have enough free space in the buffer before calling this func.
    pub fn cirbuf_add_head(cbuf: *mut cirbuf, c: ::std::os::raw::c_char);
}
extern "C" {
    /// Add a character at tail of the circular buffer. Return 0 on success, or
/// a negative value on error.
    pub fn cirbuf_add_tail_safe(cbuf: *mut cirbuf, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at tail of the circular buffer. You _must_ check that you
/// have enough free space in the buffer before calling this func.
    pub fn cirbuf_add_tail(cbuf: *mut cirbuf, c: ::std::os::raw::c_char);
}
extern "C" {
    /// Remove a char at the head of the circular buffer. Return 0 on
/// success, or a negative value on error.
    pub fn cirbuf_del_head_safe(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a char at the head of the circular buffer. You _must_ check
/// that buffer is not empty before calling the function.
    pub fn cirbuf_del_head(cbuf: *mut cirbuf);
}
extern "C" {
    /// Remove a char at the tail of the circular buffer. Return 0 on
/// success, or a negative value on error.
    pub fn cirbuf_del_tail_safe(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a char at the tail of the circular buffer. You _must_ check
/// that buffer is not empty before calling the function.
    pub fn cirbuf_del_tail(cbuf: *mut cirbuf);
}
extern "C" {
    /// Return the head of the circular buffer. You _must_ check that
/// buffer is not empty before calling the function.
    pub fn cirbuf_get_head(cbuf: *mut cirbuf) -> ::std::os::raw::c_char;
}
extern "C" {
    /// Return the tail of the circular buffer. You _must_ check that
/// buffer is not empty before calling the function.
    pub fn cirbuf_get_tail(cbuf: *mut cirbuf) -> ::std::os::raw::c_char;
}
extern "C" {
    /// Add a buffer at head of the circular buffer. 'c' is a pointer to a
/// buffer, and n is the number of char to add. Return the number of
/// copied bytes on success, or a negative value on error.
    pub fn cirbuf_add_buf_head(cbuf: *mut cirbuf,
                               c: *const ::std::os::raw::c_char,
                               n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a buffer at tail of the circular buffer. 'c' is a pointer to a
/// buffer, and n is the number of char to add. Return the number of
/// copied bytes on success, or a negative value on error.
    pub fn cirbuf_add_buf_tail(cbuf: *mut cirbuf,
                               c: *const ::std::os::raw::c_char,
                               n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove chars at the head of the circular buffer. Return 0 on
/// success, or a negative value on error.
    pub fn cirbuf_del_buf_head(cbuf: *mut cirbuf,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove chars at the tail of the circular buffer. Return 0 on
/// success, or a negative value on error.
    pub fn cirbuf_del_buf_tail(cbuf: *mut cirbuf,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy a maximum of 'size' characters from the head of the circular
/// buffer to a flat one pointed by 'c'. Return the number of copied
/// chars.
    pub fn cirbuf_get_buf_head(cbuf: *mut cirbuf,
                               c: *mut ::std::os::raw::c_char,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy a maximum of 'size' characters from the tail of the circular
/// buffer to a flat one pointed by 'c'. Return the number of copied
/// chars.
    pub fn cirbuf_get_buf_tail(cbuf: *mut cirbuf,
                               c: *mut ::std::os::raw::c_char,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the start of the data to the index 0 of the internal buffer.
    pub fn cirbuf_align_left(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the end of the data to the last index of the internal buffer.
    pub fn cirbuf_align_right(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "cmdline_vt100_commands"]
    pub static mut cmdline_vt100_commands:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cmdline_vt100_parser_state {
    CMDLINE_VT100_INIT = 0,
    CMDLINE_VT100_ESCAPE = 1,
    CMDLINE_VT100_ESCAPE_CSI = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_vt100 {
    pub bufpos: u8,
    pub buf: [::std::os::raw::c_char; 8usize],
    pub state: cmdline_vt100_parser_state,
}
#[test]
fn bindgen_test_layout_cmdline_vt100() {
    assert_eq!(::std::mem::size_of::<cmdline_vt100>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cmdline_vt100 ) ));
    assert_eq! (::std::mem::align_of::<cmdline_vt100>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmdline_vt100 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . bufpos as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_vt100 ) , "::"
                , stringify ! ( bufpos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . buf as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_vt100 ) , "::"
                , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . state as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_vt100 ) , "::"
                , stringify ! ( state ) ));
}
impl Clone for cmdline_vt100 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Init
    pub fn vt100_init(vt: *mut cmdline_vt100);
}
extern "C" {
    /// Input a new character.
/// Return -1 if the character is not part of a control sequence
/// Return -2 if c is not the last char of a control sequence
/// Else return the index in vt100_commands[]
    pub fn vt100_parser(vt: *mut cmdline_vt100, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rdline_status {
    RDLINE_INIT = 0,
    RDLINE_RUNNING = 1,
    RDLINE_EXITED = 2,
}
#[repr(C)]
pub struct rdline {
    pub status: rdline_status,
    pub left: cirbuf,
    pub right: cirbuf,
    pub left_buf: [::std::os::raw::c_char; 514usize],
    pub right_buf: [::std::os::raw::c_char; 512usize],
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub prompt_size: ::std::os::raw::c_uint,
    pub kill_buf: [::std::os::raw::c_char; 512usize],
    pub kill_size: ::std::os::raw::c_uint,
    pub history: cirbuf,
    pub history_buf: [::std::os::raw::c_char; 8192usize],
    pub history_cur_line: ::std::os::raw::c_int,
    pub write_char: rdline_write_char_t,
    pub validate: rdline_validate_t,
    pub complete: rdline_complete_t,
    pub vt100: cmdline_vt100,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rdline() {
    assert_eq!(::std::mem::size_of::<rdline>() , 9912usize , concat ! (
               "Size of: " , stringify ! ( rdline ) ));
    assert_eq! (::std::mem::align_of::<rdline>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rdline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . left as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . right as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . left_buf as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( left_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . right_buf as * const _ as
                usize } , 570usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( right_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . prompt as * const _ as usize
                } , 1082usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( prompt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . prompt_size as * const _ as
                usize } , 1116usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( prompt_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . kill_buf as * const _ as
                usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( kill_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . kill_size as * const _ as
                usize } , 1632usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( kill_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history as * const _ as
                usize } , 1640usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( history ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history_buf as * const _ as
                usize } , 1664usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( history_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history_cur_line as * const
                _ as usize } , 9856usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( history_cur_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . write_char as * const _ as
                usize } , 9864usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( write_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . validate as * const _ as
                usize } , 9872usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( validate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . complete as * const _ as
                usize } , 9880usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( complete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . vt100 as * const _ as usize
                } , 9888usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( vt100 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . opaque as * const _ as usize
                } , 9904usize , concat ! (
                "Alignment of field: " , stringify ! ( rdline ) , "::" ,
                stringify ! ( opaque ) ));
}
pub type rdline_write_char_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               arg1: ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
pub type rdline_validate_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               buf:
                                                   *const ::std::os::raw::c_char,
                                               size: ::std::os::raw::c_uint)>;
pub type rdline_complete_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               buf:
                                                   *const ::std::os::raw::c_char,
                                               dstbuf:
                                                   *mut ::std::os::raw::c_char,
                                               dstsize:
                                                   ::std::os::raw::c_uint,
                                               state:
                                                   *mut ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Init fields for a struct rdline. Call this only once at the beginning
/// of your program.
/// \param rdl A pointer to an uninitialized struct rdline
/// \param write_char The function used by the function to write a character
/// \param validate A pointer to the function to execute when the
/// user validates the buffer.
/// \param complete A pointer to the function to execute when the
/// user completes the buffer.
    pub fn rdline_init(rdl: *mut rdline, write_char: rdline_write_char_t,
                       validate: rdline_validate_t,
                       complete: rdline_complete_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Init the current buffer, and display a prompt.
/// \param rdl A pointer to a struct rdline
/// \param prompt A string containing the prompt
    pub fn rdline_newline(rdl: *mut rdline,
                          prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Call it and all received chars will be ignored.
/// \param rdl A pointer to a struct rdline
    pub fn rdline_stop(rdl: *mut rdline);
}
extern "C" {
    /// Same than rdline_stop() except that next calls to rdline_char_in()
/// will return RDLINE_RES_EXITED.
/// \param rdl A pointer to a struct rdline
    pub fn rdline_quit(rdl: *mut rdline);
}
extern "C" {
    /// Restart after a call to rdline_stop() or rdline_quit()
/// \param rdl A pointer to a struct rdline
    pub fn rdline_restart(rdl: *mut rdline);
}
extern "C" {
    /// Redisplay the current buffer
/// \param rdl A pointer to a struct rdline
    pub fn rdline_redisplay(rdl: *mut rdline);
}
extern "C" {
    /// Reset the current buffer and setup for a new line.
/// \param rdl A pointer to a struct rdline
    pub fn rdline_reset(rdl: *mut rdline);
}
extern "C" {
    /// append a char to the readline buffer.
/// Return RDLINE_RES_VALIDATE when the line has been validated.
/// Return RDLINE_RES_COMPLETE when the user asked to complete the buffer.
/// Return RDLINE_RES_NOT_RUNNING if it is not running.
/// Return RDLINE_RES_EOF if EOF (ctrl-d on an empty line).
/// Else return RDLINE_RES_SUCCESS.
/// XXX error case when the buffer is full ?
///
/// \param rdl A pointer to a struct rdline
/// \param c The character to append
    pub fn rdline_char_in(rdl: *mut rdline, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the current buffer, terminated by '\0'.
/// \param rdl A pointer to a struct rdline
    pub fn rdline_get_buffer(rdl: *mut rdline)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Add the buffer to history.
/// return < 0 on error.
/// \param rdl A pointer to a struct rdline
/// \param buf A buffer that is terminated by '\0'
    pub fn rdline_add_history(rdl: *mut rdline,
                              buf: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Clear current history
/// \param rdl A pointer to a struct rdline
    pub fn rdline_clear_history(rdl: *mut rdline);
}
extern "C" {
    /// Get the i-th history item
    pub fn rdline_get_history_item(rdl: *mut rdline,
                                   i: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_char;
}
/// Stores a pointer to the ops struct, and the offset: the place to
/// write the parsed result in the destination structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_hdr {
    pub ops: *mut cmdline_token_ops,
    pub offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cmdline_token_hdr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_hdr>() , 16usize , concat !
               ( "Size of: " , stringify ! ( cmdline_token_hdr ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_hdr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cmdline_token_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr ) ) . ops as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_hdr ) ,
                "::" , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr ) ) . offset as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_hdr ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for cmdline_token_hdr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_hdr_t = cmdline_token_hdr;
/// A token is defined by this structure.
///
/// parse() takes the token as first argument, then the source buffer
/// starting at the token we want to parse. The 3rd arg is a pointer
/// where we store the parsed data (as binary). It returns the number of
/// parsed chars on success and a negative value on error.
///
/// complete_get_nb() returns the number of possible values for this
/// token if completion is possible. If it is NULL or if it returns 0,
/// no completion is possible.
///
/// complete_get_elt() copy in dstbuf (the size is specified in the
/// parameter) the i-th possible completion for this token.  returns 0
/// on success or and a negative value on error.
///
/// get_help() fills the dstbuf with the help for the token. It returns
/// -1 on error and 0 on success.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_ops {
    /// parse(token ptr, buf, res pts, buf len)
    pub parse: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut cmdline_parse_token_hdr_t,
                                                          arg2:
                                                              *const ::std::os::raw::c_char,
                                                          arg3:
                                                              *mut ::std::os::raw::c_void,
                                                          arg4:
                                                              ::std::os::raw::c_uint)
                                         -> ::std::os::raw::c_int>,
    /// return the num of possible choices for this token
    pub complete_get_nb: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut cmdline_parse_token_hdr_t)
                                                   -> ::std::os::raw::c_int>,
    /// return the elt x for this token (token, idx, dstbuf, size)
    pub complete_get_elt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut cmdline_parse_token_hdr_t,
                                                                     arg2:
                                                                         ::std::os::raw::c_int,
                                                                     arg3:
                                                                         *mut ::std::os::raw::c_char,
                                                                     arg4:
                                                                         ::std::os::raw::c_uint)
                                                    -> ::std::os::raw::c_int>,
    /// get help for this token (token, dstbuf, size)
    pub get_help: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut cmdline_parse_token_hdr_t,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_char,
                                                             arg3:
                                                                 ::std::os::raw::c_uint)
                                            -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_cmdline_token_ops() {
    assert_eq!(::std::mem::size_of::<cmdline_token_ops>() , 32usize , concat !
               ( "Size of: " , stringify ! ( cmdline_token_ops ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_ops>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cmdline_token_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ops ) ) . parse as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ops ) ,
                "::" , stringify ! ( parse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ops ) ) . complete_get_nb
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ops ) ,
                "::" , stringify ! ( complete_get_nb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ops ) ) . complete_get_elt
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ops ) ,
                "::" , stringify ! ( complete_get_elt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ops ) ) . get_help as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ops ) ,
                "::" , stringify ! ( get_help ) ));
}
impl Clone for cmdline_token_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct cmdline {
    pub s_in: ::std::os::raw::c_int,
    pub s_out: ::std::os::raw::c_int,
    pub ctx: *mut cmdline_parse_ctx_t,
    pub rdl: rdline,
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub oldterm: termios,
}
#[test]
fn bindgen_test_layout_cmdline() {
    assert_eq!(::std::mem::size_of::<cmdline>() , 10024usize , concat ! (
               "Size of: " , stringify ! ( cmdline ) ));
    assert_eq! (::std::mem::align_of::<cmdline>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmdline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . s_in as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( s_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . s_out as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( s_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . ctx as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . rdl as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( rdl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . prompt as * const _ as
                usize } , 9928usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( prompt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . oldterm as * const _ as
                usize } , 9960usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline ) , "::" ,
                stringify ! ( oldterm ) ));
}
/// Store a instruction, which is a pointer to a callback function and
/// its parameter that is called when the instruction is parsed, a help
/// string, and a list of token composing this instruction.
///
/// When no tokens are defined (tokens[0] == NULL), they are retrieved
/// dynamically by calling f() as follows:
///
/// @code
///
/// f((struct cmdline_token_hdr **)&token_p,
/// NULL,
/// (struct cmdline_token_hdr **)&inst->tokens[num]);
///
/// @endcode
///
/// The address of the resulting token is expected at the location pointed by
/// the first argument. Can be set to NULL to end the list.
///
/// The cmdline argument (struct cmdline *) is always NULL.
///
/// The last argument points to the inst->tokens[] entry to retrieve, which
/// is not necessarily inside allocated memory and should neither be read nor
/// written. Its sole purpose is to deduce the token entry index of interest
/// as described in the example below.
///
/// Note about constraints:
///
/// - Only the address of these tokens is dynamic, their storage should be
/// static like normal tokens.
/// - Dynamic token lists that need to maintain an internal context (e.g. in
/// order to determine the next token) must store it statically also. This
/// context must be reinitialized when the first token is requested, that
/// is, when &inst->tokens[0] is provided as the third argument.
/// - Dynamic token lists must be NULL-terminated to generate usable
/// commands.
///
/// @code
///
/// // Assuming first and third arguments are respectively named "token_p"
/// // and "token":
///
/// int index = token - inst->tokens;
///
/// if (!index) {
/// [...] // Clean up internal context if any.
/// }
/// [...] // Then set up dyn_token according to index.
///
/// if (no_more_tokens)
/// *token_p = NULL;
/// else
/// *token_p = &dyn_token;
///
/// @endcode
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_inst {
    pub f: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                          *mut ::std::os::raw::c_void,
                                                      arg2: *mut cmdline,
                                                      arg3:
                                                          *mut ::std::os::raw::c_void)>,
    pub data: *mut ::std::os::raw::c_void,
    pub help_str: *const ::std::os::raw::c_char,
    pub tokens: __IncompleteArrayField<*mut cmdline_parse_token_hdr_t>,
}
#[test]
fn bindgen_test_layout_cmdline_inst() {
    assert_eq!(::std::mem::size_of::<cmdline_inst>() , 24usize , concat ! (
               "Size of: " , stringify ! ( cmdline_inst ) ));
    assert_eq! (::std::mem::align_of::<cmdline_inst>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmdline_inst ) ));
}
impl Clone for cmdline_inst {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_inst_t = cmdline_inst;
/// A context is identified by its name, and contains a list of
/// instruction
///
pub type cmdline_parse_ctx_t = *mut cmdline_parse_inst_t;
extern "C" {
    /// Try to parse a buffer according to the specified context. The
/// argument buf must ends with "\n\0". The function returns
/// CMDLINE_PARSE_AMBIGUOUS, CMDLINE_PARSE_NOMATCH or
/// CMDLINE_PARSE_BAD_ARGS on error. Else it calls the associated
/// function (defined in the context) and returns 0
/// (CMDLINE_PARSE_SUCCESS).
    pub fn cmdline_parse(cl: *mut cmdline, buf: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// complete() must be called with *state==0 (try to complete) or
/// with *state==-1 (just display choices), then called without
/// modifying *state until it returns CMDLINE_PARSE_COMPLETED_BUFFER or
/// CMDLINE_PARSE_COMPLETED_BUFFER.
///
/// It returns < 0 on error.
///
/// Else it returns:
/// - CMDLINE_PARSE_COMPLETED_BUFFER on completion (one possible
/// choice). In this case, the chars are appended in dst buffer.
/// - CMDLINE_PARSE_COMPLETE_AGAIN if there is several possible
/// choices. In this case, you must call the function again,
/// keeping the value of state intact.
/// - CMDLINE_PARSE_COMPLETED_BUFFER when the iteration is
/// finished. The dst is not valid for this last call.
///
/// The returned dst buf ends with \0.
    pub fn cmdline_complete(cl: *mut cmdline,
                            buf: *const ::std::os::raw::c_char,
                            state: *mut ::std::os::raw::c_int,
                            dst: *mut ::std::os::raw::c_char,
                            size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendoftoken(c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendofcommand(c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_new(ctx: *mut cmdline_parse_ctx_t,
                       prompt: *const ::std::os::raw::c_char,
                       s_in: ::std::os::raw::c_int,
                       s_out: ::std::os::raw::c_int) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_set_prompt(cl: *mut cmdline,
                              prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cmdline_free(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_printf(cl: *const cmdline,
                          fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cmdline_in(cl: *mut cmdline, buf: *const ::std::os::raw::c_char,
                      size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_write_char(rdl: *mut rdline, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function is nonblocking equivalent of ``cmdline_interact()``. It polls
/// *cl* for one character and interpret it. If return value is *RDLINE_EXITED*
/// it mean that ``cmdline_quit()`` was invoked.
///
/// @param cl
/// The command line object.
///
/// @return
/// On success return object status - one of *enum rdline_status*.
/// On error return negative value.
    pub fn cmdline_poll(cl: *mut cmdline) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_interact(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_quit(cl: *mut cmdline);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_etheraddr {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_etheraddr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_etheraddr>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( cmdline_token_etheraddr ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_etheraddr>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_etheraddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_etheraddr ) ) . hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_etheraddr
                ) , "::" , stringify ! ( hdr ) ));
}
impl Clone for cmdline_token_etheraddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_etheraddr_t = cmdline_token_etheraddr;
extern "C" {
    #[link_name = "cmdline_token_etheraddr_ops"]
    pub static mut cmdline_token_etheraddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_etheraddr(tk: *mut cmdline_parse_token_hdr_t,
                                   srcbuf: *const ::std::os::raw::c_char,
                                   res: *mut ::std::os::raw::c_void,
                                   ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_etheraddr(tk: *mut cmdline_parse_token_hdr_t,
                                      dstbuf: *mut ::std::os::raw::c_char,
                                      size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_ipaddr {
    pub family: u8,
    pub addr: cmdline_ipaddr__bindgen_ty_1,
    pub prefixlen: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_ipaddr__bindgen_ty_1 {
    pub ipv4: __BindgenUnionField<in_addr>,
    pub ipv6: __BindgenUnionField<in6_addr>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cmdline_ipaddr__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( cmdline_ipaddr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<cmdline_ipaddr__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( cmdline_ipaddr__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr__bindgen_ty_1 ) ) . ipv4
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cmdline_ipaddr__bindgen_ty_1 ) , "::" , stringify ! ( ipv4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr__bindgen_ty_1 ) ) . ipv6
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cmdline_ipaddr__bindgen_ty_1 ) , "::" , stringify ! ( ipv6 )
                ));
}
impl Clone for cmdline_ipaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr() {
    assert_eq!(::std::mem::size_of::<cmdline_ipaddr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( cmdline_ipaddr ) ));
    assert_eq! (::std::mem::align_of::<cmdline_ipaddr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmdline_ipaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . family as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_ipaddr ) , "::"
                , stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . addr as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_ipaddr ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . prefixlen as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_ipaddr ) , "::"
                , stringify ! ( prefixlen ) ));
}
impl Clone for cmdline_ipaddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_ipaddr_t = cmdline_ipaddr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_ipaddr_data {
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_ipaddr_data>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( cmdline_token_ipaddr_data ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_ipaddr_data>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_ipaddr_data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr_data ) ) . flags as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cmdline_token_ipaddr_data ) , "::" , stringify ! ( flags ) ));
}
impl Clone for cmdline_token_ipaddr_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_ipaddr {
    pub hdr: cmdline_token_hdr,
    pub ipaddr_data: cmdline_token_ipaddr_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_ipaddr>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( cmdline_token_ipaddr )
               ));
    assert_eq! (::std::mem::align_of::<cmdline_token_ipaddr>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_ipaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr ) ) . hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ipaddr )
                , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr ) ) . ipaddr_data as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_ipaddr )
                , "::" , stringify ! ( ipaddr_data ) ));
}
impl Clone for cmdline_token_ipaddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_ipaddr_t = cmdline_token_ipaddr;
extern "C" {
    #[link_name = "cmdline_token_ipaddr_ops"]
    pub static mut cmdline_token_ipaddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_ipaddr(tk: *mut cmdline_parse_token_hdr_t,
                                srcbuf: *const ::std::os::raw::c_char,
                                res: *mut ::std::os::raw::c_void,
                                ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_ipaddr(tk: *mut cmdline_parse_token_hdr_t,
                                   dstbuf: *mut ::std::os::raw::c_char,
                                   size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cmdline_numtype {
    UINT8 = 0,
    UINT16 = 1,
    UINT32 = 2,
    UINT64 = 3,
    INT8 = 4,
    INT16 = 5,
    INT32 = 6,
    INT64 = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_num_data {
    pub type_: cmdline_numtype,
}
#[test]
fn bindgen_test_layout_cmdline_token_num_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_num_data>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( cmdline_token_num_data )
               ));
    assert_eq! (::std::mem::align_of::<cmdline_token_num_data>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_num_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num_data ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_num_data
                ) , "::" , stringify ! ( type_ ) ));
}
impl Clone for cmdline_token_num_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_num {
    pub hdr: cmdline_token_hdr,
    pub num_data: cmdline_token_num_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_num() {
    assert_eq!(::std::mem::size_of::<cmdline_token_num>() , 24usize , concat !
               ( "Size of: " , stringify ! ( cmdline_token_num ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_num>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cmdline_token_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_num ) ,
                "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num ) ) . num_data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_num ) ,
                "::" , stringify ! ( num_data ) ));
}
impl Clone for cmdline_token_num {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_num_t = cmdline_token_num;
extern "C" {
    #[link_name = "cmdline_token_num_ops"]
    pub static mut cmdline_token_num_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_num(tk: *mut cmdline_parse_token_hdr_t,
                             srcbuf: *const ::std::os::raw::c_char,
                             res: *mut ::std::os::raw::c_void,
                             ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_num(tk: *mut cmdline_parse_token_hdr_t,
                                dstbuf: *mut ::std::os::raw::c_char,
                                size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_portlist {
    pub map: u32,
}
#[test]
fn bindgen_test_layout_cmdline_portlist() {
    assert_eq!(::std::mem::size_of::<cmdline_portlist>() , 4usize , concat ! (
               "Size of: " , stringify ! ( cmdline_portlist ) ));
    assert_eq! (::std::mem::align_of::<cmdline_portlist>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( cmdline_portlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_portlist ) ) . map as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_portlist ) ,
                "::" , stringify ! ( map ) ));
}
impl Clone for cmdline_portlist {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_portlist_t = cmdline_portlist;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_portlist {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_portlist() {
    assert_eq!(::std::mem::size_of::<cmdline_token_portlist>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cmdline_token_portlist )
               ));
    assert_eq! (::std::mem::align_of::<cmdline_token_portlist>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_portlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_portlist ) ) . hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_portlist
                ) , "::" , stringify ! ( hdr ) ));
}
impl Clone for cmdline_token_portlist {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_portlist_t = cmdline_token_portlist;
extern "C" {
    #[link_name = "cmdline_token_portlist_ops"]
    pub static mut cmdline_token_portlist_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_portlist(tk: *mut cmdline_parse_token_hdr_t,
                                  srcbuf: *const ::std::os::raw::c_char,
                                  res: *mut ::std::os::raw::c_void,
                                  ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_portlist(tk: *mut cmdline_parse_token_hdr_t,
                                     dstbuf: *mut ::std::os::raw::c_char,
                                     size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type cmdline_fixed_string_t = [::std::os::raw::c_char; 128usize];
pub type cmdline_multi_string_t = [::std::os::raw::c_char; 4096usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_string_data {
    pub str: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cmdline_token_string_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_string_data>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cmdline_token_string_data ) ));
    assert_eq! (::std::mem::align_of::<cmdline_token_string_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_string_data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string_data ) ) . str as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cmdline_token_string_data ) , "::" , stringify ! ( str ) ));
}
impl Clone for cmdline_token_string_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_string {
    pub hdr: cmdline_token_hdr,
    pub string_data: cmdline_token_string_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_string() {
    assert_eq!(::std::mem::size_of::<cmdline_token_string>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( cmdline_token_string )
               ));
    assert_eq! (::std::mem::align_of::<cmdline_token_string>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cmdline_token_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string ) ) . hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_string )
                , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string ) ) . string_data as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmdline_token_string )
                , "::" , stringify ! ( string_data ) ));
}
impl Clone for cmdline_token_string {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_string_t = cmdline_token_string;
extern "C" {
    #[link_name = "cmdline_token_string_ops"]
    pub static mut cmdline_token_string_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_string(tk: *mut cmdline_parse_token_hdr_t,
                                srcbuf: *const ::std::os::raw::c_char,
                                res: *mut ::std::os::raw::c_void,
                                ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_nb_string(tk: *mut cmdline_parse_token_hdr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_elt_string(tk: *mut cmdline_parse_token_hdr_t,
                                           idx: ::std::os::raw::c_int,
                                           dstbuf:
                                               *mut ::std::os::raw::c_char,
                                           size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_string(tk: *mut cmdline_parse_token_hdr_t,
                                   dstbuf: *mut ::std::os::raw::c_char,
                                   size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_file_new(ctx: *mut cmdline_parse_ctx_t,
                            prompt: *const ::std::os::raw::c_char,
                            path: *const ::std::os::raw::c_char)
     -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_new(ctx: *mut cmdline_parse_ctx_t,
                             prompt: *const ::std::os::raw::c_char)
     -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_exit(cl: *mut cmdline);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
pub const _ISupper: _bindgen_ty_7 = _bindgen_ty_7::_ISupper;
pub const _ISlower: _bindgen_ty_7 = _bindgen_ty_7::_ISlower;
pub const _ISalpha: _bindgen_ty_7 = _bindgen_ty_7::_ISalpha;
pub const _ISdigit: _bindgen_ty_7 = _bindgen_ty_7::_ISdigit;
pub const _ISxdigit: _bindgen_ty_7 = _bindgen_ty_7::_ISxdigit;
pub const _ISspace: _bindgen_ty_7 = _bindgen_ty_7::_ISspace;
pub const _ISprint: _bindgen_ty_7 = _bindgen_ty_7::_ISprint;
pub const _ISgraph: _bindgen_ty_7 = _bindgen_ty_7::_ISgraph;
pub const _ISblank: _bindgen_ty_7 = _bindgen_ty_7::_ISblank;
pub const _IScntrl: _bindgen_ty_7 = _bindgen_ty_7::_IScntrl;
pub const _ISpunct: _bindgen_ty_7 = _bindgen_ty_7::_ISpunct;
pub const _ISalnum: _bindgen_ty_7 = _bindgen_ty_7::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __WAIT_STATUS {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
extern "C" {
    /// Function to terminate the application immediately, printing an error
/// message and returning the exit_code back to the shell.
///
/// This function never returns
///
/// @param exit_code
/// The exit code to be returned by the application
/// @param format
/// The format string to be used for printing the message. This can include
/// printf format characters which will be expanded using any further parameters
/// to the function.
    pub fn rte_exit(exit_code: ::std::os::raw::c_int,
                    format: *const ::std::os::raw::c_char, ...);
}
/// 64 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v64u8_t = [u8; 8usize];
/// 64 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v64u16_t){ a0, a1, a2, a3 }
pub type rte_v64u16_t = [u16; 4usize];
/// 64 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v64u32_t){ a0, a1 }
pub type rte_v64u32_t = [u32; 2usize];
/// 128 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v128u8_t = [u8; 16usize];
/// 128 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v128u16_t = [u16; 8usize];
/// 128 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v128u32_t){ a0, a1, a2, a3, a4 }
pub type rte_v128u32_t = [u32; 4usize];
/// 128 bits vector size to use with unsigned 64 bits elements.
///
/// a = (rte_v128u64_t){ a0, a1 }
pub type rte_v128u64_t = [u64; 2usize];
/// 256 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15,
/// a16, a17, a18, a19, a20, a21, a22, a23,
/// a24, a25, a26, a27, a28, a29, a30, a31 }
pub type rte_v256u8_t = [u8; 32usize];
/// 256 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v256u16_t = [u16; 16usize];
/// 256 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v256u32_t = [u32; 8usize];
/// 256 bits vector size to use with unsigned 64 bits elements.
///
/// a = (rte_v256u64_t){ a0, a1, a2, a3 }
pub type rte_v256u64_t = [u64; 4usize];
/// 64 bits vector size to use with 8 bits elements.
///
/// a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v64s8_t = [i8; 8usize];
/// 64 bits vector size to use with 16 bits elements.
///
/// a = (rte_v64s16_t){ a0, a1, a2, a3 }
pub type rte_v64s16_t = [i16; 4usize];
/// 64 bits vector size to use with 32 bits elements.
///
/// a = (rte_v64s32_t){ a0, a1 }
pub type rte_v64s32_t = [i32; 2usize];
/// 128 bits vector size to use with 8 bits elements.
///
/// a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v128s8_t = [i8; 16usize];
/// 128 bits vector size to use with 16 bits elements.
///
/// a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v128s16_t = [i16; 8usize];
/// 128 bits vector size to use with 32 bits elements.
///
/// a = (rte_v128s32_t){ a0, a1, a2, a3 }
pub type rte_v128s32_t = [i32; 4usize];
/// 128 bits vector size to use with 64 bits elements.
///
/// a = (rte_v128s64_t){ a1, a2 }
pub type rte_v128s64_t = [i64; 2usize];
/// 256 bits vector size to use with 8 bits elements.
///
/// a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15,
/// a16, a17, a18, a19, a20, a21, a22, a23,
/// a24, a25, a26, a27, a28, a29, a30, a31 }
pub type rte_v256s8_t = [i8; 32usize];
/// 256 bits vector size to use with 16 bits elements.
///
/// a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,
/// a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v256s16_t = [i16; 16usize];
/// 256 bits vector size to use with 32 bits elements.
///
/// a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v256s32_t = [i32; 8usize];
/// 256 bits vector size to use with 64 bits elements.
///
/// a = (rte_v256s64_t){ a0, a1, a2, a3 }
pub type rte_v256s64_t = [i64; 4usize];
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[derive(Copy)]
pub struct rte_xmm {
    pub x: __BindgenUnionField<xmm_t>,
    pub u8: __BindgenUnionField<[u8; 16usize]>,
    pub u16: __BindgenUnionField<[u16; 8usize]>,
    pub u32: __BindgenUnionField<[u32; 4usize]>,
    pub u64: __BindgenUnionField<[u64; 2usize]>,
    pub pd: __BindgenUnionField<[f64; 2usize]>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(::std::mem::size_of::<rte_xmm>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . x as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u8 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( u8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u16 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( u16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u32 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( u32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u64 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( u64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . pd as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_xmm ) , "::" ,
                stringify ! ( pd ) ));
}
impl Clone for rte_xmm {
    fn clone(&self) -> Self { *self }
}
pub type rte_xmm_t = rte_xmm;
/// A structure used to store memory information.
#[repr(C)]
pub struct memory_info {
    pub name: [::std::os::raw::c_char; 256usize],
    pub size: u64,
}
#[test]
fn bindgen_test_layout_memory_info() {
    assert_eq!(::std::mem::size_of::<memory_info>() , 264usize , concat ! (
               "Size of: " , stringify ! ( memory_info ) ));
    assert_eq! (::std::mem::align_of::<memory_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memory_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memory_info ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memory_info ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memory_info ) ) . size as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( memory_info ) , "::" ,
                stringify ! ( size ) ));
}
/// A structure used to store memory segment information.
#[repr(C)]
pub struct memseg_info {
    pub idx: u32,
    pub pfn: u64,
    pub size: u64,
    pub mfn: [u64; 2048usize],
}
#[test]
fn bindgen_test_layout_memseg_info() {
    assert_eq!(::std::mem::size_of::<memseg_info>() , 16408usize , concat ! (
               "Size of: " , stringify ! ( memseg_info ) ));
    assert_eq! (::std::mem::align_of::<memseg_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memseg_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memseg_info ) ) . idx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memseg_info ) , "::" ,
                stringify ! ( idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memseg_info ) ) . pfn as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memseg_info ) , "::" ,
                stringify ! ( pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memseg_info ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( memseg_info ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memseg_info ) ) . mfn as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( memseg_info ) , "::" ,
                stringify ! ( mfn ) ));
}
/// A structure used to store memory block information.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct memblock_info {
    pub exchange_flag: u8,
    pub used: u8,
    pub vir_addr: u64,
    pub pfn: u64,
    pub mfn: u64,
}
#[test]
fn bindgen_test_layout_memblock_info() {
    assert_eq!(::std::mem::size_of::<memblock_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( memblock_info ) ));
    assert_eq! (::std::mem::align_of::<memblock_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( memblock_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memblock_info ) ) . exchange_flag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memblock_info ) , "::"
                , stringify ! ( exchange_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memblock_info ) ) . used as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( memblock_info ) , "::"
                , stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memblock_info ) ) . vir_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memblock_info ) , "::"
                , stringify ! ( vir_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memblock_info ) ) . pfn as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( memblock_info ) , "::"
                , stringify ! ( pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memblock_info ) ) . mfn as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( memblock_info ) , "::"
                , stringify ! ( mfn ) ));
}
impl Clone for memblock_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_page_sizes {
    RTE_PGSIZE_4K = 4096,
    RTE_PGSIZE_64K = 65536,
    RTE_PGSIZE_256K = 262144,
    RTE_PGSIZE_2M = 2097152,
    RTE_PGSIZE_16M = 16777216,
    RTE_PGSIZE_256M = 268435456,
    RTE_PGSIZE_512M = 536870912,
    RTE_PGSIZE_1G = 1073741824,
    RTE_PGSIZE_4G = 4294967296,
    RTE_PGSIZE_16G = 17179869184,
}
pub type phys_addr_t = u64;
/// Physical memory segment descriptor.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_memseg {
    /// < Start physical address.
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    /// < Length of the segment.
    pub len: usize,
    /// < The pagesize of underlying memory
    pub hugepage_sz: u64,
    /// < NUMA socket ID.
    pub socket_id: i32,
    /// < Number of channels.
    pub nchannel: u32,
    /// < Number of ranks.
    pub nrank: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_memseg__bindgen_ty_1 {
    /// < Start virtual address.
    pub addr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /// < Makes sure addr is always 64 bits
    pub addr_64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_memseg__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_memseg__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_memseg__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_memseg__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg__bindgen_ty_1 ) ) . addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_memseg__bindgen_ty_1 ) , "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg__bindgen_ty_1 ) ) . addr_64 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_memseg__bindgen_ty_1 ) , "::" , stringify ! ( addr_64 )
                ));
}
impl Clone for rte_memseg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(::std::mem::size_of::<rte_memseg>() , 44usize , concat ! (
               "Size of: " , stringify ! ( rte_memseg ) ));
    assert_eq! (::std::mem::align_of::<rte_memseg>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( rte_memseg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . phys_addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . hugepage_sz as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( hugepage_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . socket_id as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . nchannel as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( nchannel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . nrank as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memseg ) , "::" ,
                stringify ! ( nrank ) ));
}
impl Clone for rte_memseg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Lock page in physical memory and prevent from swapping.
///
/// @param virt
/// The virtual address.
/// @return
/// 0 on success, negative on error.
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get physical address of any mapped virtual address in the current process.
/// It is found by browsing the /proc/self/pagemap special file.
/// The page must be locked.
///
/// @param virt
/// The virtual address.
/// @return
/// The physical address or RTE_BAD_PHYS_ADDR on error.
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void)
     -> phys_addr_t;
}
extern "C" {
    /// Get the layout of the available physical memory.
///
/// It can be useful for an application to have the full physical
/// memory layout to decide the size of a memory zone to reserve. This
/// table is stored in rte_config (see rte_eal_get_configuration()).
///
/// @return
/// - On success, return a pointer to a read-only table of struct
/// rte_physmem_desc elements, containing the layout of all
/// addressable physical memory. The last element of the table
/// contains a NULL address.
/// - On error, return NULL. This should not happen since it is a fatal
/// error that will probably cause the entire system to panic.
    pub fn rte_eal_get_physmem_layout() -> *const rte_memseg;
}
extern "C" {
    /// Dump the physical memory layout to a file.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    /// Get the total amount of available physical memory.
///
/// @return
/// The total amount of available physical memory in bytes.
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    /// Get the number of memory channels.
///
/// @return
/// The number of memory channels on the system. The value is 0 if unknown
/// or not the same on all devices.
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the number of memory ranks.
///
/// @return
/// The number of memory ranks on the system. The value is 0 if unknown or
/// not the same on all devices.
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
/// The rte_log structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_logs {
    /// < Bitfield with enabled logs.
    pub type_: u32,
    /// < Log level.
    pub level: u32,
    /// < Output file set by rte_openlog_stream, or NULL.
    pub file: *mut FILE,
    pub dynamic_types_len: usize,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(::std::mem::size_of::<rte_logs>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rte_logs ) ));
    assert_eq! (::std::mem::align_of::<rte_logs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_logs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_logs ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_logs ) , "::" ,
                stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . file as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_logs ) , "::" ,
                stringify ! ( file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . dynamic_types_len as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_logs ) , "::" ,
                stringify ! ( dynamic_types_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . dynamic_types as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_logs ) , "::" ,
                stringify ! ( dynamic_types ) ));
}
impl Clone for rte_logs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_logs"]
    pub static mut rte_logs: rte_logs;
}
extern "C" {
    /// Change the stream that will be used by the logging system.
///
/// This can be done at any time. The f argument represents the stream
/// to be used to send the logs. If f is NULL, the default output is
/// used (stderr).
///
/// @param f
/// Pointer to the stream.
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the global log level.
///
/// After this call, logs with a level lower or equal than the level
/// passed as argument will be displayed.
///
/// @param level
/// Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    /// Deprecated, replaced by rte_log_set_global_level().
    pub fn rte_set_log_level(level: u32);
}
extern "C" {
    /// Get the global log level.
///
/// @return
/// The current global log level.
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    /// Deprecated, replaced by rte_log_get_global_level().
    pub fn rte_get_log_level() -> u32;
}
extern "C" {
    /// Enable or disable the log type.
///
/// @param type
/// Log type, for example, RTE_LOGTYPE_EAL.
/// @param enable
/// True for enable; false for disable.
    pub fn rte_set_log_type(type_: u32, enable: ::std::os::raw::c_int);
}
extern "C" {
    /// Get the global log type.
    pub fn rte_get_log_type() -> u32;
}
extern "C" {
    /// Get the log level for a given type.
///
/// @param logtype
/// The log type identifier.
/// @return
/// 0 on success, a negative value if logtype is invalid.
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level for a given type.
///
/// @param pattern
/// The regexp identifying the log type.
/// @param level
/// The level to be set.
/// @return
/// 0 on success, a negative value if level is invalid.
    pub fn rte_log_set_level_regexp(pattern: *const ::std::os::raw::c_char,
                                    level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level for a given type.
///
/// @param logtype
/// The log type identifier.
/// @param level
/// The level to be set.
/// @return
/// 0 on success, a negative value if logtype or level is invalid.
    pub fn rte_log_set_level(logtype: u32, level: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current loglevel for the message being processed.
///
/// Before calling the user-defined stream for logging, the log
/// subsystem sets a per-lcore variable containing the loglevel and the
/// logtype of the message being processed. This information can be
/// accessed by the user-defined log output function through this
/// function.
///
/// @return
/// The loglevel of the message being processed.
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current logtype for the message being processed.
///
/// Before calling the user-defined stream for logging, the log
/// subsystem sets a per-lcore variable containing the loglevel and the
/// logtype of the message being processed. This information can be
/// accessed by the user-defined log output function through this
/// function.
///
/// @return
/// The logtype of the message being processed.
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register a dynamic log type
///
/// If a log is already registered with the same type, the returned value
/// is the same than the previous one.
///
/// @param name
/// The string identifying the log type.
/// @return
/// - >0: success, the returned value is the log type identifier.
/// - (-ENONEM): cannot allocate memory.
    pub fn rte_log_register(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump log information.
///
/// Dump the global level and the registered log types.
///
/// @param f
/// The output stream where the dump should be sent.
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    /// Generates a log message.
///
/// The message will be sent in the stream defined by the previous call
/// to rte_openlog_stream().
///
/// The level argument determines if the log should be displayed or
/// not, depending on the global rte_logs variable.
///
/// The preferred alternative is the RTE_LOG() because it adds the
/// level and type in the logged string.
///
/// @param level
/// Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
/// @param logtype
/// The log type, for example, RTE_LOGTYPE_EAL.
/// @param format
/// The format string, as in printf(3), followed by the variable arguments
/// required by the format.
/// @return
/// - 0: Success.
/// - Negative on error.
    pub fn rte_log(level: u32, logtype: u32,
                   format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generates a log message.
///
/// The message will be sent in the stream defined by the previous call
/// to rte_openlog_stream().
///
/// The level argument determines if the log should be displayed or
/// not, depending on the global rte_logs variable. A trailing
/// newline may be added if needed.
///
/// The preferred alternative is the RTE_LOG() because it adds the
/// level and type in the logged string.
///
/// @param level
/// Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
/// @param logtype
/// The log type, for example, RTE_LOGTYPE_EAL.
/// @param format
/// The format string, as in printf(3), followed by the variable arguments
/// required by the format.
/// @param ap
/// The va_list of the variable arguments required by the format.
/// @return
/// - 0: Success.
/// - Negative on error.
    pub fn rte_vlog(level: u32, logtype: u32,
                    format: *const ::std::os::raw::c_char,
                    ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
/// A structure describing a memzone, which is a contiguous portion of
/// physical memory identified by a name.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_memzone {
    /// < Name of the memory zone.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Start physical address.
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    /// < Length of the memzone.
    pub len: usize,
    /// < The page size of underlying memory
    pub hugepage_sz: u64,
    /// < NUMA socket ID.
    pub socket_id: i32,
    /// < Characteristics of this memzone.
    pub flags: u32,
    /// < Memseg it belongs.
    pub memseg_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_memzone__bindgen_ty_1 {
    /// < Start virtual address.
    pub addr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /// < Makes sure addr is always 64-bits
    pub addr_64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_memzone__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_memzone__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_memzone__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_memzone__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone__bindgen_ty_1 ) ) . addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_memzone__bindgen_ty_1 ) , "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone__bindgen_ty_1 ) ) . addr_64
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_memzone__bindgen_ty_1 ) , "::" , stringify ! ( addr_64 )
                ));
}
impl Clone for rte_memzone__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(::std::mem::size_of::<rte_memzone>() , 76usize , concat ! (
               "Size of: " , stringify ! ( rte_memzone ) ));
    assert_eq! (::std::mem::align_of::<rte_memzone>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( rte_memzone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . phys_addr as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . len as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . hugepage_sz as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( hugepage_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . socket_id as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . flags as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . memseg_id as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_memzone ) , "::" ,
                stringify ! ( memseg_id ) ));
}
impl Clone for rte_memzone {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Reserve a portion of physical memory.
///
/// This function reserves some memory and returns a pointer to a
/// correctly filled memzone descriptor. If the allocation cannot be
/// done, return NULL.
///
/// @param name
/// The name of the memzone. If it already exists, the function will
/// fail and return NULL.
/// @param len
/// The size of the memory to be reserved. If it
/// is 0, the biggest contiguous zone will be reserved.
/// @param socket_id
/// The socket identifier in the case of
/// NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// The flags parameter is used to request memzones to be
/// taken from specifically sized hugepages.
/// - RTE_MEMZONE_2MB - Reserved from 2MB pages
/// - RTE_MEMZONE_1GB - Reserved from 1GB pages
/// - RTE_MEMZONE_16MB - Reserved from 16MB pages
/// - RTE_MEMZONE_16GB - Reserved from 16GB pages
/// - RTE_MEMZONE_256KB - Reserved from 256KB pages
/// - RTE_MEMZONE_256MB - Reserved from 256MB pages
/// - RTE_MEMZONE_512MB - Reserved from 512MB pages
/// - RTE_MEMZONE_4GB - Reserved from 4GB pages
/// - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
/// the requested page size is unavailable.
/// If this flag is not set, the function
/// will return error on an unavailable size
/// request.
/// @return
/// A pointer to a correctly-filled read-only memzone descriptor, or NULL
/// on error.
/// On error case, rte_errno will be set appropriately:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
/// - EINVAL - invalid parameters
    pub fn rte_memzone_reserve(name: *const ::std::os::raw::c_char,
                               len: usize, socket_id: ::std::os::raw::c_int,
                               flags: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /// Reserve a portion of physical memory with alignment on a specified
/// boundary.
///
/// This function reserves some memory with alignment on a specified
/// boundary, and returns a pointer to a correctly filled memzone
/// descriptor. If the allocation cannot be done or if the alignment
/// is not a power of 2, returns NULL.
///
/// @param name
/// The name of the memzone. If it already exists, the function will
/// fail and return NULL.
/// @param len
/// The size of the memory to be reserved. If it
/// is 0, the biggest contiguous zone will be reserved.
/// @param socket_id
/// The socket identifier in the case of
/// NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// The flags parameter is used to request memzones to be
/// taken from specifically sized hugepages.
/// - RTE_MEMZONE_2MB - Reserved from 2MB pages
/// - RTE_MEMZONE_1GB - Reserved from 1GB pages
/// - RTE_MEMZONE_16MB - Reserved from 16MB pages
/// - RTE_MEMZONE_16GB - Reserved from 16GB pages
/// - RTE_MEMZONE_256KB - Reserved from 256KB pages
/// - RTE_MEMZONE_256MB - Reserved from 256MB pages
/// - RTE_MEMZONE_512MB - Reserved from 512MB pages
/// - RTE_MEMZONE_4GB - Reserved from 4GB pages
/// - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
/// the requested page size is unavailable.
/// If this flag is not set, the function
/// will return error on an unavailable size
/// request.
/// @param align
/// Alignment for resulting memzone. Must be a power of 2.
/// @return
/// A pointer to a correctly-filled read-only memzone descriptor, or NULL
/// on error.
/// On error case, rte_errno will be set appropriately:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
/// - EINVAL - invalid parameters
    pub fn rte_memzone_reserve_aligned(name: *const ::std::os::raw::c_char,
                                       len: usize,
                                       socket_id: ::std::os::raw::c_int,
                                       flags: ::std::os::raw::c_uint,
                                       align: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /// Reserve a portion of physical memory with specified alignment and
/// boundary.
///
/// This function reserves some memory with specified alignment and
/// boundary, and returns a pointer to a correctly filled memzone
/// descriptor. If the allocation cannot be done or if the alignment
/// or boundary are not a power of 2, returns NULL.
/// Memory buffer is reserved in a way, that it wouldn't cross specified
/// boundary. That implies that requested length should be less or equal
/// then boundary.
///
/// @param name
/// The name of the memzone. If it already exists, the function will
/// fail and return NULL.
/// @param len
/// The size of the memory to be reserved. If it
/// is 0, the biggest contiguous zone will be reserved.
/// @param socket_id
/// The socket identifier in the case of
/// NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// The flags parameter is used to request memzones to be
/// taken from specifically sized hugepages.
/// - RTE_MEMZONE_2MB - Reserved from 2MB pages
/// - RTE_MEMZONE_1GB - Reserved from 1GB pages
/// - RTE_MEMZONE_16MB - Reserved from 16MB pages
/// - RTE_MEMZONE_16GB - Reserved from 16GB pages
/// - RTE_MEMZONE_256KB - Reserved from 256KB pages
/// - RTE_MEMZONE_256MB - Reserved from 256MB pages
/// - RTE_MEMZONE_512MB - Reserved from 512MB pages
/// - RTE_MEMZONE_4GB - Reserved from 4GB pages
/// - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
/// the requested page size is unavailable.
/// If this flag is not set, the function
/// will return error on an unavailable size
/// request.
/// @param align
/// Alignment for resulting memzone. Must be a power of 2.
/// @param bound
/// Boundary for resulting memzone. Must be a power of 2 or zero.
/// Zero value implies no boundary condition.
/// @return
/// A pointer to a correctly-filled read-only memzone descriptor, or NULL
/// on error.
/// On error case, rte_errno will be set appropriately:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
/// - EINVAL - invalid parameters
    pub fn rte_memzone_reserve_bounded(name: *const ::std::os::raw::c_char,
                                       len: usize,
                                       socket_id: ::std::os::raw::c_int,
                                       flags: ::std::os::raw::c_uint,
                                       align: ::std::os::raw::c_uint,
                                       bound: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /// Free a memzone.
///
/// @param mz
/// A pointer to the memzone
/// @return
/// -EINVAL - invalid parameter.
/// 0 - success
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Lookup for a memzone.
///
/// Get a pointer to a descriptor of an already reserved memory
/// zone identified by the name given as an argument.
///
/// @param name
/// The name of the memzone.
/// @return
/// A pointer to a read-only memzone descriptor.
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char)
     -> *const rte_memzone;
}
extern "C" {
    /// Dump all reserved memzones to a file.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    /// Walk list of all memzones
///
/// @param func
/// Iterator function
/// @param arg
/// Argument passed to iterator
    pub fn rte_memzone_walk(func:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const rte_memzone,
                                                                           arg:
                                                                               *mut ::std::os::raw::c_void)>,
                            arg: *mut ::std::os::raw::c_void);
}
/// Structure to hold heap statistics obtained from rte_malloc_get_socket_stats function.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_malloc_socket_stats {
    /// < Total bytes on heap
    pub heap_totalsz_bytes: usize,
    /// < Total free bytes on heap
    pub heap_freesz_bytes: usize,
    /// < Size in bytes of largest free block
    pub greatest_free_size: usize,
    /// < Number of free elements on heap
    pub free_count: ::std::os::raw::c_uint,
    /// < Number of allocated elements on heap
    pub alloc_count: ::std::os::raw::c_uint,
    /// < Total allocated bytes on heap
    pub heap_allocsz_bytes: usize,
}
#[test]
fn bindgen_test_layout_rte_malloc_socket_stats() {
    assert_eq!(::std::mem::size_of::<rte_malloc_socket_stats>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_malloc_socket_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_malloc_socket_stats>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_malloc_socket_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_totalsz_bytes as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( heap_totalsz_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_freesz_bytes as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( heap_freesz_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                greatest_free_size as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( greatest_free_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) . free_count
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( free_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) . alloc_count
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( alloc_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_allocsz_bytes as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_malloc_socket_stats
                ) , "::" , stringify ! ( heap_allocsz_bytes ) ));
}
impl Clone for rte_malloc_socket_stats {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// This function allocates memory from the huge-page area of memory. The memory
/// is not cleared. In NUMA systems, the memory allocated resides on the same
/// NUMA socket as the core that calls this function.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param size
/// Size (in bytes) to be allocated.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_malloc(type_: *const ::std::os::raw::c_char, size: usize,
                      align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate zero'ed memory from the heap.
///
/// Equivalent to rte_malloc() except that the memory zone is
/// initialised with zeros. In NUMA systems, the memory allocated resides on the
/// same NUMA socket as the core that calls this function.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param size
/// Size (in bytes) to be allocated.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must obviously be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_zmalloc(type_: *const ::std::os::raw::c_char, size: usize,
                       align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for calloc(), using huge-page memory. Memory area is
/// initialised with zeros. In NUMA systems, the memory allocated resides on the
/// same NUMA socket as the core that calls this function.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param num
/// Number of elements to be allocated.
/// @param size
/// Size (in bytes) of a single element.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must obviously be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_calloc(type_: *const ::std::os::raw::c_char, num: usize,
                      size: usize, align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for realloc(), using huge-page memory. Reserved area
/// memory is resized, preserving contents. In NUMA systems, the new area
/// resides on the same NUMA socket as the old area.
///
/// @param ptr
/// Pointer to already allocated memory
/// @param size
/// Size (in bytes) of new area. If this is 0, memory is freed.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must obviously be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the reallocated memory.
    pub fn rte_realloc(ptr: *mut ::std::os::raw::c_void, size: usize,
                       align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// This function allocates memory from the huge-page area of memory. The memory
/// is not cleared.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param size
/// Size (in bytes) to be allocated.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @param socket
/// NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
/// will behave the same as rte_malloc().
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_malloc_socket(type_: *const ::std::os::raw::c_char,
                             size: usize, align: ::std::os::raw::c_uint,
                             socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate zero'ed memory from the heap.
///
/// Equivalent to rte_malloc() except that the memory zone is
/// initialised with zeros.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param size
/// Size (in bytes) to be allocated.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must obviously be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @param socket
/// NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
/// will behave the same as rte_zmalloc().
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_zmalloc_socket(type_: *const ::std::os::raw::c_char,
                              size: usize, align: ::std::os::raw::c_uint,
                              socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for calloc(), using huge-page memory. Memory area is
/// initialised with zeros.
///
/// @param type
/// A string identifying the type of allocated objects (useful for debug
/// purposes, such as identifying the cause of a memory leak). Can be NULL.
/// @param num
/// Number of elements to be allocated.
/// @param size
/// Size (in bytes) of a single element.
/// @param align
/// If 0, the return is a pointer that is suitably aligned for any kind of
/// variable (in the same manner as malloc()).
/// Otherwise, the return is a pointer that is a multiple of *align*. In
/// this case, it must obviously be a power of two. (Minimum alignment is the
/// cacheline size, i.e. 64-bytes)
/// @param socket
/// NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
/// will behave the same as rte_calloc().
/// @return
/// - NULL on error. Not enough memory, or invalid arguments (size is 0,
/// align is not a power of two).
/// - Otherwise, the pointer to the allocated object.
    pub fn rte_calloc_socket(type_: *const ::std::os::raw::c_char, num: usize,
                             size: usize, align: ::std::os::raw::c_uint,
                             socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Frees the memory space pointed to by the provided pointer.
///
/// This pointer must have been returned by a previous call to
/// rte_malloc(), rte_zmalloc(), rte_calloc() or rte_realloc(). The behaviour of
/// rte_free() is undefined if the pointer does not match this requirement.
///
/// If the pointer is NULL, the function does nothing.
///
/// @param ptr
/// The pointer to memory to be freed.
    pub fn rte_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// If malloc debug is enabled, check a memory block for header
/// and trailer markers to indicate that all is well with the block.
/// If size is non-null, also return the size of the block.
///
/// @param ptr
/// pointer to the start of a data block, must have been returned
/// by a previous call to rte_malloc(), rte_zmalloc(), rte_calloc()
/// or rte_realloc()
/// @param size
/// if non-null, and memory block pointer is valid, returns the size
/// of the memory block
/// @return
/// -1 on error, invalid pointer passed or header and trailer markers
/// are missing or corrupted
/// 0 on success
    pub fn rte_malloc_validate(ptr: *const ::std::os::raw::c_void,
                               size: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get heap statistics for the specified heap.
///
/// @param socket
/// An unsigned integer specifying the socket to get heap statistics for
/// @param socket_stats
/// A structure which provides memory to store statistics
/// @return
/// Null on error
/// Pointer to structure storing statistics on success
    pub fn rte_malloc_get_socket_stats(socket: ::std::os::raw::c_int,
                                       socket_stats:
                                           *mut rte_malloc_socket_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump statistics.
///
/// Dump for the specified type to a file. If the type argument is
/// NULL, all memory types will be dumped.
///
/// @param f
/// A pointer to a file for output
/// @param type
/// A string identifying the type of objects to dump, or NULL
/// to dump all objects.
    pub fn rte_malloc_dump_stats(f: *mut FILE,
                                 type_: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Set the maximum amount of allocated memory for this type.
///
/// This is not yet implemented
///
/// @param type
/// A string identifying the type of allocated objects.
/// @param max
/// The maximum amount of allocated bytes for this type.
/// @return
/// - 0: Success.
/// - (-1): Error.
    pub fn rte_malloc_set_limit(type_: *const ::std::os::raw::c_char,
                                max: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the physical address of a virtual address obtained through
/// rte_malloc
///
/// @param addr
/// Address obtained from a previous rte_malloc call
/// @return
/// RTE_BAD_PHYS_ADDR on error
/// otherwise return physical address of the buffer
    pub fn rte_malloc_virt2phy(addr: *const ::std::os::raw::c_void)
     -> phys_addr_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sched_param ) ));
    assert_eq! (::std::mem::align_of::<sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( __sched_priority ) ));
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( __sched_param ) ));
    assert_eq! (::std::mem::align_of::<__sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sched_param ) , "::"
                , stringify ! ( __sched_priority ) ));
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(::std::mem::size_of::<cpu_set_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( cpu_set_t ) ));
    assert_eq! (::std::mem::align_of::<cpu_set_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_set_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_set_t ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_set_t ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for cpu_set_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_11 =
    _bindgen_ty_11::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_11 =
    _bindgen_ty_11::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_11 =
    _bindgen_ty_11::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_12 =
    _bindgen_ty_12::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_12 =
    _bindgen_ty_12::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_12 =
    _bindgen_ty_12::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_12 =
    _bindgen_ty_12::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_13 =
    _bindgen_ty_13::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_13 =
    _bindgen_ty_13::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_14 =
    _bindgen_ty_14::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_14 =
    _bindgen_ty_14::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_15 =
    _bindgen_ty_15::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_15 =
    _bindgen_ty_15::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __routine
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __arg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) .
                __canceltype as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __canceltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __prev as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __prev ) ));
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_16 =
    _bindgen_ty_16::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_16 =
    _bindgen_ty_16::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_17 =
    _bindgen_ty_17::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_17 =
    _bindgen_ty_17::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr:
                                         *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr:
                                     *mut *mut ::std::os::raw::c_void,
                                 __stacksize: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::std::os::raw::c_void,
                                 __stacksize: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() ,
               72usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __cancel_jmp_buf as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __mask_was_saved as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __mask_was_saved ) ));
}
impl Clone for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) .
                __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) . __pad as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __pad ) ));
}
impl Clone for __pthread_unwind_buf_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_arg as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) . __do_it as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __do_it ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_type as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_type ) ));
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::std::os::raw::c_int,
                                        __old_ceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling:
                                                *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(__prepare:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                              ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// The lcore role (used in RTE or not).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_lcore_role_t { ROLE_RTE = 0, ROLE_OFF = 1, ROLE_SERVICE = 2, }
#[repr(i32)]
/// The type of process in a linuxapp, multi-process setup
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_proc_type_t {
    RTE_PROC_AUTO = -1,
    RTE_PROC_PRIMARY = 0,
    RTE_PROC_SECONDARY = 1,
    RTE_PROC_INVALID = 2,
}
/// The global RTE configuration structure.
#[repr(C, packed)]
pub struct rte_config {
    /// < Id of the master lcore
    pub master_lcore: u32,
    /// < Number of available logical cores.
    pub lcore_count: u32,
    /// < Number of available service cores.
    pub service_lcore_count: u32,
    /// < State of cores.
    pub lcore_role: [rte_lcore_role_t; 128usize],
    /// Primary or secondary configuration
    pub process_type: rte_proc_type_t,
    /// Pointer to memory configuration, which may be shared across multiple
    /// DPDK instances
    pub mem_config: *mut rte_mem_config,
}
#[test]
fn bindgen_test_layout_rte_config() {
    assert_eq!(::std::mem::size_of::<rte_config>() , 536usize , concat ! (
               "Size of: " , stringify ! ( rte_config ) ));
    assert_eq! (::std::mem::align_of::<rte_config>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( rte_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . master_lcore as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( master_lcore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . lcore_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( lcore_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . service_lcore_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( service_lcore_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . lcore_role as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( lcore_role ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . process_type as * const
                _ as usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( process_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . mem_config as * const _
                as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_config ) , "::" ,
                stringify ! ( mem_config ) ));
}
extern "C" {
    /// Get the global configuration structure.
///
/// @return
/// A pointer to the global configuration structure.
    pub fn rte_eal_get_configuration() -> *mut rte_config;
}
extern "C" {
    /// Get a lcore's role.
///
/// @param lcore_id
/// The identifier of the lcore.
/// @return
/// The role of the lcore.
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint)
     -> rte_lcore_role_t;
}
extern "C" {
    /// Get the process type in a multi-process setup
///
/// @return
/// The process type
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    /// Request iopl privilege for all RPL.
///
/// This function should be called by pmds which need access to ioports.
///
/// @return
/// - On success, returns 0.
/// - On failure, returns -1.
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize the Environment Abstraction Layer (EAL).
///
/// This function is to be executed on the MASTER lcore only, as soon
/// as possible in the application's main() function.
///
/// The function finishes the initialization process before main() is called.
/// It puts the SLAVE lcores in the WAIT state.
///
/// When the multi-partition feature is supported, depending on the
/// configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this
/// function waits to ensure that the magic number is set before
/// returning. See also the rte_eal_get_configuration() function. Note:
/// This behavior may change in the future.
///
/// @param argc
/// A non-negative value.  If it is greater than 0, the array members
/// for argv[0] through argv[argc] (non-inclusive) shall contain pointers
/// to strings.
/// @param argv
/// An array of strings.  The contents of the array, as well as the strings
/// which are pointed to by the array, may be modified by this function.
/// @return
/// - On success, the number of parsed arguments, which is greater or
/// equal to zero. After the call to rte_eal_init(),
/// all arguments argv[x] with x < ret may have been modified by this
/// function call and should not be further interpreted by the
/// application.  The EAL does not take any ownership of the memory used
/// for either the argv array, or its members.
/// - On failure, -1 and rte_errno is set to a value indicating the cause
/// for failure.  In some instances, the application will need to be
/// restarted as part of clearing the issue.
///
/// Error codes returned via rte_errno:
/// EACCES indicates a permissions issue.
///
/// EAGAIN indicates either a bus or system resource was not available,
/// setup may be attempted again.
///
/// EALREADY indicates that the rte_eal_init function has already been
/// called, and cannot be called again.
///
/// EFAULT indicates the tailq configuration name was not found in
/// memory configuration.
///
/// EINVAL indicates invalid parameters were passed as argv/argc.
///
/// ENOMEM indicates failure likely caused by an out-of-memory condition.
///
/// ENODEV indicates memory setup issues.
///
/// ENOTSUP indicates that the EAL cannot initialize on this system.
///
/// EPROTO indicates that the PCI bus is either not present, or is not
/// readable by the eal.
///
/// ENOEXEC indicates that a service core failed to launch successfully.
    pub fn rte_eal_init(argc: ::std::os::raw::c_int,
                        argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if a primary process is currently alive
///
/// This function returns true when a primary process is currently
/// active.
///
/// @param config_file_path
/// The config_file_path argument provided should point at the location
/// that the primary process will create its config file. If NULL, the default
/// config file path is used.
///
/// @return
/// - If alive, returns 1.
/// - If dead, returns 0.
    pub fn rte_eal_primary_proc_alive(config_file_path:
                                          *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/// Usage function typedef used by the application usage function.
///
/// Use this function typedef to define and call rte_set_applcation_usage_hook()
/// routine.
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /// Add application usage routine callout from the eal_usage() routine.
///
/// This function allows the application to include its usage message
/// in the EAL system usage message. The routine rte_set_application_usage_hook()
/// needs to be called before the rte_eal_init() routine in the application.
///
/// This routine is optional for the application and will behave as if the set
/// routine was never called as the default behavior.
///
/// @param usage_func
/// The func argument is a function pointer to the application usage routine.
/// Called function is defined using rte_usage_hook_t typedef, which is of
/// the form void rte_usage_func(const char * prgname).
///
/// Calling this routine with a NULL value will reset the usage hook routine and
/// return the current value, which could be NULL.
/// @return
/// - Returns the current value of the rte_application_usage pointer to allow
/// the caller to daisy chain the usage routines if needing more then one.
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t)
     -> rte_usage_hook_t;
}
extern "C" {
    /// Whether EAL is using huge pages (disabled by --no-huge option).
/// The no-huge mode cannot be used with UIO poll-mode drivers like igb/ixgbe.
/// It is useful for NIC drivers (e.g. librte_pmd_mlx4, librte_pmd_vmxnet3) or
/// crypto drivers (e.g. librte_crypto_nitrox) provided by third-parties such
/// as 6WIND.
///
/// @return
/// Nonzero if hugepages are enabled.
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    /// A wrap API for syscall gettid.
///
/// @return
/// On success, returns the thread ID of calling process.
/// It is always successful.
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump the stack of the calling core to the console.
    pub fn rte_dump_stack();
}
extern "C" {
    /// Dump the registers of the calling core to the console.
///
/// Note: Not implemented in a userapp environment; use gdb instead.
    pub fn rte_dump_registers();
}
extern "C" {
    pub fn __rte_panic(funcname: *const ::std::os::raw::c_char,
                       format: *const ::std::os::raw::c_char, ...);
}
/// dummy structure type used by the rte_tailq APIs
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry {
    /// < Pointer entries for a tailq list
    pub next: rte_tailq_entry__bindgen_ty_1,
    /// < Pointer to the data referenced by this tailq entry
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_entry,
    pub tqe_prev: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_tailq_entry__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tailq_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tailq_entry__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tailq_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tailq_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for rte_tailq_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tailq_entry() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_tailq_entry ) ));
    assert_eq! (::std::mem::align_of::<rte_tailq_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_tailq_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry ) ) . next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_entry ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry ) ) . data as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_entry ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for rte_tailq_entry {
    fn clone(&self) -> Self { *self }
}
/// dummy
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry_head {
    pub tqh_first: *mut rte_tailq_entry,
    pub tqh_last: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry_head() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry_head>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_tailq_entry_head )
               ));
    assert_eq! (::std::mem::align_of::<rte_tailq_entry_head>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tailq_entry_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry_head ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_entry_head )
                , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry_head ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_entry_head )
                , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_tailq_entry_head {
    fn clone(&self) -> Self { *self }
}
/// The structure defining a tailq header entry for storing
/// in the rte_config structure in shared memory. Each tailq
/// is identified by name.
/// Any library storing a set of objects e.g. rings, mempools, hash-tables,
/// is recommended to use an entry here, so as to make it easy for
/// a multi-process app to find already-created elements in shared memory.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_head {
    /// < NOTE: must be first element
    pub tailq_head: rte_tailq_entry_head,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_rte_tailq_head() {
    assert_eq!(::std::mem::size_of::<rte_tailq_head>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_tailq_head ) ));
    assert_eq! (::std::mem::align_of::<rte_tailq_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tailq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_head ) ) . tailq_head as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_head ) , "::"
                , stringify ! ( tailq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_head ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_head ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for rte_tailq_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_elem {
    /// Reference to head in shared mem, updated at init time by
    /// rte_eal_tailqs_init()
    pub head: *mut rte_tailq_head,
    pub next: rte_tailq_elem__bindgen_ty_1,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_elem__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_elem,
    pub tqe_prev: *mut *mut rte_tailq_elem,
}
#[test]
fn bindgen_test_layout_rte_tailq_elem__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tailq_elem__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_tailq_elem__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tailq_elem__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tailq_elem__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tailq_elem__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tailq_elem__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev
                ) ));
}
impl Clone for rte_tailq_elem__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tailq_elem() {
    assert_eq!(::std::mem::size_of::<rte_tailq_elem>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rte_tailq_elem ) ));
    assert_eq! (::std::mem::align_of::<rte_tailq_elem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tailq_elem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_elem ) , "::"
                , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_elem ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . name as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tailq_elem ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for rte_tailq_elem {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Dump tail queues to a file.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_dump_tailq(f: *mut FILE);
}
extern "C" {
    /// Lookup for a tail queue.
///
/// Get a pointer to a tail queue header of a tail
/// queue identified by the name given as an argument.
/// Note: this function is not multi-thread safe, and should only be called from
/// a single thread at a time
///
/// @param name
/// The name of the queue.
/// @return
/// A pointer to the tail queue head structure.
    pub fn rte_eal_tailq_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_tailq_head;
}
extern "C" {
    /// Register a tail queue.
///
/// Register a tail queue from shared memory.
/// This function is mainly used by EAL_REGISTER_TAILQ macro which is used to
/// register tailq from the different dpdk libraries. Since this macro is a
/// constructor, the function has no access to dpdk shared memory, so the
/// registered tailq can not be used before call to rte_eal_init() which calls
/// rte_eal_tailqs_init().
///
/// @param t
/// The tailq element which contains the name of the tailq you want to
/// create (/retrieve when in secondary process).
/// @return
/// 0 on success or -1 in case of an error.
    pub fn rte_eal_tailq_register(t: *mut rte_tailq_elem)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// State of an lcore.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_lcore_state_t { WAIT = 0, RUNNING = 1, FINISHED = 2, }
/// Definition of a remote launch function.
pub type lcore_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Launch a function on another lcore.
///
/// To be executed on the MASTER lcore only.
///
/// Sends a message to a slave lcore (identified by the slave_id) that
/// is in the WAIT state (this is true after the first call to
/// rte_eal_init()). This can be checked by first calling
/// rte_eal_wait_lcore(slave_id).
///
/// When the remote lcore receives the message, it switches to
/// the RUNNING state, then calls the function f with argument arg. Once the
/// execution is done, the remote lcore switches to a FINISHED state and
/// the return value of f is stored in a local variable to be read using
/// rte_eal_wait_lcore().
///
/// The MASTER lcore returns as soon as the message is sent and knows
/// nothing about the completion of f.
///
/// Note: This function is not designed to offer optimum
/// performance. It is just a practical way to launch a function on
/// another lcore at initialization time.
///
/// @param f
/// The function to be called.
/// @param arg
/// The argument for the function.
/// @param slave_id
/// The identifier of the lcore on which the function should be executed.
/// @return
/// - 0: Success. Execution of function f started on the remote lcore.
/// - (-EBUSY): The remote lcore is not in a WAIT state.
    pub fn rte_eal_remote_launch(f: lcore_function_t,
                                 arg: *mut ::std::os::raw::c_void,
                                 slave_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// This enum indicates whether the master core must execute the handler
/// launched on all logical cores.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_rmt_call_master_t { SKIP_MASTER = 0, CALL_MASTER = 1, }
extern "C" {
    /// Launch a function on all lcores.
///
/// Check that each SLAVE lcore is in a WAIT state, then call
/// rte_eal_remote_launch() for each lcore.
///
/// @param f
/// The function to be called.
/// @param arg
/// The argument for the function.
/// @param call_master
/// If call_master set to SKIP_MASTER, the MASTER lcore does not call
/// the function. If call_master is set to CALL_MASTER, the function
/// is also called on master before returning. In any case, the master
/// lcore returns as soon as it finished its job and knows nothing
/// about the completion of f on the other lcores.
/// @return
/// - 0: Success. Execution of function f started on all remote lcores.
/// - (-EBUSY): At least one remote lcore is not in a WAIT state. In this
/// case, no message is sent to any of the lcores.
    pub fn rte_eal_mp_remote_launch(f: lcore_function_t,
                                    arg: *mut ::std::os::raw::c_void,
                                    call_master: rte_rmt_call_master_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the state of the lcore identified by slave_id.
///
/// To be executed on the MASTER lcore only.
///
/// @param slave_id
/// The identifier of the lcore.
/// @return
/// The state of the lcore.
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint)
     -> rte_lcore_state_t;
}
extern "C" {
    /// Wait until an lcore finishes its job.
///
/// To be executed on the MASTER lcore only.
///
/// If the slave lcore identified by the slave_id is in a FINISHED state,
/// switch to the WAIT state. If the lcore is in RUNNING state, wait until
/// the lcore finishes its job and moves to the FINISHED state.
///
/// @param slave_id
/// The identifier of the lcore.
/// @return
/// - 0: If the lcore identified by the slave_id is in a WAIT state.
/// - The value that was returned by the previous remote launch
/// function call if the lcore identified by the slave_id was in a
/// FINISHED or RUNNING state. In this case, it changes the state
/// of the lcore to WAIT.
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait until all lcores finish their jobs.
///
/// To be executed on the MASTER lcore only. Issue an
/// rte_eal_wait_lcore() for every lcore. The return values are
/// ignored.
///
/// After a call to rte_eal_mp_wait_lcore(), the caller can assume
/// that all slave lcores are in a WAIT state.
    pub fn rte_eal_mp_wait_lcore();
}
pub type rte_cpuset_t = cpu_set_t;
/// Structure storing internal configuration (per-lcore)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcore_config {
    /// < true if lcore was detected
    pub detected: ::std::os::raw::c_uint,
    /// < pthread identifier
    pub thread_id: pthread_t,
    /// < communication pipe with master
    pub pipe_master2slave: [::std::os::raw::c_int; 2usize],
    /// < communication pipe with master
    pub pipe_slave2master: [::std::os::raw::c_int; 2usize],
    /// < function to call
    pub f: lcore_function_t,
    /// < argument of function
    pub arg: *mut ::std::os::raw::c_void,
    /// < return value of function
    pub ret: ::std::os::raw::c_int,
    /// < lcore state
    pub state: rte_lcore_state_t,
    /// < physical socket id for this lcore
    pub socket_id: ::std::os::raw::c_uint,
    /// < core number on socket for this lcore
    pub core_id: ::std::os::raw::c_uint,
    /// < relative index, starting from 0
    pub core_index: ::std::os::raw::c_int,
    /// < cpu set which the lcore affinity to
    pub cpuset: rte_cpuset_t,
    /// < role of core eg: OFF, RTE, SERVICE
    pub core_role: u8,
}
#[test]
fn bindgen_test_layout_lcore_config() {
    assert_eq!(::std::mem::size_of::<lcore_config>() , 208usize , concat ! (
               "Size of: " , stringify ! ( lcore_config ) ));
    assert_eq! (::std::mem::align_of::<lcore_config>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcore_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . detected as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( detected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . thread_id as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( thread_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . pipe_master2slave as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( pipe_master2slave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . pipe_slave2master as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( pipe_slave2master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . f as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . arg as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . ret as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( ret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . state as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . socket_id as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . core_id as * const _
                as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( core_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . core_index as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( core_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . cpuset as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . core_role as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( lcore_config ) , "::" ,
                stringify ! ( core_role ) ));
}
impl Clone for lcore_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "lcore_config"]
    pub static mut lcore_config: [lcore_config; 128usize];
}
extern "C" {
    #[thread_local]
    #[link_name = "per_lcore__lcore_id"]
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
extern "C" {
    #[thread_local]
    #[link_name = "per_lcore__cpuset"]
    pub static mut per_lcore__cpuset: cpu_set_t;
}
extern "C" {
    /// Return the ID of the physical socket of the logical core we are
/// running on.
/// @return
/// the ID of current lcoreid's physical socket
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Set core affinity of the current thread.
/// Support both EAL and non-EAL thread and update TLS.
///
/// @param cpusetp
/// Point to cpu_set_t for setting current thread affinity.
/// @return
/// On success, return 0; otherwise return -1;
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get core affinity of the current thread.
///
/// @param cpusetp
/// Point to cpu_set_t for getting current thread cpu affinity.
/// It presumes input is not NULL, otherwise it causes panic.
///
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    /// Set thread names.
///
/// @note It fails with glibc < 2.12.
///
/// @param id
/// Thread id.
/// @param name
/// Thread name to set.
/// @return
/// On success, return 0; otherwise return a negative value.
    pub fn rte_thread_setname(id: pthread_t,
                              name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/// The rte_spinlock_t type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_spinlock_t {
    /// < lock status 0 = unlocked, 1 = locked
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(::std::mem::size_of::<rte_spinlock_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_spinlock_t ) ));
    assert_eq! (::std::mem::align_of::<rte_spinlock_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_spinlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_spinlock_t ) ) . locked as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_spinlock_t ) , "::"
                , stringify ! ( locked ) ));
}
impl Clone for rte_spinlock_t {
    fn clone(&self) -> Self { *self }
}
/// The rte_spinlock_recursive_t type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_spinlock_recursive_t {
    /// < the actual spinlock
    pub sl: rte_spinlock_t,
    /// < core id using lock, -1 for unused
    pub user: ::std::os::raw::c_int,
    /// < count of time this lock has been called
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(::std::mem::size_of::<rte_spinlock_recursive_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_spinlock_recursive_t ) ));
    assert_eq! (::std::mem::align_of::<rte_spinlock_recursive_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_spinlock_recursive_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_spinlock_recursive_t ) ) . sl as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_spinlock_recursive_t ) , "::" , stringify ! ( sl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_spinlock_recursive_t ) ) . user as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_spinlock_recursive_t ) , "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_spinlock_recursive_t ) ) . count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_spinlock_recursive_t ) , "::" , stringify ! ( count ) ));
}
impl Clone for rte_spinlock_recursive_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Enumeration of all CPU features supported
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_cpu_flag_t {
    RTE_CPUFLAG_SSE3 = 0,
    RTE_CPUFLAG_PCLMULQDQ = 1,
    RTE_CPUFLAG_DTES64 = 2,
    RTE_CPUFLAG_MONITOR = 3,
    RTE_CPUFLAG_DS_CPL = 4,
    RTE_CPUFLAG_VMX = 5,
    RTE_CPUFLAG_SMX = 6,
    RTE_CPUFLAG_EIST = 7,
    RTE_CPUFLAG_TM2 = 8,
    RTE_CPUFLAG_SSSE3 = 9,
    RTE_CPUFLAG_CNXT_ID = 10,
    RTE_CPUFLAG_FMA = 11,
    RTE_CPUFLAG_CMPXCHG16B = 12,
    RTE_CPUFLAG_XTPR = 13,
    RTE_CPUFLAG_PDCM = 14,
    RTE_CPUFLAG_PCID = 15,
    RTE_CPUFLAG_DCA = 16,
    RTE_CPUFLAG_SSE4_1 = 17,
    RTE_CPUFLAG_SSE4_2 = 18,
    RTE_CPUFLAG_X2APIC = 19,
    RTE_CPUFLAG_MOVBE = 20,
    RTE_CPUFLAG_POPCNT = 21,
    RTE_CPUFLAG_TSC_DEADLINE = 22,
    RTE_CPUFLAG_AES = 23,
    RTE_CPUFLAG_XSAVE = 24,
    RTE_CPUFLAG_OSXSAVE = 25,
    RTE_CPUFLAG_AVX = 26,
    RTE_CPUFLAG_F16C = 27,
    RTE_CPUFLAG_RDRAND = 28,
    RTE_CPUFLAG_FPU = 29,
    RTE_CPUFLAG_VME = 30,
    RTE_CPUFLAG_DE = 31,
    RTE_CPUFLAG_PSE = 32,
    RTE_CPUFLAG_TSC = 33,
    RTE_CPUFLAG_MSR = 34,
    RTE_CPUFLAG_PAE = 35,
    RTE_CPUFLAG_MCE = 36,
    RTE_CPUFLAG_CX8 = 37,
    RTE_CPUFLAG_APIC = 38,
    RTE_CPUFLAG_SEP = 39,
    RTE_CPUFLAG_MTRR = 40,
    RTE_CPUFLAG_PGE = 41,
    RTE_CPUFLAG_MCA = 42,
    RTE_CPUFLAG_CMOV = 43,
    RTE_CPUFLAG_PAT = 44,
    RTE_CPUFLAG_PSE36 = 45,
    RTE_CPUFLAG_PSN = 46,
    RTE_CPUFLAG_CLFSH = 47,
    RTE_CPUFLAG_DS = 48,
    RTE_CPUFLAG_ACPI = 49,
    RTE_CPUFLAG_MMX = 50,
    RTE_CPUFLAG_FXSR = 51,
    RTE_CPUFLAG_SSE = 52,
    RTE_CPUFLAG_SSE2 = 53,
    RTE_CPUFLAG_SS = 54,
    RTE_CPUFLAG_HTT = 55,
    RTE_CPUFLAG_TM = 56,
    RTE_CPUFLAG_PBE = 57,
    RTE_CPUFLAG_DIGTEMP = 58,
    RTE_CPUFLAG_TRBOBST = 59,
    RTE_CPUFLAG_ARAT = 60,
    RTE_CPUFLAG_PLN = 61,
    RTE_CPUFLAG_ECMD = 62,
    RTE_CPUFLAG_PTM = 63,
    RTE_CPUFLAG_MPERF_APERF_MSR = 64,
    RTE_CPUFLAG_ACNT2 = 65,
    RTE_CPUFLAG_ENERGY_EFF = 66,
    RTE_CPUFLAG_FSGSBASE = 67,
    RTE_CPUFLAG_BMI1 = 68,
    RTE_CPUFLAG_HLE = 69,
    RTE_CPUFLAG_AVX2 = 70,
    RTE_CPUFLAG_SMEP = 71,
    RTE_CPUFLAG_BMI2 = 72,
    RTE_CPUFLAG_ERMS = 73,
    RTE_CPUFLAG_INVPCID = 74,
    RTE_CPUFLAG_RTM = 75,
    RTE_CPUFLAG_AVX512F = 76,
    RTE_CPUFLAG_LAHF_SAHF = 77,
    RTE_CPUFLAG_LZCNT = 78,
    RTE_CPUFLAG_SYSCALL = 79,
    RTE_CPUFLAG_XD = 80,
    RTE_CPUFLAG_1GB_PG = 81,
    RTE_CPUFLAG_RDTSCP = 82,
    RTE_CPUFLAG_EM64T = 83,
    RTE_CPUFLAG_INVTSC = 84,
    RTE_CPUFLAG_NUMFLAGS = 85,
}
extern "C" {
    /// Get name of CPU flag
///
/// @param feature
/// CPU flag ID
/// @return
/// flag name
/// NULL if flag ID is invalid
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Function for checking a CPU flag availability
///
/// @param feature
/// CPU flag to query CPU for
/// @return
/// 1 if flag is available
/// 0 if flag is not available
/// -ENOENT if flag is invalid
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function checks that the currently used CPU supports the CPU features
/// that were specified at compile time. It is called automatically within the
/// EAL, so does not need to be used by applications.
    pub fn rte_cpu_check_supported();
}
extern "C" {
    /// This function checks that the currently used CPU supports the CPU features
/// that were specified at compile time. It is called automatically within the
/// EAL, so does not need to be used by applications.  This version returns a
/// result so that decisions may be made (for instance, graceful shutdowns).
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rte_rtm_supported"]
    pub static mut rte_rtm_supported: u8;
}
/// Structure to hold malloc heap
#[repr(C)]
#[derive(Copy)]
pub struct malloc_heap {
    pub lock: rte_spinlock_t,
    pub free_head: [malloc_heap__bindgen_ty_1; 13usize],
    pub alloc_count: ::std::os::raw::c_uint,
    pub total_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_heap__bindgen_ty_1 {
    pub lh_first: *mut malloc_elem,
}
#[test]
fn bindgen_test_layout_malloc_heap__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<malloc_heap__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( malloc_heap__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<malloc_heap__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_heap__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap__bindgen_ty_1 ) ) . lh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_heap__bindgen_ty_1 ) , "::" , stringify ! ( lh_first )
                ));
}
impl Clone for malloc_heap__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_malloc_heap() {
    assert_eq!(::std::mem::size_of::<malloc_heap>() , 128usize , concat ! (
               "Size of: " , stringify ! ( malloc_heap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_heap ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . free_head as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_heap ) , "::" ,
                stringify ! ( free_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . alloc_count as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_heap ) , "::" ,
                stringify ! ( alloc_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . total_size as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_heap ) , "::" ,
                stringify ! ( total_size ) ));
}
impl Clone for malloc_heap {
    fn clone(&self) -> Self { *self }
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_atomic16_t {
    /// < An internal counter value.
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(::std::mem::size_of::<rte_atomic16_t>() , 2usize , concat ! (
               "Size of: " , stringify ! ( rte_atomic16_t ) ));
    assert_eq! (::std::mem::align_of::<rte_atomic16_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rte_atomic16_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_atomic16_t ) ) . cnt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_atomic16_t ) , "::"
                , stringify ! ( cnt ) ));
}
impl Clone for rte_atomic16_t {
    fn clone(&self) -> Self { *self }
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_atomic32_t {
    /// < An internal counter value.
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(::std::mem::size_of::<rte_atomic32_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_atomic32_t ) ));
    assert_eq! (::std::mem::align_of::<rte_atomic32_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_atomic32_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_atomic32_t ) ) . cnt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_atomic32_t ) , "::"
                , stringify ! ( cnt ) ));
}
impl Clone for rte_atomic32_t {
    fn clone(&self) -> Self { *self }
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_atomic64_t {
    /// < Internal counter value.
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(::std::mem::size_of::<rte_atomic64_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_atomic64_t ) ));
    assert_eq! (::std::mem::align_of::<rte_atomic64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_atomic64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_atomic64_t ) ) . cnt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_atomic64_t ) , "::"
                , stringify ! ( cnt ) ));
}
impl Clone for rte_atomic64_t {
    fn clone(&self) -> Self { *self }
}
/// The rte_rwlock_t type.
///
/// cnt is -1 when write lock is held, and > 0 when read locks are held.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_rwlock_t {
    /// < -1 when W lock held, > 0 when R locks held.
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    assert_eq!(::std::mem::size_of::<rte_rwlock_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<rte_rwlock_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_rwlock_t ) ) . cnt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_rwlock_t ) , "::" ,
                stringify ! ( cnt ) ));
}
impl Clone for rte_rwlock_t {
    fn clone(&self) -> Self { *self }
}
/// the structure for the memory configuration for the RTE.
/// Used by the rte_config structure. It is separated out, as for multi-process
/// support, the memory details should be shared across instances
#[repr(C, packed)]
pub struct rte_mem_config {
    /// < Magic number - Sanity check.
    pub magic: u32,
    /// < Number of channels (0 if unknown).
    pub nchannel: u32,
    /// < Number of ranks (0 if unknown).
    pub nrank: u32,
    /// < only used by memzone LIB for thread-safe.
    pub mlock: rte_rwlock_t,
    /// < used for tailq operation for thread safe.
    pub qlock: rte_rwlock_t,
    /// < only used by mempool LIB for thread-safe.
    pub mplock: rte_rwlock_t,
    /// < Number of allocated memzones
    pub memzone_cnt: u32,
    /// < Physmem descriptors.
    pub memseg: [rte_memseg; 256usize],
    /// < Memzone descriptors.
    pub memzone: [rte_memzone; 2560usize],
    /// < Tailqs for objects
    pub tailq_head: [rte_tailq_head; 32usize],
    pub malloc_heaps: [malloc_heap; 8usize],
    pub mem_cfg_addr: u64,
}
#[test]
fn bindgen_test_layout_rte_mem_config() {
    assert_eq!(::std::mem::size_of::<rte_mem_config>() , 208420usize , concat
               ! ( "Size of: " , stringify ! ( rte_mem_config ) ));
    assert_eq! (::std::mem::align_of::<rte_mem_config>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( rte_mem_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . magic as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . nchannel as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( nchannel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . nrank as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( nrank ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . mlock as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( mlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . qlock as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( qlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . mplock as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( mplock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . memzone_cnt as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( memzone_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . memseg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( memseg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . memzone as * const _
                as usize } , 11292usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( memzone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . tailq_head as *
                const _ as usize } , 205852usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( tailq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . malloc_heaps as *
                const _ as usize } , 207388usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( malloc_heaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_config ) ) . mem_cfg_addr as *
                const _ as usize } , 208412usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_config ) , "::"
                , stringify ! ( mem_cfg_addr ) ));
}
extern "C" {
    #[thread_local]
    #[link_name = "per_lcore__rte_errno"]
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
extern "C" {
    /// Function which returns a printable string describing a particular
/// error code. For non-RTE-specific error codes, this function returns
/// the value from the libc strerror function.
///
/// @param errnum
/// The error number to be looked up - generally the value of rte_errno
/// @return
/// A pointer to a thread-local string containing the text describing
/// the error.
    pub fn rte_strerror(errnum: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
pub const RTE_MIN_ERRNO: _bindgen_ty_18 = _bindgen_ty_18::RTE_MIN_ERRNO;
pub const E_RTE_SECONDARY: _bindgen_ty_18 = _bindgen_ty_18::E_RTE_SECONDARY;
pub const E_RTE_NO_CONFIG: _bindgen_ty_18 = _bindgen_ty_18::E_RTE_NO_CONFIG;
pub const RTE_MAX_ERRNO: _bindgen_ty_18 = _bindgen_ty_18::RTE_MAX_ERRNO;
#[repr(u32)]
/// Error types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    RTE_MIN_ERRNO = 1000,
    E_RTE_SECONDARY = 1001,
    E_RTE_NO_CONFIG = 1002,
    RTE_MAX_ERRNO = 1003,
}
extern "C" {
    /// Takes string "string" parameter and splits it at character "delim"
/// up to maxtokens-1 times - to give "maxtokens" resulting tokens. Like
/// strtok or strsep functions, this modifies its input string, by replacing
/// instances of "delim" with '\\0'. All resultant tokens are returned in the
/// "tokens" array which must have enough entries to hold "maxtokens".
///
/// @param string
/// The input string to be split into tokens
///
/// @param stringlen
/// The max length of the input buffer
///
/// @param tokens
/// The array to hold the pointers to the tokens in the string
///
/// @param maxtokens
/// The number of elements in the tokens array. At most, maxtokens-1 splits
/// of the string will be done.
///
/// @param delim
/// The character on which the split of the data will be done
///
/// @return
/// The number of tokens in the tokens array.
    pub fn rte_strsplit(string: *mut ::std::os::raw::c_char,
                        stringlen: ::std::os::raw::c_int,
                        tokens: *mut *mut ::std::os::raw::c_char,
                        maxtokens: ::std::os::raw::c_int,
                        delim: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field_types {
    pub u8: __BindgenUnionField<u8>,
    pub u16: __BindgenUnionField<u16>,
    pub u32: __BindgenUnionField<u32>,
    pub u64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_acl_field_types() {
    assert_eq!(::std::mem::size_of::<rte_acl_field_types>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_acl_field_types ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_field_types>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_acl_field_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_types ) ,
                "::" , stringify ! ( u8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u16 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_types ) ,
                "::" , stringify ! ( u16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u32 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_types ) ,
                "::" , stringify ! ( u32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u64 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_types ) ,
                "::" , stringify ! ( u64 ) ));
}
impl Clone for rte_acl_field_types {
    fn clone(&self) -> Self { *self }
}
pub const RTE_ACL_FIELD_TYPE_MASK: _bindgen_ty_19 =
    _bindgen_ty_19::RTE_ACL_FIELD_TYPE_MASK;
pub const RTE_ACL_FIELD_TYPE_RANGE: _bindgen_ty_19 =
    _bindgen_ty_19::RTE_ACL_FIELD_TYPE_RANGE;
pub const RTE_ACL_FIELD_TYPE_BITMASK: _bindgen_ty_19 =
    _bindgen_ty_19::RTE_ACL_FIELD_TYPE_BITMASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    RTE_ACL_FIELD_TYPE_MASK = 0,
    RTE_ACL_FIELD_TYPE_RANGE = 1,
    RTE_ACL_FIELD_TYPE_BITMASK = 2,
}
/// ACL Field definition.
/// Each field in the ACL rule has an associate definition.
/// It defines the type of field, its size, its offset in the input buffer,
/// the field index, and the input index.
/// For performance reasons, the inner loop of the search function is unrolled
/// to process four input bytes at a time. This requires the input to be grouped
/// into sets of 4 consecutive bytes. The loop processes the first input byte as
/// part of the setup and then subsequent bytes must be in groups of 4
/// consecutive bytes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field_def {
    /// < type - RTE_ACL_FIELD_TYPE_*.
    pub type_: u8,
    /// < size of field 1,2,4, or 8.
    pub size: u8,
    /// < index of field inside the rule.
    pub field_index: u8,
    /// < 0-N input index.
    pub input_index: u8,
    /// < offset to start of field.
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_field_def() {
    assert_eq!(::std::mem::size_of::<rte_acl_field_def>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_acl_field_def ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_field_def>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_acl_field_def ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_def ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . size as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_def ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . field_index as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_def ) ,
                "::" , stringify ! ( field_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . input_index as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_def ) ,
                "::" , stringify ! ( input_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field_def ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for rte_acl_field_def {
    fn clone(&self) -> Self { *self }
}
/// ACL build configuration.
/// Defines the fields of an ACL trie and number of categories to build with.
#[repr(C)]
pub struct rte_acl_config {
    /// < Number of categories to build with.
    pub num_categories: u32,
    /// < Number of field definitions.
    pub num_fields: u32,
    pub defs: [rte_acl_field_def; 64usize],
    pub max_size: usize,
}
#[test]
fn bindgen_test_layout_rte_acl_config() {
    assert_eq!(::std::mem::size_of::<rte_acl_config>() , 528usize , concat ! (
               "Size of: " , stringify ! ( rte_acl_config ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_config>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_acl_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . num_categories as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_config ) , "::"
                , stringify ! ( num_categories ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . num_fields as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_config ) , "::"
                , stringify ! ( num_fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . defs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_config ) , "::"
                , stringify ! ( defs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . max_size as * const
                _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_config ) , "::"
                , stringify ! ( max_size ) ));
}
/// Defines the value of a field for a rule.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field {
    pub value: rte_acl_field_types,
    pub mask_range: rte_acl_field_types,
}
#[test]
fn bindgen_test_layout_rte_acl_field() {
    assert_eq!(::std::mem::size_of::<rte_acl_field>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_acl_field ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_field>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_acl_field ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field ) ) . mask_range as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_field ) , "::"
                , stringify ! ( mask_range ) ));
}
impl Clone for rte_acl_field {
    fn clone(&self) -> Self { *self }
}
pub const RTE_ACL_TYPE_SHIFT: _bindgen_ty_20 =
    _bindgen_ty_20::RTE_ACL_TYPE_SHIFT;
pub const RTE_ACL_MAX_INDEX: _bindgen_ty_20 =
    _bindgen_ty_20::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MAX_PRIORITY: _bindgen_ty_20 =
    _bindgen_ty_20::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MIN_PRIORITY: _bindgen_ty_20 =
    _bindgen_ty_20::RTE_ACL_MIN_PRIORITY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    RTE_ACL_TYPE_SHIFT = 29,
    RTE_ACL_MAX_INDEX = 536870911,
    RTE_ACL_MIN_PRIORITY = 0,
}
/// Miscellaneous data for ACL rule.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_rule_data {
    /// < Mask of categories for that rule.
    pub category_mask: u32,
    /// < Priority for that rule.
    pub priority: i32,
    /// < Associated with the rule user data.
    pub userdata: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_rule_data() {
    assert_eq!(::std::mem::size_of::<rte_acl_rule_data>() , 12usize , concat !
               ( "Size of: " , stringify ! ( rte_acl_rule_data ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_rule_data>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_acl_rule_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . category_mask as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_rule_data ) ,
                "::" , stringify ! ( category_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . priority as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_rule_data ) ,
                "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . userdata as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_rule_data ) ,
                "::" , stringify ! ( userdata ) ));
}
impl Clone for rte_acl_rule_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_rule {
    pub data: rte_acl_rule_data,
    pub field: __IncompleteArrayField<rte_acl_field>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_acl_rule() {
    assert_eq!(::std::mem::size_of::<rte_acl_rule>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_acl_rule ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_rule>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_acl_rule ) ));
}
impl Clone for rte_acl_rule {
    fn clone(&self) -> Self { *self }
}
/// Parameters used when creating the ACL context.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_param {
    /// < Name of the ACL context.
    pub name: *const ::std::os::raw::c_char,
    /// < Socket ID to allocate memory for.
    pub socket_id: ::std::os::raw::c_int,
    /// < Size of each rule.
    pub rule_size: u32,
    /// < Maximum number of rules.
    pub max_rule_num: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_param() {
    assert_eq!(::std::mem::size_of::<rte_acl_param>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_acl_param ) ));
    assert_eq! (::std::mem::align_of::<rte_acl_param>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_acl_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_param ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . socket_id as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_param ) , "::"
                , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . rule_size as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_param ) , "::"
                , stringify ! ( rule_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . max_rule_num as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_acl_param ) , "::"
                , stringify ! ( max_rule_num ) ));
}
impl Clone for rte_acl_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_ctx {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a new ACL context.
///
/// @param param
/// Parameters used to create and initialise the ACL context.
/// @return
/// Pointer to ACL context structure that is used in future ACL
/// operations, or NULL on error, with error code set in rte_errno.
/// Possible rte_errno errors include:
/// - EINVAL - invalid parameter passed to function
    pub fn rte_acl_create(param: *const rte_acl_param) -> *mut rte_acl_ctx;
}
extern "C" {
    /// Find an existing ACL context object and return a pointer to it.
///
/// @param name
/// Name of the ACL context as passed to rte_acl_create()
/// @return
/// Pointer to ACL context or NULL if object not found
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - value not available for return
    pub fn rte_acl_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_acl_ctx;
}
extern "C" {
    /// De-allocate all memory used by ACL context.
///
/// @param ctx
/// ACL context to free
    pub fn rte_acl_free(ctx: *mut rte_acl_ctx);
}
extern "C" {
    /// Add rules to an existing ACL context.
/// This function is not multi-thread safe.
///
/// @param ctx
/// ACL context to add patterns to.
/// @param rules
/// Array of rules to add to the ACL context.
/// Note that all fields in rte_acl_rule structures are expected
/// to be in host byte order.
/// Each rule expected to be in the same format and not exceed size
/// specified at ACL context creation time.
/// @param num
/// Number of elements in the input array of rules.
/// @return
/// - -ENOMEM if there is no space in the ACL context for these rules.
/// - -EINVAL if the parameters are invalid.
/// - Zero if operation completed successfully.
    pub fn rte_acl_add_rules(ctx: *mut rte_acl_ctx,
                             rules: *const rte_acl_rule, num: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete all rules from the ACL context.
/// This function is not multi-thread safe.
/// Note that internal run-time structures are not affected.
///
/// @param ctx
/// ACL context to delete rules from.
    pub fn rte_acl_reset_rules(ctx: *mut rte_acl_ctx);
}
extern "C" {
    /// Analyze set of rules and build required internal run-time structures.
/// This function is not multi-thread safe.
///
/// @param ctx
/// ACL context to build.
/// @param cfg
/// Pointer to struct rte_acl_config - defines build parameters.
/// @return
/// - -ENOMEM if couldn't allocate enough memory.
/// - -EINVAL if the parameters are invalid.
/// - Negative error code if operation failed.
/// - Zero if operation completed successfully.
    pub fn rte_acl_build(ctx: *mut rte_acl_ctx, cfg: *const rte_acl_config)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete all rules from the ACL context and
/// destroy all internal run-time structures.
/// This function is not multi-thread safe.
///
/// @param ctx
/// ACL context to reset.
    pub fn rte_acl_reset(ctx: *mut rte_acl_ctx);
}
#[repr(u32)]
/// Available implementations of ACL classify.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_acl_classify_alg {
    RTE_ACL_CLASSIFY_DEFAULT = 0,
    RTE_ACL_CLASSIFY_SCALAR = 1,
    RTE_ACL_CLASSIFY_SSE = 2,
    RTE_ACL_CLASSIFY_AVX2 = 3,
    RTE_ACL_CLASSIFY_NEON = 4,
    RTE_ACL_CLASSIFY_ALTIVEC = 5,
    RTE_ACL_CLASSIFY_NUM = 6,
}
extern "C" {
    /// Perform search for a matching ACL rule for each input data buffer.
/// Each input data buffer can have up to *categories* matches.
/// That implies that results array should be big enough to hold
/// (categories * num) elements.
/// Also categories parameter should be either one or multiple of
/// RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES.
/// If more than one rule is applicable for given input buffer and
/// given category, then rule with highest priority will be returned as a match.
/// Note, that it is a caller's responsibility to ensure that input parameters
/// are valid and point to correct memory locations.
///
/// @param ctx
/// ACL context to search with.
/// @param data
/// Array of pointers to input data buffers to perform search.
/// Note that all fields in input data buffers supposed to be in network
/// byte order (MSB).
/// @param results
/// Array of search results, *categories* results per each input data buffer.
/// @param num
/// Number of elements in the input data buffers array.
/// @param categories
/// Number of maximum possible matches for each input buffer, one possible
/// match per category.
/// @return
/// zero on successful completion.
/// -EINVAL for incorrect arguments.
    pub fn rte_acl_classify(ctx: *const rte_acl_ctx, data: *mut *const u8,
                            results: *mut u32, num: u32, categories: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Perform search using specified algorithm for a matching ACL rule for
/// each input data buffer.
/// Each input data buffer can have up to *categories* matches.
/// That implies that results array should be big enough to hold
/// (categories * num) elements.
/// Also categories parameter should be either one or multiple of
/// RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES.
/// If more than one rule is applicable for given input buffer and
/// given category, then rule with highest priority will be returned as a match.
/// Note, that it is a caller's responsibility to ensure that input parameters
/// are valid and point to correct memory locations.
///
/// @param ctx
/// ACL context to search with.
/// @param data
/// Array of pointers to input data buffers to perform search.
/// Note that all fields in input data buffers supposed to be in network
/// byte order (MSB).
/// @param results
/// Array of search results, *categories* results per each input data buffer.
/// @param num
/// Number of elements in the input data buffers array.
/// @param categories
/// Number of maximum possible matches for each input buffer, one possible
/// match per category.
/// @param alg
/// Algorithm to be used for the search.
/// It is the caller responsibility to ensure that the value refers to the
/// existing algorithm, and that it could be run on the given CPU.
/// @return
/// zero on successful completion.
/// -EINVAL for incorrect arguments.
    pub fn rte_acl_classify_alg(ctx: *const rte_acl_ctx, data: *mut *const u8,
                                results: *mut u32, num: u32, categories: u32,
                                alg: rte_acl_classify_alg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_acl_set_ctx_classify(ctx: *mut rte_acl_ctx,
                                    alg: rte_acl_classify_alg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump an ACL context structure to the console.
///
/// @param ctx
/// ACL context to dump.
    pub fn rte_acl_dump(ctx: *const rte_acl_ctx);
}
extern "C" {
    /// Dump all ACL context structures to the console.
    pub fn rte_acl_list_dump();
}
/// Signature of callback back function called when an alarm goes off.
pub type rte_eal_alarm_callback =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Function to set a callback to be triggered when us microseconds
/// have expired. Accuracy of timing to the microsecond is not guaranteed. The
/// alarm function will not be called *before* the requested time, but may
/// be called a short period of time afterwards.
/// The alarm handler will be called only once. There is no need to call
/// "rte_eal_alarm_cancel" from within the callback function.
///
/// @param us
/// The time in microseconds before the callback is called
/// @param cb
/// The function to be called when the alarm expires
/// @param cb_arg
/// Pointer parameter to be passed to the callback function
///
/// @return
/// On success, zero.
/// On failure, a negative error number
    pub fn rte_eal_alarm_set(us: u64, cb: rte_eal_alarm_callback,
                             cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Function to cancel an alarm callback which has been registered before. If
/// used outside alarm callback it wait for all callbacks to finish execution.
///
/// @param cb_fn
/// alarm callback
/// @param cb_arg
/// Pointer parameter to be passed to the callback function. To remove all
/// copies of a given callback function, irrespective of parameter, (void *)-1
/// can be used here.
///
/// @return
/// - value greater than 0 and rte_errno not changed - returned value is
/// the number of canceled alarm callback functions
/// - value greater or equal 0 and rte_errno set to EINPROGRESS, at least one
/// alarm could not be canceled because cancellation was requested from alarm
/// callback context. Returned value is the number of successfully canceled
/// alarm callbacks
/// -  0 and rte_errno set to ENOENT - no alarm found
/// - -1 and rte_errno set to EINVAL - invalid parameter (NULL callback)
    pub fn rte_eal_alarm_cancel(cb_fn: rte_eal_alarm_callback,
                                cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find best rational approximation
///
/// @param alpha
/// Rational number to approximate
/// @param d
/// Precision for the rational approximation
/// @param p
/// Pointer to pre-allocated space where the numerator of the rational
/// approximation will be stored when operation is successful
/// @param q
/// Pointer to pre-allocated space where the denominator of the rational
/// approximation will be stored when operation is successful
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_approx(alpha: f64, d: f64, p: *mut u32, q: *mut u32)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_ring_queue_behavior {
    RTE_RING_QUEUE_FIXED = 0,
    RTE_RING_QUEUE_VARIABLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ring_headtail {
    /// < Prod/consumer head.
    pub head: u32,
    /// < Prod/consumer tail.
    pub tail: u32,
    /// < True if single prod/cons
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(::std::mem::size_of::<rte_ring_headtail>() , 12usize , concat !
               ( "Size of: " , stringify ! ( rte_ring_headtail ) ));
    assert_eq! (::std::mem::align_of::<rte_ring_headtail>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_ring_headtail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_headtail ) ) . head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring_headtail ) ,
                "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_headtail ) ) . tail as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring_headtail ) ,
                "::" , stringify ! ( tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_headtail ) ) . single as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring_headtail ) ,
                "::" , stringify ! ( single ) ));
}
impl Clone for rte_ring_headtail {
    fn clone(&self) -> Self { *self }
}
/// An RTE ring structure.
///
/// The producer and the consumer have a head and a tail index. The particularity
/// of these index is that they are not between 0 and size(ring). These indexes
/// are between 0 and 2^32, and we mask their value when we access the ring[]
/// field. Thanks to this assumption, we can do subtractions between 2 index
/// values in a modulo-32bit base: that's why the overflow of the indexes is not
/// a problem.
#[repr(C)]
#[derive(Copy)]
pub struct rte_ring {
    /// < Name of the ring.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Flags supplied at creation.
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    /// < Size of ring.
    pub size: u32,
    /// < Mask (size-1) of ring.
    pub mask: u32,
    /// < Usable size of ring
    pub capacity: u32,
    pub __bindgen_padding_0: [u32; 17usize],
    /// Ring producer status.
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_1: [u32; 29usize],
    /// Ring consumer status.
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_2: [u32; 29usize],
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(::std::mem::size_of::<rte_ring>() , 384usize , concat ! (
               "Size of: " , stringify ! ( rte_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . memzone as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( memzone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . size as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . mask as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . capacity as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . prod as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( prod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring ) ) . cons as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ring ) , "::" ,
                stringify ! ( cons ) ));
}
impl Clone for rte_ring {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Calculate the memory size needed for a ring
///
/// This function returns the number of bytes needed for a ring, given
/// the number of elements in it. This value is the sum of the size of
/// the structure rte_ring and the size of the memory needed by the
/// objects pointers. The value is aligned to a cache line size.
///
/// @param count
/// The number of elements in the ring (must be a power of 2).
/// @return
/// - The memory size needed for the ring on success.
/// - -EINVAL if count is not a power of 2.
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    /// Initialize a ring structure.
///
/// Initialize a ring structure in memory pointed by "r". The size of the
/// memory area must be large enough to store the ring structure and the
/// object table. It is advised to use rte_ring_get_memsize() to get the
/// appropriate size.
///
/// The ring size is set to *count*, which must be a power of two. Water
/// marking is disabled by default. The real usable ring size is
/// *count-1* instead of *count* to differentiate a free ring from an
/// empty ring.
///
/// The ring is not added in RTE_TAILQ_RING global list. Indeed, the
/// memory given by the caller may not be shareable among dpdk
/// processes.
///
/// @param r
/// The pointer to the ring structure followed by the objects table.
/// @param name
/// The name of the ring.
/// @param count
/// The number of elements in the ring (must be a power of 2).
/// @param flags
/// An OR of the following:
/// - RING_F_SP_ENQ: If this flag is set, the default behavior when
/// using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
/// is "single-producer". Otherwise, it is "multi-producers".
/// - RING_F_SC_DEQ: If this flag is set, the default behavior when
/// using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
/// is "single-consumer". Otherwise, it is "multi-consumers".
/// @return
/// 0 on success, or a negative value on error.
    pub fn rte_ring_init(r: *mut rte_ring,
                         name: *const ::std::os::raw::c_char,
                         count: ::std::os::raw::c_uint,
                         flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a new ring named *name* in memory.
///
/// This function uses ``memzone_reserve()`` to allocate memory. Then it
/// calls rte_ring_init() to initialize an empty ring.
///
/// The new ring size is set to *count*, which must be a power of
/// two. Water marking is disabled by default. The real usable ring size
/// is *count-1* instead of *count* to differentiate a free ring from an
/// empty ring.
///
/// The ring is added in RTE_TAILQ_RING list.
///
/// @param name
/// The name of the ring.
/// @param count
/// The size of the ring (must be a power of 2).
/// @param socket_id
/// The *socket_id* argument is the socket identifier in case of
/// NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// An OR of the following:
/// - RING_F_SP_ENQ: If this flag is set, the default behavior when
/// using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
/// is "single-producer". Otherwise, it is "multi-producers".
/// - RING_F_SC_DEQ: If this flag is set, the default behavior when
/// using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
/// is "single-consumer". Otherwise, it is "multi-consumers".
/// @return
/// On success, the pointer to the new allocated ring. NULL on error with
/// rte_errno set appropriately. Possible errno values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - count provided is not a power of 2
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_ring_create(name: *const ::std::os::raw::c_char,
                           count: ::std::os::raw::c_uint,
                           socket_id: ::std::os::raw::c_int,
                           flags: ::std::os::raw::c_uint) -> *mut rte_ring;
}
extern "C" {
    /// De-allocate all memory used by the ring.
///
/// @param r
/// Ring to free
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    /// Dump the status of the ring to a file.
///
/// @param f
/// A pointer to a file for output
/// @param r
/// A pointer to the ring structure.
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    /// Dump the status of all rings on the console
///
/// @param f
/// A pointer to a file for output
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    /// Search a ring from its name
///
/// @param name
/// The name of the ring.
/// @return
/// The pointer to the ring matching the name, or NULL if not found,
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_ring;
}
/// A structure that stores a per-core object cache.
#[repr(C)]
pub struct rte_mempool_cache {
    /// < Size of the cache
    pub size: u32,
    /// < Threshold before we flush excess elements
    pub flushthresh: u32,
    /// < Current cache count
    pub len: u32,
    /// < Cache objects
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(::std::mem::size_of::<rte_mempool_cache>() , 12352usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mempool_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_cache ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . flushthresh as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_cache ) ,
                "::" , stringify ! ( flushthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_cache ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . objs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_cache ) ,
                "::" , stringify ! ( objs ) ));
}
/// A structure that stores the size of mempool elements.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objsz {
    /// < Size of an element.
    pub elt_size: u32,
    /// < Size of header (before elt).
    pub header_size: u32,
    /// < Size of trailer (after elt).
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objsz>() , 16usize , concat !
               ( "Size of: " , stringify ! ( rte_mempool_objsz ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool_objsz>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_mempool_objsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . elt_size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objsz ) ,
                "::" , stringify ! ( elt_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . header_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objsz ) ,
                "::" , stringify ! ( header_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . trailer_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objsz ) ,
                "::" , stringify ! ( trailer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . total_size as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objsz ) ,
                "::" , stringify ! ( total_size ) ));
}
impl Clone for rte_mempool_objsz {
    fn clone(&self) -> Self { *self }
}
/// Mempool object header structure
///
/// Each object stored in mempools are prefixed by this header structure,
/// it allows to retrieve the mempool pointer from the object and to
/// iterate on all objects attached to a mempool. When debug is enabled,
/// a cookie is also added in this structure preventing corruptions and
/// double-frees.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr {
    /// < Next in list.
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    /// < The mempool owning the object.
    pub mp: *mut rte_mempool,
    /// < Physical address of the object.
    pub physaddr: phys_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_mempool_objhdr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mempool_objhdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mempool_objhdr__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for rte_mempool_objhdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( rte_mempool_objhdr ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_mempool_objhdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objhdr ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . mp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objhdr ) ,
                "::" , stringify ! ( mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . physaddr as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objhdr ) ,
                "::" , stringify ! ( physaddr ) ));
}
impl Clone for rte_mempool_objhdr {
    fn clone(&self) -> Self { *self }
}
/// A list of object headers type
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_mempool_objhdr_list ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mempool_objhdr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_list ) ) . stqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objhdr_list
                ) , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_list ) ) . stqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_objhdr_list
                ) , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for rte_mempool_objhdr_list {
    fn clone(&self) -> Self { *self }
}
/// A list of memory where objects are stored
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_mempool_memhdr_list ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mempool_memhdr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr_list ) ) . stqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr_list
                ) , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr_list ) ) . stqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr_list
                ) , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for rte_mempool_memhdr_list {
    fn clone(&self) -> Self { *self }
}
/// Callback used to free a memory chunk
pub type rte_mempool_memchunk_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(memhdr:
                                                   *mut rte_mempool_memhdr,
                                               opaque:
                                                   *mut ::std::os::raw::c_void)>;
/// Mempool objects memory header structure
///
/// The memory chunks where objects are stored. Each chunk is virtually
/// and physically contiguous.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr {
    /// < Next in list.
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    /// < The mempool owning the chunk
    pub mp: *mut rte_mempool,
    /// < Virtual address of the chunk
    pub addr: *mut ::std::os::raw::c_void,
    /// < Physical address of the chunk
    pub phys_addr: phys_addr_t,
    /// < length of the chunk
    pub len: usize,
    /// < Free callback
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    /// < Argument passed to the free callback
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_mempool_memhdr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mempool_memhdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mempool_memhdr__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for rte_mempool_memhdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( rte_mempool_memhdr ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_mempool_memhdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . mp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . addr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . phys_addr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . len as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . free_cb as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( free_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr ) ) . opaque as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_memhdr ) ,
                "::" , stringify ! ( opaque ) ));
}
impl Clone for rte_mempool_memhdr {
    fn clone(&self) -> Self { *self }
}
/// The RTE mempool structure.
#[repr(C)]
#[derive(Copy)]
pub struct rte_mempool {
    /// < Name of mempool.
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    /// < optional args for ops alloc.
    pub pool_config: *mut ::std::os::raw::c_void,
    /// < Memzone where pool is alloc'd.
    pub mz: *const rte_memzone,
    /// < Flags of the mempool.
    pub flags: ::std::os::raw::c_int,
    /// < Socket id passed at create.
    pub socket_id: ::std::os::raw::c_int,
    /// < Max size of the mempool.
    pub size: u32,
    pub cache_size: u32,
    /// < Size of an element.
    pub elt_size: u32,
    /// < Size of header (before elt).
    pub header_size: u32,
    /// < Size of trailer (after elt).
    pub trailer_size: u32,
    /// < Size of private data.
    pub private_data_size: ::std::os::raw::c_uint,
    /// Index into rte_mempool_ops_table array of mempool ops
    /// structs, which contain callback function pointers.
    /// We're using an index here rather than pointers to the callbacks
    /// to facilitate any secondary processes that may want to use
    /// this mempool.
    pub ops_index: i32,
    /// < Per-lcore local cache
    pub local_cache: *mut rte_mempool_cache,
    /// < Number of populated objects.
    pub populated_size: u32,
    /// < List of objects in pool
    pub elt_list: rte_mempool_objhdr_list,
    /// < Number of memory chunks
    pub nb_mem_chunks: u32,
    /// < List of memory chunks
    pub mem_list: rte_mempool_memhdr_list,
    pub __bindgen_padding_0: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool__bindgen_ty_1 {
    /// < Ring or pool to store objects.
    pub pool_data: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /// < External mempool identifier.
    pub pool_id: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_mempool__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_mempool__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mempool__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool__bindgen_ty_1 ) ) . pool_data
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mempool__bindgen_ty_1 ) , "::" , stringify ! ( pool_data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool__bindgen_ty_1 ) ) . pool_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mempool__bindgen_ty_1 ) , "::" , stringify ! ( pool_id )
                ));
}
impl Clone for rte_mempool__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(::std::mem::size_of::<rte_mempool>() , 192usize , concat ! (
               "Size of: " , stringify ! ( rte_mempool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . pool_config as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( pool_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . mz as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( mz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . socket_id as * const _
                as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . size as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . cache_size as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . elt_size as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( elt_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . header_size as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( header_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . trailer_size as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( trailer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . private_data_size as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( private_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . ops_index as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( ops_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . local_cache as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( local_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . populated_size as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( populated_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . elt_list as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( elt_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . nb_mem_chunks as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( nb_mem_chunks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool ) ) . mem_list as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool ) , "::" ,
                stringify ! ( mem_list ) ));
}
impl Clone for rte_mempool {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    /// @internal Check and update cookies or panic.
///
/// @param mp
/// Pointer to the memory pool.
/// @param obj_table_const
/// Pointer to a table of void * pointers (objects).
/// @param n
/// Index of object in object table.
/// @param free
/// - 0: object is supposed to be allocated, mark it as free
/// - 1: object is supposed to be free, mark it as allocated
/// - 2: just check that cookie is valid (free or allocated)
    pub fn rte_mempool_check_cookies(mp: *const rte_mempool,
                                     obj_table_const:
                                         *const *const ::std::os::raw::c_void,
                                     n: ::std::os::raw::c_uint,
                                     free: ::std::os::raw::c_int);
}
/// Prototype for implementation specific data provisioning function.
///
/// The function should provide the implementation specific memory for
/// use by the other mempool ops functions in a given mempool ops struct.
/// E.g. the default ops provides an instance of the rte_ring for this purpose.
/// it will most likely point to a different type of data structure, and
/// will be transparent to the application programmer.
/// This function should set mp->pool_data.
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)
                              -> ::std::os::raw::c_int>;
/// Free the opaque private data pointed to by mp->pool_data pointer.
pub type rte_mempool_free_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
/// Enqueue an object into the external pool.
pub type rte_mempool_enqueue_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool,
                                               obj_table:
                                                   *const *const ::std::os::raw::c_void,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/// Dequeue an object from the external pool.
pub type rte_mempool_dequeue_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool,
                                               obj_table:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/// Return the number of available objects in the external pool.
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool)
                              -> ::std::os::raw::c_uint>;
/// Structure defining mempool operations structure
#[repr(C)]
#[derive(Copy)]
pub struct rte_mempool_ops {
    /// < Name of mempool ops struct.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Allocate private data.
    pub alloc: rte_mempool_alloc_t,
    /// < Free the external pool.
    pub free: rte_mempool_free_t,
    /// < Enqueue an object.
    pub enqueue: rte_mempool_enqueue_t,
    /// < Dequeue an object.
    pub dequeue: rte_mempool_dequeue_t,
    /// < Get qty of available objs.
    pub get_count: rte_mempool_get_count,
    pub __bindgen_padding_0: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(::std::mem::size_of::<rte_mempool_ops>() , 128usize , concat !
               ( "Size of: " , stringify ! ( rte_mempool_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . alloc as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . free as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . enqueue as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . dequeue as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( dequeue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . get_count as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops ) ,
                "::" , stringify ! ( get_count ) ));
}
impl Clone for rte_mempool_ops {
    fn clone(&self) -> Self { *self }
}
/// Structure storing the table of registered ops structs, each of which contain
/// the function pointers for the mempool ops functions.
/// Each process has its own storage for this ops struct array so that
/// the mempools can be shared across primary and secondary processes.
/// The indices used to access the array are valid across processes, whereas
/// any function pointers stored directly in the mempool struct would not be.
/// This results in us simply having "ops_index" in the mempool struct.
#[repr(C)]
#[derive(Copy)]
pub struct rte_mempool_ops_table {
    /// < Spinlock for add/delete.
    pub sl: rte_spinlock_t,
    /// < Number of used ops structs in the table.
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    /// Storage for all possible ops structs.
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(::std::mem::size_of::<rte_mempool_ops_table>() , 2112usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mempool_ops_table )
               ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . sl as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops_table )
                , "::" , stringify ! ( sl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . num_ops as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops_table )
                , "::" , stringify ! ( num_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . ops as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mempool_ops_table )
                , "::" , stringify ! ( ops ) ));
}
impl Clone for rte_mempool_ops_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_mempool_ops_table"]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    /// @internal Wrapper for mempool_ops alloc callback.
///
/// @param mp
/// Pointer to the memory pool.
/// @return
/// - 0: Success; successfully allocated mempool pool_data.
/// - <0: Error; code of alloc function.
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal wrapper for mempool_ops get_count callback.
///
/// @param mp
/// Pointer to the memory pool.
/// @return
/// The number of available objects in the external pool.
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// @internal wrapper for mempool_ops free callback.
///
/// @param mp
/// Pointer to the memory pool.
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    /// Set the ops of a mempool.
///
/// This can only be done on a mempool that is not populated, i.e. just after
/// a call to rte_mempool_create_empty().
///
/// @param mp
/// Pointer to the memory pool.
/// @param name
/// Name of the ops structure to use for this mempool.
/// @param pool_config
/// Opaque data that can be passed by the application to the ops functions.
/// @return
/// - 0: Success; the mempool is now using the requested ops functions.
/// - -EINVAL - Invalid ops struct name provided.
/// - -EEXIST - mempool already has an ops struct assigned.
    pub fn rte_mempool_set_ops_byname(mp: *mut rte_mempool,
                                      name: *const ::std::os::raw::c_char,
                                      pool_config:
                                          *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register mempool operations.
///
/// @param ops
/// Pointer to an ops structure to register.
/// @return
/// - >=0: Success; return the index of the ops struct in the table.
/// - -EINVAL - some missing callbacks while registering ops struct.
/// - -ENOSPC - the maximum number of ops structs has been reached.
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops)
     -> ::std::os::raw::c_int;
}
/// An object callback function for mempool.
///
/// Used by rte_mempool_create() and rte_mempool_obj_iter().
pub type rte_mempool_obj_cb_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool,
                                               opaque:
                                                   *mut ::std::os::raw::c_void,
                                               obj:
                                                   *mut ::std::os::raw::c_void,
                                               obj_idx:
                                                   ::std::os::raw::c_uint)>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
/// A memory callback function for mempool.
///
/// Used by rte_mempool_mem_iter().
pub type rte_mempool_mem_cb_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool,
                                               opaque:
                                                   *mut ::std::os::raw::c_void,
                                               memhdr:
                                                   *mut rte_mempool_memhdr,
                                               mem_idx:
                                                   ::std::os::raw::c_uint)>;
/// A mempool constructor callback function.
///
/// Arguments are the mempool and the opaque pointer given by the user in
/// rte_mempool_create().
pub type rte_mempool_ctor_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_mempool,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Create a new mempool named *name* in memory.
///
/// This function uses ``rte_memzone_reserve()`` to allocate memory. The
/// pool contains n elements of elt_size. Its size is set to n.
///
/// @param name
/// The name of the mempool.
/// @param n
/// The number of elements in the mempool. The optimum size (in terms of
/// memory usage) for a mempool is when n is a power of two minus one:
/// n = (2^q - 1).
/// @param elt_size
/// The size of each element.
/// @param cache_size
/// If cache_size is non-zero, the rte_mempool library will try to
/// limit the accesses to the common lockless pool, by maintaining a
/// per-lcore object cache. This argument must be lower or equal to
/// CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose
/// cache_size to have "n modulo cache_size == 0": if this is
/// not the case, some elements will always stay in the pool and will
/// never be used. The access to the per-lcore table is of course
/// faster than the multi-producer/consumer pool. The cache can be
/// disabled if the cache_size argument is set to 0; it can be useful to
/// avoid losing objects in cache.
/// @param private_data_size
/// The size of the private data appended after the mempool
/// structure. This is useful for storing some private data after the
/// mempool structure, as is done for rte_mbuf_pool for example.
/// @param mp_init
/// A function pointer that is called for initialization of the pool,
/// before object initialization. The user can initialize the private
/// data in this function if needed. This parameter can be NULL if
/// not needed.
/// @param mp_init_arg
/// An opaque pointer to data that can be used in the mempool
/// constructor function.
/// @param obj_init
/// A function pointer that is called for each object at
/// initialization of the pool. The user can set some meta data in
/// objects if needed. This parameter can be NULL if not needed.
/// The obj_init() function takes the mempool pointer, the init_arg,
/// the object pointer and the object number as parameters.
/// @param obj_init_arg
/// An opaque pointer to data that can be used as an argument for
/// each call to the object constructor function.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in the case of
/// NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// The *flags* arguments is an OR of following flags:
/// - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread
/// between channels in RAM: the pool allocator will add padding
/// between objects depending on the hardware configuration. See
/// Memory alignment constraints for details. If this flag is set,
/// the allocator will just align them to a cache line.
/// - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are
/// cache-aligned. This flag removes this constraint, and no
/// padding will be present between objects. This flag implies
/// MEMPOOL_F_NO_SPREAD.
/// - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior
/// when using rte_mempool_put() or rte_mempool_put_bulk() is
/// "single-producer". Otherwise, it is "multi-producers".
/// - MEMPOOL_F_SC_GET: If this flag is set, the default behavior
/// when using rte_mempool_get() or rte_mempool_get_bulk() is
/// "single-consumer". Otherwise, it is "multi-consumers".
/// - MEMPOOL_F_NO_PHYS_CONTIG: If set, allocated objects won't
/// necessarily be contiguous in physical memory.
/// @return
/// The pointer to the new allocated mempool, on success. NULL on error
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - cache size provided is too large
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_mempool_create(name: *const ::std::os::raw::c_char,
                              n: ::std::os::raw::c_uint,
                              elt_size: ::std::os::raw::c_uint,
                              cache_size: ::std::os::raw::c_uint,
                              private_data_size: ::std::os::raw::c_uint,
                              mp_init: rte_mempool_ctor_t,
                              mp_init_arg: *mut ::std::os::raw::c_void,
                              obj_init: rte_mempool_obj_cb_t,
                              obj_init_arg: *mut ::std::os::raw::c_void,
                              socket_id: ::std::os::raw::c_int,
                              flags: ::std::os::raw::c_uint)
     -> *mut rte_mempool;
}
extern "C" {
    /// Create a new mempool named *name* in memory.
///
/// The pool contains n elements of elt_size. Its size is set to n.
/// This function uses ``memzone_reserve()`` to allocate the mempool header
/// (and the objects if vaddr is NULL).
/// Depending on the input parameters, mempool elements can be either allocated
/// together with the mempool header, or an externally provided memory buffer
/// could be used to store mempool objects. In later case, that external
/// memory buffer can consist of set of disjoint physical pages.
///
/// @param name
/// The name of the mempool.
/// @param n
/// The number of elements in the mempool. The optimum size (in terms of
/// memory usage) for a mempool is when n is a power of two minus one:
/// n = (2^q - 1).
/// @param elt_size
/// The size of each element.
/// @param cache_size
/// Size of the cache. See rte_mempool_create() for details.
/// @param private_data_size
/// The size of the private data appended after the mempool
/// structure. This is useful for storing some private data after the
/// mempool structure, as is done for rte_mbuf_pool for example.
/// @param mp_init
/// A function pointer that is called for initialization of the pool,
/// before object initialization. The user can initialize the private
/// data in this function if needed. This parameter can be NULL if
/// not needed.
/// @param mp_init_arg
/// An opaque pointer to data that can be used in the mempool
/// constructor function.
/// @param obj_init
/// A function called for each object at initialization of the pool.
/// See rte_mempool_create() for details.
/// @param obj_init_arg
/// An opaque pointer passed to the object constructor function.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in the case of
/// NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// Flags controlling the behavior of the mempool. See
/// rte_mempool_create() for details.
/// @param vaddr
/// Virtual address of the externally allocated memory buffer.
/// Will be used to store mempool objects.
/// @param paddr
/// Array of physical addresses of the pages that comprises given memory
/// buffer.
/// @param pg_num
/// Number of elements in the paddr array.
/// @param pg_shift
/// LOG2 of the physical pages size.
/// @return
/// The pointer to the new allocated mempool, on success. NULL on error
/// with rte_errno set appropriately. See rte_mempool_create() for details.
    pub fn rte_mempool_xmem_create(name: *const ::std::os::raw::c_char,
                                   n: ::std::os::raw::c_uint,
                                   elt_size: ::std::os::raw::c_uint,
                                   cache_size: ::std::os::raw::c_uint,
                                   private_data_size: ::std::os::raw::c_uint,
                                   mp_init: rte_mempool_ctor_t,
                                   mp_init_arg: *mut ::std::os::raw::c_void,
                                   obj_init: rte_mempool_obj_cb_t,
                                   obj_init_arg: *mut ::std::os::raw::c_void,
                                   socket_id: ::std::os::raw::c_int,
                                   flags: ::std::os::raw::c_uint,
                                   vaddr: *mut ::std::os::raw::c_void,
                                   paddr: *const phys_addr_t, pg_num: u32,
                                   pg_shift: u32) -> *mut rte_mempool;
}
extern "C" {
    /// Create an empty mempool
///
/// The mempool is allocated and initialized, but it is not populated: no
/// memory is allocated for the mempool elements. The user has to call
/// rte_mempool_populate_*() to add memory chunks to the pool. Once
/// populated, the user may also want to initialize each object with
/// rte_mempool_obj_iter().
///
/// @param name
/// The name of the mempool.
/// @param n
/// The maximum number of elements that can be added in the mempool.
/// The optimum size (in terms of memory usage) for a mempool is when n
/// is a power of two minus one: n = (2^q - 1).
/// @param elt_size
/// The size of each element.
/// @param cache_size
/// Size of the cache. See rte_mempool_create() for details.
/// @param private_data_size
/// The size of the private data appended after the mempool
/// structure. This is useful for storing some private data after the
/// mempool structure, as is done for rte_mbuf_pool for example.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in the case of
/// NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
/// constraint for the reserved zone.
/// @param flags
/// Flags controlling the behavior of the mempool. See
/// rte_mempool_create() for details.
/// @return
/// The pointer to the new allocated mempool, on success. NULL on error
/// with rte_errno set appropriately. See rte_mempool_create() for details.
    pub fn rte_mempool_create_empty(name: *const ::std::os::raw::c_char,
                                    n: ::std::os::raw::c_uint,
                                    elt_size: ::std::os::raw::c_uint,
                                    cache_size: ::std::os::raw::c_uint,
                                    private_data_size: ::std::os::raw::c_uint,
                                    socket_id: ::std::os::raw::c_int,
                                    flags: ::std::os::raw::c_uint)
     -> *mut rte_mempool;
}
extern "C" {
    /// Free a mempool
///
/// Unlink the mempool from global list, free the memory chunks, and all
/// memory referenced by the mempool. The objects must not be used by
/// other cores as they will be freed.
///
/// @param mp
/// A pointer to the mempool structure.
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    /// Add physically contiguous memory for objects in the pool at init
///
/// Add a virtually and physically contiguous memory chunk in the pool
/// where objects can be instantiated.
///
/// If the given physical address is unknown (paddr = RTE_BAD_PHYS_ADDR),
/// the chunk doesn't need to be physically contiguous (only virtually),
/// and allocated objects may span two pages.
///
/// @param mp
/// A pointer to the mempool structure.
/// @param vaddr
/// The virtual address of memory that should be used to store objects.
/// @param paddr
/// The physical address
/// @param len
/// The length of memory in bytes.
/// @param free_cb
/// The callback used to free this chunk when destroying the mempool.
/// @param opaque
/// An opaque argument passed to free_cb.
/// @return
/// The number of objects added on success.
/// On error, the chunk is not added in the memory list of the
/// mempool and a negative errno is returned.
    pub fn rte_mempool_populate_phys(mp: *mut rte_mempool,
                                     vaddr: *mut ::std::os::raw::c_char,
                                     paddr: phys_addr_t, len: usize,
                                     free_cb: rte_mempool_memchunk_free_cb_t,
                                     opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add physical memory for objects in the pool at init
///
/// Add a virtually contiguous memory chunk in the pool where objects can
/// be instantiated. The physical addresses corresponding to the virtual
/// area are described in paddr[], pg_num, pg_shift.
///
/// @param mp
/// A pointer to the mempool structure.
/// @param vaddr
/// The virtual address of memory that should be used to store objects.
/// @param paddr
/// An array of physical addresses of each page composing the virtual
/// area.
/// @param pg_num
/// Number of elements in the paddr array.
/// @param pg_shift
/// LOG2 of the physical pages size.
/// @param free_cb
/// The callback used to free this chunk when destroying the mempool.
/// @param opaque
/// An opaque argument passed to free_cb.
/// @return
/// The number of objects added on success.
/// On error, the chunks are not added in the memory list of the
/// mempool and a negative errno is returned.
    pub fn rte_mempool_populate_phys_tab(mp: *mut rte_mempool,
                                         vaddr: *mut ::std::os::raw::c_char,
                                         paddr: *const phys_addr_t,
                                         pg_num: u32, pg_shift: u32,
                                         free_cb:
                                             rte_mempool_memchunk_free_cb_t,
                                         opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add virtually contiguous memory for objects in the pool at init
///
/// Add a virtually contiguous memory chunk in the pool where objects can
/// be instantiated.
///
/// @param mp
/// A pointer to the mempool structure.
/// @param addr
/// The virtual address of memory that should be used to store objects.
/// Must be page-aligned.
/// @param len
/// The length of memory in bytes. Must be page-aligned.
/// @param pg_sz
/// The size of memory pages in this virtual area.
/// @param free_cb
/// The callback used to free this chunk when destroying the mempool.
/// @param opaque
/// An opaque argument passed to free_cb.
/// @return
/// The number of objects added on success.
/// On error, the chunk is not added in the memory list of the
/// mempool and a negative errno is returned.
    pub fn rte_mempool_populate_virt(mp: *mut rte_mempool,
                                     addr: *mut ::std::os::raw::c_char,
                                     len: usize, pg_sz: usize,
                                     free_cb: rte_mempool_memchunk_free_cb_t,
                                     opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add memory for objects in the pool at init
///
/// This is the default function used by rte_mempool_create() to populate
/// the mempool. It adds memory allocated using rte_memzone_reserve().
///
/// @param mp
/// A pointer to the mempool structure.
/// @return
/// The number of objects added on success.
/// On error, the chunk is not added in the memory list of the
/// mempool and a negative errno is returned.
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add memory from anonymous mapping for objects in the pool at init
///
/// This function mmap an anonymous memory zone that is locked in
/// memory to store the objects of the mempool.
///
/// @param mp
/// A pointer to the mempool structure.
/// @return
/// The number of objects added on success.
/// On error, the chunk is not added in the memory list of the
/// mempool and a negative errno is returned.
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Call a function for each mempool element
///
/// Iterate across all objects attached to a rte_mempool and call the
/// callback function on it.
///
/// @param mp
/// A pointer to an initialized mempool.
/// @param obj_cb
/// A function pointer that is called for each object.
/// @param obj_cb_arg
/// An opaque pointer passed to the callback function.
/// @return
/// Number of objects iterated.
    pub fn rte_mempool_obj_iter(mp: *mut rte_mempool,
                                obj_cb: rte_mempool_obj_cb_t,
                                obj_cb_arg: *mut ::std::os::raw::c_void)
     -> u32;
}
extern "C" {
    /// Call a function for each mempool memory chunk
///
/// Iterate across all memory chunks attached to a rte_mempool and call
/// the callback function on it.
///
/// @param mp
/// A pointer to an initialized mempool.
/// @param mem_cb
/// A function pointer that is called for each memory chunk.
/// @param mem_cb_arg
/// An opaque pointer passed to the callback function.
/// @return
/// Number of memory chunks iterated.
    pub fn rte_mempool_mem_iter(mp: *mut rte_mempool,
                                mem_cb: rte_mempool_mem_cb_t,
                                mem_cb_arg: *mut ::std::os::raw::c_void)
     -> u32;
}
extern "C" {
    /// Dump the status of the mempool to a file.
///
/// @param f
/// A pointer to a file for output
/// @param mp
/// A pointer to the mempool structure.
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    /// Create a user-owned mempool cache.
///
/// This can be used by non-EAL threads to enable caching when they
/// interact with a mempool.
///
/// @param size
/// The size of the mempool cache. See rte_mempool_create()'s cache_size
/// parameter description for more information. The same limits and
/// considerations apply here too.
/// @param socket_id
/// The socket identifier in the case of NUMA. The value can be
/// SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone.
    pub fn rte_mempool_cache_create(size: u32,
                                    socket_id: ::std::os::raw::c_int)
     -> *mut rte_mempool_cache;
}
extern "C" {
    /// Free a user-owned mempool cache.
///
/// @param cache
/// A pointer to the mempool cache.
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    /// Return the number of entries in the mempool.
///
/// When cache is enabled, this function has to browse the length of
/// all lcores, so it should not be used in a data path, but only for
/// debug purposes. User-owned mempool caches are not accounted for.
///
/// @param mp
/// A pointer to the mempool structure.
/// @return
/// The number of entries in the mempool.
    pub fn rte_mempool_avail_count(mp: *const rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return the number of elements which have been allocated from the mempool
///
/// When cache is enabled, this function has to browse the length of
/// all lcores, so it should not be used in a data path, but only for
/// debug purposes.
///
/// @param mp
/// A pointer to the mempool structure.
/// @return
/// The number of free entries in the mempool.
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Check the consistency of mempool objects.
///
/// Verify the coherency of fields in the mempool structure. Also check
/// that the cookies of mempool objects (even the ones that are not
/// present in pool) have a correct value. If not, a panic will occur.
///
/// @param mp
/// A pointer to the mempool structure.
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    /// Dump the status of all mempools on the console
///
/// @param f
/// A pointer to a file for output
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    /// Search a mempool from its name
///
/// @param name
/// The name of the mempool.
/// @return
/// The pointer to the mempool matching the name, or NULL if not found.
/// NULL on error
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
///
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_mempool;
}
extern "C" {
    /// Get the header, trailer and total size of a mempool element.
///
/// Given a desired size of the mempool element and mempool flags,
/// calculates header, trailer, body and total sizes of the mempool object.
///
/// @param elt_size
/// The size of each element, without header and trailer.
/// @param flags
/// The flags used for the mempool creation.
/// Consult rte_mempool_create() for more information about possible values.
/// The size of each element.
/// @param sz
/// The calculated detailed size the mempool object. May be NULL.
/// @return
/// Total size of the mempool object.
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32,
                                     sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    /// Get the size of memory required to store mempool elements.
///
/// Calculate the maximum amount of memory required to store given number
/// of objects. Assume that the memory buffer will be aligned at page
/// boundary.
///
/// Note that if object size is bigger then page size, then it assumes
/// that pages are grouped in subsets of physically continuous pages big
/// enough to store at least one object.
///
/// @param elt_num
/// Number of elements.
/// @param total_elt_sz
/// The size of each element, including header and trailer, as returned
/// by rte_mempool_calc_obj_size().
/// @param pg_shift
/// LOG2 of the physical pages size. If set to 0, ignore page boundaries.
/// @return
/// Required memory size aligned at page boundary.
    pub fn rte_mempool_xmem_size(elt_num: u32, total_elt_sz: usize,
                                 pg_shift: u32) -> usize;
}
extern "C" {
    /// Get the size of memory required to store mempool elements.
///
/// Calculate how much memory would be actually required with the given
/// memory footprint to store required number of objects.
///
/// @param vaddr
/// Virtual address of the externally allocated memory buffer.
/// Will be used to store mempool objects.
/// @param elt_num
/// Number of elements.
/// @param total_elt_sz
/// The size of each element, including header and trailer, as returned
/// by rte_mempool_calc_obj_size().
/// @param paddr
/// Array of physical addresses of the pages that comprises given memory
/// buffer.
/// @param pg_num
/// Number of elements in the paddr array.
/// @param pg_shift
/// LOG2 of the physical pages size.
/// @return
/// On success, the number of bytes needed to store given number of
/// objects, aligned to the given page size. If the provided memory
/// buffer is too small, return a negative value whose absolute value
/// is the actual number of elements that can be stored in that buffer.
    pub fn rte_mempool_xmem_usage(vaddr: *mut ::std::os::raw::c_void,
                                  elt_num: u32, total_elt_sz: usize,
                                  paddr: *const phys_addr_t, pg_num: u32,
                                  pg_shift: u32) -> isize;
}
extern "C" {
    /// Walk list of all memory pools
///
/// @param func
/// Iterator function
/// @param arg
/// Argument passed to iterator
    pub fn rte_mempool_walk(func:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut rte_mempool,
                                                                           arg:
                                                                               *mut ::std::os::raw::c_void)>,
                            arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Get the name of the l2 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the l3 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the l4 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the tunnel packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_tunnel_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l2 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l2_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l3 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l3_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l4 packet type
///
/// @param ptype
/// The packet type value.
/// @return
/// A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l4_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Write the packet type name into the buffer
///
/// @param ptype
/// The packet type value.
/// @param buf
/// The buffer where the string is written.
/// @param buflen
/// The length of the buffer.
/// @return
/// - 0 on success
/// - (-1) if the buffer is too small
    pub fn rte_get_ptype_name(ptype: u32, buf: *mut ::std::os::raw::c_char,
                              buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the name of a RX offload flag
///
/// @param mask
/// The mask describing the flag.
/// @return
/// The name of this flag, or NULL if it's not a valid RX flag.
    pub fn rte_get_rx_ol_flag_name(mask: u64)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Dump the list of RX offload flags in a buffer
///
/// @param mask
/// The mask describing the RX flags.
/// @param buf
/// The output buffer.
/// @param buflen
/// The length of the buffer.
/// @return
/// 0 on success, (-1) on error.
    pub fn rte_get_rx_ol_flag_list(mask: u64,
                                   buf: *mut ::std::os::raw::c_char,
                                   buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the name of a TX offload flag
///
/// @param mask
/// The mask describing the flag. Usually only one bit must be set.
/// Several bits can be given if they belong to the same mask.
/// Ex: PKT_TX_L4_MASK.
/// @return
/// The name of this flag, or NULL if it's not a valid TX flag.
    pub fn rte_get_tx_ol_flag_name(mask: u64)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Dump the list of TX offload flags in a buffer
///
/// @param mask
/// The mask describing the TX flags.
/// @param buf
/// The output buffer.
/// @param buflen
/// The length of the buffer.
/// @return
/// 0 on success, (-1) on error.
    pub fn rte_get_tx_ol_flag_list(mask: u64,
                                   buf: *mut ::std::os::raw::c_char,
                                   buflen: usize) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER8 = [u8; 0usize];
pub type MARKER64 = [u64; 0usize];
/// The generic rte_mbuf, containing a packet mbuf.
#[repr(C)]
#[derive(Copy)]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    /// < Virtual address of segment buffer.
    pub buf_addr: *mut ::std::os::raw::c_void,
    /// Physical address of segment buffer.
    /// Force alignment to 8-bytes, so as to ensure we have the exact
    /// same mbuf cacheline0 layout for 32-bit and 64-bit. This makes
    /// working on vector drivers easier.
    pub buf_physaddr: phys_addr_t,
    pub rearm_data: MARKER64,
    pub data_off: u16,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    /// < Number of segments.
    pub nb_segs: u16,
    /// Input port (16 bits to support more than 256 virtual ports).
    pub port: u16,
    /// < Offload features.
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    /// < Total pkt len: sum of all segments.
    pub pkt_len: u32,
    /// < Amount of data in segment buffer.
    pub data_len: u16,
    /// VLAN TCI (CPU order), valid if PKT_RX_VLAN_STRIPPED is set.
    pub vlan_tci: u16,
    /// < hash information
    pub hash: rte_mbuf__bindgen_ty_3,
    /// Outer VLAN TCI (CPU order), valid if PKT_RX_QINQ_STRIPPED is set.
    pub vlan_tci_outer: u16,
    /// < Length of segment buffer.
    pub buf_len: u16,
    /// Valid if PKT_RX_TIMESTAMP is set. The unit and time reference
    /// are not normalized but are always the same for a given port.
    pub timestamp: u64,
    pub cacheline1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_4,
    /// < Pool from which mbuf was allocated.
    pub pool: *mut rte_mempool,
    /// < Next segment of scattered packet.
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_5,
    /// Size of the application private data. In case of an indirect
    /// mbuf, it stores the direct mbuf private data size.
    pub priv_size: u16,
    /// Timesync flags for use with IEEE1588.
    pub timesync: u16,
    /// Sequence number. See also rte_reorder_insert().
    pub seqn: u32,
    pub __bindgen_padding_0: [u64; 3usize],
}
/// Reference counter. Its size should at least equal to the size
/// of port field (16 bits), to support zero-copy broadcast.
/// It should only be accessed using the following functions:
/// rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and
/// rte_mbuf_refcnt_set(). The functionality of these functions (atomic,
/// or non-atomic) is controlled by the CONFIG_RTE_MBUF_REFCNT_ATOMIC
/// config option.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_1 {
    /// < Atomically accessed refcnt
    pub refcnt_atomic: __BindgenUnionField<rte_atomic16_t>,
    /// < Non-atomically accessed refcnt
    pub refcnt: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_1>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mbuf__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mbuf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_1 ) ) .
                refcnt_atomic as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_1
                ) , "::" , stringify ! ( refcnt_atomic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_1 ) ) . refcnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_1
                ) , "::" , stringify ! ( refcnt ) ));
}
impl Clone for rte_mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_2 {
    /// < L2/L3/L4 and tunnel information.
    pub packet_type: __BindgenUnionField<u32>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
}
impl Clone for rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        let mask = 15u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 240u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        let mask = 240u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3840u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        let mask = 3840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 61440u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        let mask = 61440u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn inner_l2_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 983040u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u32) {
        let mask = 983040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15728640u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u32) {
        let mask = 15728640u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 251658240u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        let mask = 251658240u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(l2_type: u32, l3_type: u32, l4_type: u32,
                          tun_type: u32, inner_l2_type: u32,
                          inner_l3_type: u32, inner_l4_type: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((l2_type as u32 as u32) << 0usize)
                                               & (15u64 as u32))
                                  } |
                                      ((l3_type as u32 as u32) << 4usize) &
                                          (240u64 as u32))
                             } |
                                 ((l4_type as u32 as u32) << 8usize) &
                                     (3840u64 as u32))
                        } |
                            ((tun_type as u32 as u32) << 12usize) &
                                (61440u64 as u32))
                   } |
                       ((inner_l2_type as u32 as u32) << 16usize) &
                           (983040u64 as u32))
              } |
                  ((inner_l3_type as u32 as u32) << 20usize) &
                      (15728640u64 as u32))
         } |
             ((inner_l4_type as u32 as u32) << 24usize) &
                 (251658240u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_2>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mbuf__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_2>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mbuf__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_2 ) ) . packet_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_2
                ) , "::" , stringify ! ( packet_type ) ));
}
impl Clone for rte_mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3 {
    /// < RSS hash result if RSS enabled
    pub rss: __BindgenUnionField<u32>,
    /// < Filter identifier if FDIR enabled
    pub fdir: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1>,
    /// < Hierarchical scheduler
    pub sched: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_2>,
    /// < User defined tags. See rte_distributor_process()
    pub usr: __BindgenUnionField<u32>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub lo: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . hash as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . id as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( id ) ));
}
impl Clone for
 rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ) . lo as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( lo ) ));
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_1 ) )
                . hi as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                hi ) ));
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    pub lo: u32,
    pub hi: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) )
                . lo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) , "::" , stringify ! (
                lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) )
                . hi as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) , "::" , stringify ! (
                hi ) ));
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mbuf__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mbuf__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . rss as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_3
                ) , "::" , stringify ! ( rss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . fdir as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_3
                ) , "::" , stringify ! ( fdir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . sched as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_3
                ) , "::" , stringify ! ( sched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . usr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_3
                ) , "::" , stringify ! ( usr ) ));
}
impl Clone for rte_mbuf__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_4 {
    /// < Can be used for external metadata
    pub userdata: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /// < Allow 8-byte userdata on 32-bit
    pub udata64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_4>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mbuf__bindgen_ty_4 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mbuf__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_4 ) ) . userdata as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_4
                ) , "::" , stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_4 ) ) . udata64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_4
                ) , "::" , stringify ! ( udata64 ) ));
}
impl Clone for rte_mbuf__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_5 {
    /// < combined for easy fetch
    pub tx_offload: __BindgenUnionField<u64>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_5__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: [u16; 4usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               rte_mbuf__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_mbuf__bindgen_ty_5__bindgen_ty_1 ) ));
}
impl Clone for rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 127u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        let mask = 127u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 65408u64 as u64;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        let mask = 65408u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16711680u64 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        let mask = 16711680u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1099494850560u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        let mask = 1099494850560u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 561850441793536u64 as u64;
        let val = (unit_field_val & mask) >> 40usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        let mask = 561850441793536u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 40usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 71494644084506624u64 as u64;
        let val = (unit_field_val & mask) >> 49usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        let mask = 71494644084506624u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 49usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(l2_len: u64, l3_len: u64, l4_len: u64,
                          tso_segsz: u64, outer_l3_len: u64,
                          outer_l2_len: u64) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((l2_len as u64 as u64) << 0usize) &
                                          (127u64 as u64))
                             } |
                                 ((l3_len as u64 as u64) << 7usize) &
                                     (65408u64 as u64))
                        } |
                            ((l4_len as u64 as u64) << 16usize) &
                                (16711680u64 as u64))
                   } |
                       ((tso_segsz as u64 as u64) << 24usize) &
                           (1099494850560u64 as u64))
              } |
                  ((outer_l3_len as u64 as u64) << 40usize) &
                      (561850441793536u64 as u64))
         } |
             ((outer_l2_len as u64 as u64) << 49usize) &
                 (71494644084506624u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_5>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rte_mbuf__bindgen_ty_5 )
               ));
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_mbuf__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_5 ) ) . tx_offload
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf__bindgen_ty_5
                ) , "::" , stringify ! ( tx_offload ) ));
}
impl Clone for rte_mbuf__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(::std::mem::size_of::<rte_mbuf>() , 128usize , concat ! (
               "Size of: " , stringify ! ( rte_mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . cacheline0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( cacheline0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( buf_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_physaddr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( buf_physaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . rearm_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( rearm_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . data_off as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . nb_segs as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( nb_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . port as * const _ as usize
                } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . ol_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( ol_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . rx_descriptor_fields1 as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( rx_descriptor_fields1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . pkt_len as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( pkt_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . data_len as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . vlan_tci as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . hash as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . vlan_tci_outer as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( vlan_tci_outer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_len as * const _ as
                usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( buf_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . timestamp as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . cacheline1 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( cacheline1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . pool as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . next as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . priv_size as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( priv_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . timesync as * const _ as
                usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( timesync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . seqn as * const _ as usize
                } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mbuf ) , "::" ,
                stringify ! ( seqn ) ));
}
impl Clone for rte_mbuf {
    fn clone(&self) -> Self { *self }
}
/// Private data in case of pktmbuf pool.
///
/// A structure that contains some pktmbuf_pool-specific data that are
/// appended after the mempool structure (in private data).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pktmbuf_pool_private {
    /// < Size of data space in each mbuf.
    pub mbuf_data_room_size: u16,
    /// < Size of private area in each mbuf.
    pub mbuf_priv_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(::std::mem::size_of::<rte_pktmbuf_pool_private>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pktmbuf_pool_private ) ));
    assert_eq! (::std::mem::align_of::<rte_pktmbuf_pool_private>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pktmbuf_pool_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pktmbuf_pool_private ) ) .
                mbuf_data_room_size as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_pktmbuf_pool_private ) , "::" , stringify ! (
                mbuf_data_room_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pktmbuf_pool_private ) ) .
                mbuf_priv_size as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pktmbuf_pool_private ) , "::" , stringify ! (
                mbuf_priv_size ) ));
}
impl Clone for rte_pktmbuf_pool_private {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Sanity checks on an mbuf.
///
/// Check the consistency of the given mbuf. The function will cause a
/// panic if corruption is detected.
///
/// @param m
/// The mbuf to be checked.
/// @param is_header
/// True if the mbuf is a packet header, false if it is a sub-segment
/// of a packet (in this case, some fields like nb_segs are not checked)
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf,
                                 is_header: ::std::os::raw::c_int);
}
extern "C" {
    /// The control mbuf constructor.
///
/// This function initializes some fields in an mbuf structure that are
/// not modified by the user once created (mbuf type, origin pool, buffer
/// start address, and so on). This function is given as a callback function
/// to rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.
///
/// @param mp
/// The mempool from which the mbuf is allocated.
/// @param opaque_arg
/// A pointer that can be used by the user to retrieve useful information
/// for mbuf initialization. This pointer is the opaque argument passed to
/// rte_mempool_obj_iter() or rte_mempool_create().
/// @param m
/// The mbuf to initialize.
/// @param i
/// The index of the mbuf in the pool table.
    pub fn rte_ctrlmbuf_init(mp: *mut rte_mempool,
                             opaque_arg: *mut ::std::os::raw::c_void,
                             m: *mut ::std::os::raw::c_void,
                             i: ::std::os::raw::c_uint);
}
extern "C" {
    /// The packet mbuf constructor.
///
/// This function initializes some fields in the mbuf structure that are
/// not modified by the user once created (origin pool, buffer start
/// address, and so on). This function is given as a callback function to
/// rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.
///
/// @param mp
/// The mempool from which mbufs originate.
/// @param opaque_arg
/// A pointer that can be used by the user to retrieve useful information
/// for mbuf initialization. This pointer is the opaque argument passed to
/// rte_mempool_obj_iter() or rte_mempool_create().
/// @param m
/// The mbuf to initialize.
/// @param i
/// The index of the mbuf in the pool table.
    pub fn rte_pktmbuf_init(mp: *mut rte_mempool,
                            opaque_arg: *mut ::std::os::raw::c_void,
                            m: *mut ::std::os::raw::c_void,
                            i: ::std::os::raw::c_uint);
}
extern "C" {
    /// A  packet mbuf pool constructor.
///
/// This function initializes the mempool private data in the case of a
/// pktmbuf pool. This private data is needed by the driver. The
/// function must be called on the mempool before it is used, or it
/// can be given as a callback function to rte_mempool_create() at
/// pool creation. It can be extended by the user, for example, to
/// provide another packet size.
///
/// @param mp
/// The mempool from which mbufs originate.
/// @param opaque_arg
/// A pointer that can be used by the user to retrieve useful information
/// for mbuf initialization. This pointer is the opaque argument passed to
/// rte_mempool_create().
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool,
                                 opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Create a mbuf pool.
///
/// This function creates and initializes a packet mbuf pool. It is
/// a wrapper to rte_mempool functions.
///
/// @param name
/// The name of the mbuf pool.
/// @param n
/// The number of elements in the mbuf pool. The optimum size (in terms
/// of memory usage) for a mempool is when n is a power of two minus one:
/// n = (2^q - 1).
/// @param cache_size
/// Size of the per-core object cache. See rte_mempool_create() for
/// details.
/// @param priv_size
/// Size of application private are between the rte_mbuf structure
/// and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.
/// @param data_room_size
/// Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.
/// @param socket_id
/// The socket identifier where the memory should be allocated. The
/// value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the
/// reserved zone.
/// @return
/// The pointer to the new allocated mempool, on success. NULL on error
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - cache size provided is too large, or priv_size is not aligned.
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_pktmbuf_pool_create(name: *const ::std::os::raw::c_char,
                                   n: ::std::os::raw::c_uint,
                                   cache_size: ::std::os::raw::c_uint,
                                   priv_size: u16, data_room_size: u16,
                                   socket_id: ::std::os::raw::c_int)
     -> *mut rte_mempool;
}
extern "C" {
    /// @internal used by rte_pktmbuf_read().
    pub fn __rte_pktmbuf_read(m: *const rte_mbuf, off: u32, len: u32,
                              buf: *mut ::std::os::raw::c_void)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /// Dump an mbuf structure to a file.
///
/// Dump all fields for the given packet mbuf and all its associated
/// segments (in the case of a chained buffer).
///
/// @param f
/// A pointer to a file for output
/// @param m
/// The packet mbuf.
/// @param dump_len
/// If dump_len != 0, also dump the "dump_len" first data bytes of
/// the packet.
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf,
                            dump_len: ::std::os::raw::c_uint);
}
/// Ethernet address:
/// A universally administered address is uniquely assigned to a device by its
/// manufacturer. The first three octets (in transmission order) contain the
/// Organizationally Unique Identifier (OUI). The following three (MAC-48 and
/// EUI-48) octets are assigned by that organization with the only constraint
/// of uniqueness.
/// A locally administered address is assigned to a device by a network
/// administrator and does not contain OUIs.
/// See http://standards.ieee.org/regauth/groupmac/tutorial.html
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ether_addr {
    /// < Addr bytes in tx order
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(::std::mem::size_of::<ether_addr>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ether_addr ) ));
    assert_eq! (::std::mem::align_of::<ether_addr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_addr ) ) . addr_bytes as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_addr ) , "::" ,
                stringify ! ( addr_bytes ) ));
}
impl Clone for ether_addr {
    fn clone(&self) -> Self { *self }
}
/// Ethernet header: Contains the destination address, source address
/// and frame type.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ether_hdr {
    /// < Destination address.
    pub d_addr: ether_addr,
    /// < Source address.
    pub s_addr: ether_addr,
    /// < Frame type.
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_ether_hdr() {
    assert_eq!(::std::mem::size_of::<ether_hdr>() , 14usize , concat ! (
               "Size of: " , stringify ! ( ether_hdr ) ));
    assert_eq! (::std::mem::align_of::<ether_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . d_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_hdr ) , "::" ,
                stringify ! ( d_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . s_addr as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_hdr ) , "::" ,
                stringify ! ( s_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . ether_type as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_hdr ) , "::" ,
                stringify ! ( ether_type ) ));
}
impl Clone for ether_hdr {
    fn clone(&self) -> Self { *self }
}
/// Ethernet VLAN Header.
/// Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type
/// of the encapsulated frame.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct vlan_hdr {
    /// < Priority (3) + CFI (1) + Identifier Code (12)
    pub vlan_tci: u16,
    /// < Ethernet type of encapsulated frame.
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_vlan_hdr() {
    assert_eq!(::std::mem::size_of::<vlan_hdr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( vlan_hdr ) ));
    assert_eq! (::std::mem::align_of::<vlan_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( vlan_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlan_hdr ) ) . vlan_tci as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vlan_hdr ) , "::" ,
                stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlan_hdr ) ) . eth_proto as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( vlan_hdr ) , "::" ,
                stringify ! ( eth_proto ) ));
}
impl Clone for vlan_hdr {
    fn clone(&self) -> Self { *self }
}
/// VXLAN protocol header.
/// Contains the 8-bit flag, 24-bit VXLAN Network Identifier and
/// Reserved fields (24 bits and 8 bits)
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct vxlan_hdr {
    /// < flag (8) + Reserved (24).
    pub vx_flags: u32,
    /// < VNI (24) + Reserved (8).
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_vxlan_hdr() {
    assert_eq!(::std::mem::size_of::<vxlan_hdr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( vxlan_hdr ) ));
    assert_eq! (::std::mem::align_of::<vxlan_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( vxlan_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vxlan_hdr ) ) . vx_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vxlan_hdr ) , "::" ,
                stringify ! ( vx_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vxlan_hdr ) ) . vx_vni as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vxlan_hdr ) , "::" ,
                stringify ! ( vx_vni ) ));
}
impl Clone for vxlan_hdr {
    fn clone(&self) -> Self { *self }
}
/// ARP header IPv4 payload.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct arp_ipv4 {
    /// < sender hardware address
    pub arp_sha: ether_addr,
    /// < sender IP address
    pub arp_sip: u32,
    /// < target hardware address
    pub arp_tha: ether_addr,
    /// < target IP address
    pub arp_tip: u32,
}
#[test]
fn bindgen_test_layout_arp_ipv4() {
    assert_eq!(::std::mem::size_of::<arp_ipv4>() , 20usize , concat ! (
               "Size of: " , stringify ! ( arp_ipv4 ) ));
    assert_eq! (::std::mem::align_of::<arp_ipv4>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( arp_ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_sha as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_ipv4 ) , "::" ,
                stringify ! ( arp_sha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_sip as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_ipv4 ) , "::" ,
                stringify ! ( arp_sip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_tha as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_ipv4 ) , "::" ,
                stringify ! ( arp_tha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_tip as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_ipv4 ) , "::" ,
                stringify ! ( arp_tip ) ));
}
impl Clone for arp_ipv4 {
    fn clone(&self) -> Self { *self }
}
/// ARP header.
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct arp_hdr {
    pub arp_hrd: u16,
    pub arp_pro: u16,
    pub arp_hln: u8,
    pub arp_pln: u8,
    pub arp_op: u16,
    pub arp_data: arp_ipv4,
}
#[test]
fn bindgen_test_layout_arp_hdr() {
    assert_eq!(::std::mem::size_of::<arp_hdr>() , 28usize , concat ! (
               "Size of: " , stringify ! ( arp_hdr ) ));
    assert_eq! (::std::mem::align_of::<arp_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( arp_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_hrd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_hrd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_pro as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_pro ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_hln as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_hln ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_pln as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_pln ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_op as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( arp_hdr ) , "::" ,
                stringify ! ( arp_data ) ));
}
impl Clone for arp_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_avp_req_id {
    RTE_AVP_REQ_UNKNOWN = 0,
    RTE_AVP_REQ_CHANGE_MTU = 1,
    RTE_AVP_REQ_CFG_NETWORK_IF = 2,
    RTE_AVP_REQ_CFG_DEVICE = 3,
    RTE_AVP_REQ_SHUTDOWN_DEVICE = 4,
    RTE_AVP_REQ_MAX = 5,
}
/// @}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_avp_device_config {
    /// < Unique system identifier
    pub device_id: u64,
    /// < Device Driver type
    pub driver_type: u32,
    /// < Device Driver version
    pub driver_version: u32,
    /// < Negotiated features
    pub features: u32,
    /// < Number of active transmit queues
    pub num_tx_queues: u16,
    /// < Number of active receive queues
    pub num_rx_queues: u16,
    /// < 1: interface up, 0: interface down
    pub if_up: u8,
}
#[test]
fn bindgen_test_layout_rte_avp_device_config() {
    assert_eq!(::std::mem::size_of::<rte_avp_device_config>() , 25usize ,
               concat ! ( "Size of: " , stringify ! ( rte_avp_device_config )
               ));
    assert_eq! (::std::mem::align_of::<rte_avp_device_config>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_avp_device_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . device_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . driver_type
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( driver_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) .
                driver_version as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( driver_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . features as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( features ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . num_tx_queues
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( num_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . num_rx_queues
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( num_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_config ) ) . if_up as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_config )
                , "::" , stringify ! ( if_up ) ));
}
impl Clone for rte_avp_device_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_avp_request {
    /// < Request id
    pub req_id: u32,
    pub __bindgen_anon_1: rte_avp_request__bindgen_ty_1,
    /// < Result for processing request
    pub result: i32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_avp_request__bindgen_ty_1 {
    /// < New MTU
    pub new_mtu: __BindgenUnionField<u32>,
    /// < 1: interface up, 0: interface down
    pub if_up: __BindgenUnionField<u8>,
    /// < Queue configuration
    pub config: __BindgenUnionField<rte_avp_device_config>,
    pub bindgen_union_field: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_rte_avp_request__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_avp_request__bindgen_ty_1>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( rte_avp_request__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_avp_request__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_avp_request__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_request__bindgen_ty_1 ) ) .
                new_mtu as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_avp_request__bindgen_ty_1 ) , "::" , stringify ! ( new_mtu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_request__bindgen_ty_1 ) ) . if_up
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_avp_request__bindgen_ty_1 ) , "::" , stringify ! ( if_up )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_request__bindgen_ty_1 ) ) .
                config as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_avp_request__bindgen_ty_1 ) , "::" , stringify ! ( config
                ) ));
}
impl Clone for rte_avp_request__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_avp_request() {
    assert_eq!(::std::mem::size_of::<rte_avp_request>() , 36usize , concat ! (
               "Size of: " , stringify ! ( rte_avp_request ) ));
    assert_eq! (::std::mem::align_of::<rte_avp_request>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( rte_avp_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_request ) ) . req_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_request ) ,
                "::" , stringify ! ( req_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_request ) ) . result as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_request ) ,
                "::" , stringify ! ( result ) ));
}
impl Clone for rte_avp_request {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_avp_fifo {
    /// < Next position to be written
    pub write: ::std::os::raw::c_uint,
    /// < Next position to be read
    pub read: ::std::os::raw::c_uint,
    /// < Circular buffer length
    pub len: ::std::os::raw::c_uint,
    /// < Pointer size - for 32/64 bit OS
    pub elem_size: ::std::os::raw::c_uint,
    /// < The buffer contains mbuf pointers
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_avp_fifo() {
    assert_eq!(::std::mem::size_of::<rte_avp_fifo>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_avp_fifo ) ));
    assert_eq! (::std::mem::align_of::<rte_avp_fifo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_avp_fifo ) ));
}
impl Clone for rte_avp_fifo {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct rte_avp_desc {
    pub pad0: u64,
    /// < Reference to packet mbuf
    pub pkt_mbuf: *mut ::std::os::raw::c_void,
    pub pad1: [u8; 14usize],
    /// < Offload features.
    pub ol_flags: u16,
    /// < Reference to next buffer in chain
    pub next: *mut ::std::os::raw::c_void,
    /// < Start address of data in segment buffer.
    pub data: *mut ::std::os::raw::c_void,
    /// < Amount of data in segment buffer.
    pub data_len: u16,
    /// < Number of segments
    pub nb_segs: u8,
    pub pad2: u8,
    /// < Total pkt len: sum of all segment data_len.
    pub pkt_len: u16,
    pub pad3: u32,
    /// < VLAN Tag Control Identifier (CPU order).
    pub vlan_tci: u16,
    pub pad4: u32,
}
#[test]
fn bindgen_test_layout_rte_avp_desc() {
    assert_eq!(::std::mem::size_of::<rte_avp_desc>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rte_avp_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pad0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pkt_mbuf as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pkt_mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pad1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . ol_flags as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( ol_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . next as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . data as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . data_len as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . nb_segs as * const _
                as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( nb_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pad2 as * const _ as
                usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pkt_len as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pkt_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pad3 as * const _ as
                usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . vlan_tci as * const _
                as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_desc ) ) . pad4 as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_desc ) , "::" ,
                stringify ! ( pad4 ) ));
}
impl Clone for rte_avp_desc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_avp_memmap {
    pub addr: *mut ::std::os::raw::c_void,
    pub phys_addr: phys_addr_t,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_rte_avp_memmap() {
    assert_eq!(::std::mem::size_of::<rte_avp_memmap>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_avp_memmap ) ));
    assert_eq! (::std::mem::align_of::<rte_avp_memmap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_avp_memmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap ) ) . addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap ) ) . phys_addr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap ) , "::"
                , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap ) ) . length as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for rte_avp_memmap {
    fn clone(&self) -> Self { *self }
}
/// @}
#[repr(C)]
pub struct rte_avp_memmap_info {
    /// < Memory validation marker
    pub magic: u32,
    /// < Data format version
    pub version: u32,
    pub nb_maps: u32,
    pub maps: [rte_avp_memmap; 2048usize],
}
#[test]
fn bindgen_test_layout_rte_avp_memmap_info() {
    assert_eq!(::std::mem::size_of::<rte_avp_memmap_info>() , 49168usize ,
               concat ! ( "Size of: " , stringify ! ( rte_avp_memmap_info )
               ));
    assert_eq! (::std::mem::align_of::<rte_avp_memmap_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_avp_memmap_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap_info ) ) . magic as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap_info ) ,
                "::" , stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap_info ) ) . version as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap_info ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap_info ) ) . nb_maps as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap_info ) ,
                "::" , stringify ! ( nb_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_memmap_info ) ) . maps as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_memmap_info ) ,
                "::" , stringify ! ( maps ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_avp_mempool_info {
    pub addr: *mut ::std::os::raw::c_void,
    pub phys_addr: phys_addr_t,
    pub length: u64,
}
#[test]
fn bindgen_test_layout_rte_avp_mempool_info() {
    assert_eq!(::std::mem::size_of::<rte_avp_mempool_info>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_avp_mempool_info )
               ));
    assert_eq! (::std::mem::align_of::<rte_avp_mempool_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_avp_mempool_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_mempool_info ) ) . addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_mempool_info )
                , "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_mempool_info ) ) . phys_addr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_mempool_info )
                , "::" , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_mempool_info ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_mempool_info )
                , "::" , stringify ! ( length ) ));
}
impl Clone for rte_avp_mempool_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_avp_device_info {
    /// < Memory validation marker
    pub magic: u32,
    /// < Data format version
    pub version: u32,
    /// < Network device name for AVP
    pub ifname: [::std::os::raw::c_char; 32usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    /// < Supported feature bitmap
    pub features: u32,
    /// < Minimum supported receive/free queues
    pub min_rx_queues: u8,
    /// < Recommended number of receive/free queues
    pub num_rx_queues: u8,
    /// < Maximum supported receive/free queues
    pub max_rx_queues: u8,
    /// < Minimum supported transmit/alloc queues
    pub min_tx_queues: u8,
    pub num_tx_queues: u8,
    /// < Maximum supported transmit/alloc queues
    pub max_tx_queues: u8,
    /// < Size of each transmit queue
    pub tx_size: u32,
    /// < Size of each receive queue
    pub rx_size: u32,
    /// < Size of each alloc queue
    pub alloc_size: u32,
    /// < Size of each free queue
    pub free_size: u32,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    pub pool: [rte_avp_mempool_info; 8usize],
    pub ethaddr: [::std::os::raw::c_char; 6usize],
    /// < device mode, i.e guest, host, trace
    pub mode: u8,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub device_id: u64,
    /// < Maximum receive unit size
    pub max_rx_pkt_len: u32,
}
#[test]
fn bindgen_test_layout_rte_avp_device_info() {
    assert_eq!(::std::mem::size_of::<rte_avp_device_info>() , 376usize ,
               concat ! ( "Size of: " , stringify ! ( rte_avp_device_info )
               ));
    assert_eq! (::std::mem::align_of::<rte_avp_device_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_avp_device_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . magic as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . version as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . ifname as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( ifname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . tx_phys as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( tx_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . rx_phys as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( rx_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . alloc_phys as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( alloc_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . free_phys as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( free_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . features as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( features ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . min_rx_queues
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( min_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . num_rx_queues
                as * const _ as usize } , 77usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( num_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . max_rx_queues
                as * const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( max_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . min_tx_queues
                as * const _ as usize } , 79usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( min_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . num_tx_queues
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( num_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . max_tx_queues
                as * const _ as usize } , 81usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( max_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . tx_size as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( tx_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . rx_size as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( rx_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . alloc_size as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( alloc_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . free_size as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( free_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . req_phys as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( req_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . resp_phys as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( resp_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . sync_phys as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( sync_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . sync_va as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( sync_va ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . mbuf_va as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( mbuf_va ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . mbuf_phys as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( mbuf_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . pool as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . ethaddr as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( ethaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . mode as * const
                _ as usize } , 350usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . mbuf_size as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( mbuf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . device_id as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_avp_device_info ) ) . max_rx_pkt_len
                as * const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_avp_device_info ) ,
                "::" , stringify ! ( max_rx_pkt_len ) ));
}
impl Clone for rte_avp_device_info {
    fn clone(&self) -> Self { *self }
}
/// Bitmap data structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bitmap {
    /// < Bitmap array1
    pub array1: *mut u64,
    /// < Bitmap array2
    pub array2: *mut u64,
    /// < Number of 64-bit slabs in array1 that are actually used
    pub array1_size: u32,
    /// < Number of 64-bit slabs in array2
    pub array2_size: u32,
    /// < Bitmap scan: Index of current array1 slab
    pub index1: u32,
    /// < Bitmap scan: Offset of current bit within current array1 slab
    pub offset1: u32,
    /// < Bitmap scan: Index of current array2 slab
    pub index2: u32,
    /// < Bitmap scan: Go/stop condition for current array2 cache line
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_bitmap() {
    assert_eq!(::std::mem::size_of::<rte_bitmap>() , 40usize , concat ! (
               "Size of: " , stringify ! ( rte_bitmap ) ));
    assert_eq! (::std::mem::align_of::<rte_bitmap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_bitmap ) ));
}
impl Clone for rte_bitmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_stats_bitrates {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate a bitrate statistics structure
///
/// @return
/// - Pointer to structure on success
/// - NULL on error (zmalloc failure)
    pub fn rte_stats_bitrate_create() -> *mut rte_stats_bitrates;
}
extern "C" {
    /// Register bitrate statistics with the metric library.
///
/// @param bitrate_data
/// Pointer allocated by rte_stats_create()
///
/// @return
/// Zero on success
/// Negative on error
    pub fn rte_stats_bitrate_reg(bitrate_data: *mut rte_stats_bitrates)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculate statistics for current time window. The period with which
/// this function is called should be the intended sampling window width.
///
/// @param bitrate_data
/// Bitrate statistics data pointer
///
/// @param port_id
/// Port id to calculate statistics for
///
/// @return
/// - Zero on success
/// - Negative value on error
    pub fn rte_stats_bitrate_calc(bitrate_data: *mut rte_stats_bitrates,
                                  port_id: u8) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// Device driver.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_kernel_driver {
    RTE_KDRV_UNKNOWN = 0,
    RTE_KDRV_IGB_UIO = 1,
    RTE_KDRV_VFIO = 2,
    RTE_KDRV_UIO_GENERIC = 3,
    RTE_KDRV_NIC_UIO = 4,
    RTE_KDRV_NONE = 5,
}
#[repr(u32)]
/// Device policies.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_dev_policy { RTE_DEV_WHITELISTED = 0, RTE_DEV_BLACKLISTED = 1, }
/// A generic memory resource representation.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mem_resource {
    /// < Physical address, 0 if not resource.
    pub phys_addr: u64,
    /// < Length of the resource.
    pub len: u64,
    /// < Virtual address, NULL when not mapped.
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(::std::mem::size_of::<rte_mem_resource>() , 24usize , concat !
               ( "Size of: " , stringify ! ( rte_mem_resource ) ));
    assert_eq! (::std::mem::align_of::<rte_mem_resource>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_mem_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . phys_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_resource ) ,
                "::" , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_resource ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_mem_resource ) ,
                "::" , stringify ! ( addr ) ));
}
impl Clone for rte_mem_resource {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a device driver.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_driver {
    /// < Next in list.
    pub next: rte_driver__bindgen_ty_1,
    /// < Driver name.
    pub name: *const ::std::os::raw::c_char,
    /// < Driver alias.
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_driver__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_driver__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_driver__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_driver__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_driver__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_driver__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for rte_driver__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(::std::mem::size_of::<rte_driver>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rte_driver ) ));
    assert_eq! (::std::mem::align_of::<rte_driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_driver ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_driver ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver ) ) . alias as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_driver ) , "::" ,
                stringify ! ( alias ) ));
}
impl Clone for rte_driver {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a generic device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device {
    /// < Next device
    pub next: rte_device__bindgen_ty_1,
    /// < Device name
    pub name: *const ::std::os::raw::c_char,
    /// < Associated driver
    pub driver: *const rte_driver,
    /// < NUMA node connection
    pub numa_node: ::std::os::raw::c_int,
    /// < Device user arguments
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_device__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_device__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_device__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_device__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_device__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_device__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for rte_device__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(::std::mem::size_of::<rte_device>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_device ) ));
    assert_eq! (::std::mem::align_of::<rte_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_device ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device ) ) . name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_device ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device ) ) . driver as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_device ) , "::" ,
                stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device ) ) . numa_node as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_device ) , "::" ,
                stringify ! ( numa_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device ) ) . devargs as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_device ) , "::" ,
                stringify ! ( devargs ) ));
}
impl Clone for rte_device {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Initialize a driver specified by name.
///
/// @param name
/// The pointer to a driver name to be initialized.
/// @param args
/// The pointer to arguments used by driver initialization.
/// @return
/// 0 on success, negative on error
    pub fn rte_vdev_init(name: *const ::std::os::raw::c_char,
                         args: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Uninitalize a driver specified by name.
///
/// @param name
/// The pointer to a driver name to be initialized.
/// @return
/// 0 on success, negative on error
    pub fn rte_vdev_uninit(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach a device to a registered driver.
///
/// @param name
/// The device name, that refers to a pci device (or some private
/// way of designating a vdev device). Based on this device name, eal
/// will identify a driver capable of handling it and pass it to the
/// driver probing function.
/// @param devargs
/// Device arguments to be passed to the driver.
/// @return
/// 0 on success, negative on error.
    pub fn rte_eal_dev_attach(name: *const ::std::os::raw::c_char,
                              devargs: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach a device from its driver.
///
/// @param dev
/// A pointer to a rte_device structure.
/// @return
/// 0 on success, negative on error.
    pub fn rte_eal_dev_detach(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Hotplug add a given device to a specific bus.
///
/// @param busname
/// The bus name the device is added to.
/// @param devname
/// The device name. Based on this device name, eal will identify a driver
/// capable of handling it and pass it to the driver probing function.
/// @param devargs
/// Device arguments to be passed to the driver.
/// @return
/// 0 on success, negative on error.
    pub fn rte_eal_hotplug_add(busname: *const ::std::os::raw::c_char,
                               devname: *const ::std::os::raw::c_char,
                               devargs: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Hotplug remove a given device from a specific bus.
///
/// @param busname
/// The bus name the device is removed from.
/// @param devname
/// The device name being removed.
/// @return
/// 0 on success, negative on error.
    pub fn rte_eal_hotplug_remove(busname: *const ::std::os::raw::c_char,
                                  devname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/// Device comparison function.
///
/// This type of function is used to compare an rte_device with arbitrary
/// data.
///
/// @param dev
/// Device handle.
///
/// @param data
/// Data to compare against. The type of this parameter is determined by
/// the kind of comparison performed by the function.
///
/// @return
/// 0 if the device matches the data.
/// !0 if the device does not match.
/// <0 if ordering is possible and the device is lower than the data.
/// >0 if ordering is possible and the device is greater than the data.
pub type rte_dev_cmp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *const rte_device,
                                               data:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Double linked list of buses
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(::std::mem::size_of::<rte_bus_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_bus_list ) ));
    assert_eq! (::std::mem::align_of::<rte_bus_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_bus_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus_list ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus_list ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus_list ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus_list ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for rte_bus_list {
    fn clone(&self) -> Self { *self }
}
/// Bus specific scan for devices attached on the bus.
/// For each bus object, the scan would be responsible for finding devices and
/// adding them to its private device list.
///
/// A bus should mandatorily implement this method.
///
/// @return
/// 0 for successful scan
/// <0 for unsuccessful scan with error value
pub type rte_bus_scan_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
/// Implementation specific probe function which is responsible for linking
/// devices on that bus with applicable drivers.
///
/// This is called while iterating over each registered bus.
///
/// @return
/// 0 for successful probe
/// !0 for any error while probing
pub type rte_bus_probe_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
/// Device iterator to find a device on a bus.
///
/// This function returns an rte_device if one of those held by the bus
/// matches the data passed as parameter.
///
/// If the comparison function returns zero this function should stop iterating
/// over any more devices. To continue a search the device of a previous search
/// can be passed via the start parameter.
///
/// @param cmp
/// Comparison function.
///
/// @param data
/// Data to compare each device against.
///
/// @param start
/// starting point for the iteration
///
/// @return
/// The first device matching the data, NULL if none exists.
pub type rte_bus_find_device_t =
    ::std::option::Option<unsafe extern "C" fn(start: *const rte_device,
                                               cmp: rte_dev_cmp_t,
                                               data:
                                                   *const ::std::os::raw::c_void)
                              -> *mut rte_device>;
/// Implementation specific probe function which is responsible for linking
/// devices on that bus with applicable drivers.
///
/// @param dev
/// Device pointer that was returned by a previous call to find_device.
///
/// @return
/// 0 on success.
/// !0 on error.
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device)
                              -> ::std::os::raw::c_int>;
/// Implementation specific remove function which is responsible for unlinking
/// devices on that bus from assigned driver.
///
/// @param dev
/// Device pointer that was returned by a previous call to find_device.
///
/// @return
/// 0 on success.
/// !0 on error.
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device)
                              -> ::std::os::raw::c_int>;
/// Bus specific parsing function.
/// Validates the syntax used in the textual representation of a device,
/// If the syntax is valid and ``addr`` is not NULL, writes the bus-specific
/// device representation to ``addr``.
///
/// @param[in] name
/// device textual description
///
/// @param[out] addr
/// device information location address, into which parsed info
/// should be written. If NULL, nothing should be written, which
/// is not an error.
///
/// @return
/// 0 if parsing was successful.
/// !0 for any error.
pub type rte_bus_parse_t =
    ::std::option::Option<unsafe extern "C" fn(name:
                                                   *const ::std::os::raw::c_char,
                                               addr:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(u32)]
/// Bus scan policies
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_bus_scan_mode {
    RTE_BUS_SCAN_UNDEFINED = 0,
    RTE_BUS_SCAN_WHITELIST = 1,
    RTE_BUS_SCAN_BLACKLIST = 2,
}
/// A structure used to configure bus operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bus_conf {
    /// < Scan policy.
    pub scan_mode: rte_bus_scan_mode,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(::std::mem::size_of::<rte_bus_conf>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_bus_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_bus_conf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_bus_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus_conf ) ) . scan_mode as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus_conf ) , "::" ,
                stringify ! ( scan_mode ) ));
}
impl Clone for rte_bus_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a generic bus.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bus {
    /// < Next bus object in linked list
    pub next: rte_bus__bindgen_ty_1,
    /// < Name of the bus
    pub name: *const ::std::os::raw::c_char,
    /// < Scan for devices attached to bus
    pub scan: rte_bus_scan_t,
    /// < Probe devices on bus
    pub probe: rte_bus_probe_t,
    /// < Find a device on the bus
    pub find_device: rte_bus_find_device_t,
    /// < Probe single device for drivers
    pub plug: rte_bus_plug_t,
    /// < Remove single device from driver
    pub unplug: rte_bus_unplug_t,
    /// < Parse a device name
    pub parse: rte_bus_parse_t,
    /// < Bus configuration
    pub conf: rte_bus_conf,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_bus__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_bus__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_bus__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_bus__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for rte_bus__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(::std::mem::size_of::<rte_bus>() , 80usize , concat ! (
               "Size of: " , stringify ! ( rte_bus ) ));
    assert_eq! (::std::mem::align_of::<rte_bus>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . next as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . name as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . scan as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( scan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . probe as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . find_device as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( find_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . plug as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( plug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . unplug as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( unplug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . parse as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( parse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_bus ) ) . conf as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_bus ) , "::" ,
                stringify ! ( conf ) ));
}
impl Clone for rte_bus {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Register a Bus handler.
///
/// @param bus
/// A pointer to a rte_bus structure describing the bus
/// to be registered.
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    /// Unregister a Bus handler.
///
/// @param bus
/// A pointer to a rte_bus structure describing the bus
/// to be unregistered.
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    /// Scan all the buses.
///
/// @return
/// 0 in case of success in scanning all buses
/// !0 in case of failure to scan
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    /// For each device on the buses, perform a driver 'match' and call the
/// driver-specific probe for device initialization.
///
/// @return
/// 0 for successful match/probe
/// !0 otherwise
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump information of all the buses registered with EAL.
///
/// @param f
/// A valid and open output stream handle
    pub fn rte_bus_dump(f: *mut FILE);
}
/// Bus comparison function.
///
/// @param bus
/// Bus under test.
///
/// @param data
/// Data to compare against.
///
/// @return
/// 0 if the bus matches the data.
/// !0 if the bus does not match.
/// <0 if ordering is possible and the bus is lower than the data.
/// >0 if ordering is possible and the bus is greater than the data.
pub type rte_bus_cmp_t =
    ::std::option::Option<unsafe extern "C" fn(bus: *const rte_bus,
                                               data:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Bus iterator to find a particular bus.
///
/// This function compares each registered bus to find one that matches
/// the data passed as parameter.
///
/// If the comparison function returns zero this function will stop iterating
/// over any more buses. To continue a search the bus of a previous search can
/// be passed via the start parameter.
///
/// @param start
/// Starting point for the iteration.
///
/// @param cmp
/// Comparison function.
///
/// @param data
/// Data to pass to comparison function.
///
/// @return
/// A pointer to a rte_bus structure or NULL in case no bus matches
    pub fn rte_bus_find(start: *const rte_bus, cmp: rte_bus_cmp_t,
                        data: *const ::std::os::raw::c_void) -> *mut rte_bus;
}
extern "C" {
    /// Find the registered bus for a particular device.
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    /// Find the registered bus for a given name.
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char)
     -> *mut rte_bus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cfgfile {
    _unused: [u8; 0],
}
/// Configuration file entry
#[repr(C)]
pub struct rte_cfgfile_entry {
    /// < Name
    pub name: [::std::os::raw::c_char; 64usize],
    /// < Value
    pub value: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_rte_cfgfile_entry() {
    assert_eq!(::std::mem::size_of::<rte_cfgfile_entry>() , 320usize , concat
               ! ( "Size of: " , stringify ! ( rte_cfgfile_entry ) ));
    assert_eq! (::std::mem::align_of::<rte_cfgfile_entry>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_cfgfile_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cfgfile_entry ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cfgfile_entry ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cfgfile_entry ) ) . value as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cfgfile_entry ) ,
                "::" , stringify ! ( value ) ));
}
/// Configuration file operation optional arguments
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cfgfile_parameters {
    /// Config file comment character; one of '!', '#', '%', ';', '@'
    pub comment_character: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_cfgfile_parameters() {
    assert_eq!(::std::mem::size_of::<rte_cfgfile_parameters>() , 1usize ,
               concat ! ( "Size of: " , stringify ! ( rte_cfgfile_parameters )
               ));
    assert_eq! (::std::mem::align_of::<rte_cfgfile_parameters>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cfgfile_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cfgfile_parameters ) ) .
                comment_character as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_cfgfile_parameters
                ) , "::" , stringify ! ( comment_character ) ));
}
impl Clone for rte_cfgfile_parameters {
    fn clone(&self) -> Self { *self }
}
pub const CFG_FLAG_GLOBAL_SECTION: _bindgen_ty_21 =
    _bindgen_ty_21::CFG_FLAG_GLOBAL_SECTION;
pub const CFG_FLAG_EMPTY_VALUES: _bindgen_ty_21 =
    _bindgen_ty_21::CFG_FLAG_EMPTY_VALUES;
#[repr(u32)]
/// @{ cfgfile load operation flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    CFG_FLAG_GLOBAL_SECTION = 1,
    CFG_FLAG_EMPTY_VALUES = 2,
}
extern "C" {
    /// Open config file
///
/// @param filename
/// Config file name
/// @param flags
/// Config file flags
/// @return
/// Handle to configuration file on success, NULL otherwise
    pub fn rte_cfgfile_load(filename: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_int) -> *mut rte_cfgfile;
}
extern "C" {
    /// Open config file with specified optional parameters.
///
/// @param filename
/// Config file name
/// @param flags
/// Config file flags
/// @param params
/// Additional configuration attributes.  Must be configured with desired
/// values prior to invoking this API.
/// @return
/// Handle to configuration file on success, NULL otherwise
    pub fn rte_cfgfile_load_with_params(filename:
                                            *const ::std::os::raw::c_char,
                                        flags: ::std::os::raw::c_int,
                                        params: *const rte_cfgfile_parameters)
     -> *mut rte_cfgfile;
}
extern "C" {
    /// Get number of sections in config file
///
/// @param cfg
/// Config file
/// @param sec_name
/// Section name
/// @param length
/// Maximum section name length
/// @return
/// Number of sections
    pub fn rte_cfgfile_num_sections(cfg: *mut rte_cfgfile,
                                    sec_name: *const ::std::os::raw::c_char,
                                    length: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get name of all config file sections.
///
/// Fills in the array sections with the name of all the sections in the file
/// (up to the number of max_sections sections).
///
/// @param cfg
/// Config file
/// @param sections
/// Array containing section names after successful invocation. Each element
/// of this array should be preallocated by the user with at least
/// CFG_NAME_LEN characters.
/// @param max_sections
/// Maximum number of section names to be stored in sections array
/// @return
/// Number of populated sections names
    pub fn rte_cfgfile_sections(cfg: *mut rte_cfgfile,
                                sections: *mut *mut ::std::os::raw::c_char,
                                max_sections: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if given section exists in config file
///
/// @param cfg
/// Config file
/// @param sectionname
/// Section name
/// @return
/// TRUE (value different than 0) if section exists, FALSE (value 0) otherwise
    pub fn rte_cfgfile_has_section(cfg: *mut rte_cfgfile,
                                   sectionname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get number of entries in given config file section
///
/// If multiple sections have the given name this function operates on the
/// first one.
///
/// @param cfg
/// Config file
/// @param sectionname
/// Section name
/// @return
/// Number of entries in section on success, -1 otherwise
    pub fn rte_cfgfile_section_num_entries(cfg: *mut rte_cfgfile,
                                           sectionname:
                                               *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get section entries as key-value pairs
///
/// If multiple sections have the given name this function operates on the
/// first one.
///
/// @param cfg
/// Config file
/// @param sectionname
/// Section name
/// @param entries
/// Pre-allocated array of at least max_entries entries where the section
/// entries are stored as key-value pair after successful invocation
/// @param max_entries
/// Maximum number of section entries to be stored in entries array
/// @return
/// Number of entries populated on success, -1 otherwise
    pub fn rte_cfgfile_section_entries(cfg: *mut rte_cfgfile,
                                       sectionname:
                                           *const ::std::os::raw::c_char,
                                       entries: *mut rte_cfgfile_entry,
                                       max_entries: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get section entries as key-value pairs
///
/// The index of a section is the same as the index of its name in the
/// result of rte_cfgfile_sections. This API can be used when there are
/// multiple sections with the same name.
///
/// @param cfg
/// Config file
/// @param index
/// Section index
/// @param sectionname
/// Pre-allocated string of at least CFG_NAME_LEN characters where the
/// section name is stored after successful invocation.
/// @param entries
/// Pre-allocated array of at least max_entries entries where the section
/// entries are stored as key-value pair after successful invocation
/// @param max_entries
/// Maximum number of section entries to be stored in entries array
/// @return
/// Number of entries populated on success, -1 otherwise
    pub fn rte_cfgfile_section_entries_by_index(cfg: *mut rte_cfgfile,
                                                index: ::std::os::raw::c_int,
                                                sectionname:
                                                    *mut ::std::os::raw::c_char,
                                                entries:
                                                    *mut rte_cfgfile_entry,
                                                max_entries:
                                                    ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get value of the named entry in named config file section
///
/// If multiple sections have the given name this function operates on the
/// first one.
///
/// @param cfg
/// Config file
/// @param sectionname
/// Section name
/// @param entryname
/// Entry name
/// @return
/// Entry value on success, NULL otherwise
    pub fn rte_cfgfile_get_entry(cfg: *mut rte_cfgfile,
                                 sectionname: *const ::std::os::raw::c_char,
                                 entryname: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Check if given entry exists in named config file section
///
/// If multiple sections have the given name this function operates on the
/// first one.
///
/// @param cfg
/// Config file
/// @param sectionname
/// Section name
/// @param entryname
/// Entry name
/// @return
/// TRUE (value different than 0) if entry exists, FALSE (value 0) otherwise
    pub fn rte_cfgfile_has_entry(cfg: *mut rte_cfgfile,
                                 sectionname: *const ::std::os::raw::c_char,
                                 entryname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close config file
///
/// @param cfg
/// Config file
/// @return
/// 0 on success, -1 otherwise
    pub fn rte_cfgfile_close(cfg: *mut rte_cfgfile) -> ::std::os::raw::c_int;
}
/// Type of callback function used by rte_kvargs_process()
pub type arg_handler_t =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_char,
                                               value:
                                                   *const ::std::os::raw::c_char,
                                               opaque:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// A key/value association
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kvargs_pair {
    /// < the name (key) of the association
    pub key: *mut ::std::os::raw::c_char,
    /// < the value associated to that key
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_kvargs_pair() {
    assert_eq!(::std::mem::size_of::<rte_kvargs_pair>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_kvargs_pair ) ));
    assert_eq! (::std::mem::align_of::<rte_kvargs_pair>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_kvargs_pair ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kvargs_pair ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kvargs_pair ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kvargs_pair ) ) . value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kvargs_pair ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for rte_kvargs_pair {
    fn clone(&self) -> Self { *self }
}
/// Store a list of key/value associations
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kvargs {
    /// < copy of the argument string
    pub str: *mut ::std::os::raw::c_char,
    /// < number of entries in the list
    pub count: ::std::os::raw::c_uint,
    /// < list of key/values
    pub pairs: [rte_kvargs_pair; 32usize],
}
#[test]
fn bindgen_test_layout_rte_kvargs() {
    assert_eq!(::std::mem::size_of::<rte_kvargs>() , 528usize , concat ! (
               "Size of: " , stringify ! ( rte_kvargs ) ));
    assert_eq! (::std::mem::align_of::<rte_kvargs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_kvargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kvargs ) ) . str as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kvargs ) , "::" ,
                stringify ! ( str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kvargs ) ) . count as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kvargs ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kvargs ) ) . pairs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kvargs ) , "::" ,
                stringify ! ( pairs ) ));
}
impl Clone for rte_kvargs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Allocate a rte_kvargs and store key/value associations from a string
///
/// The function allocates and fills a rte_kvargs structure from a given
/// string whose format is key1=value1,key2=value2,...
///
/// The structure can be freed with rte_kvargs_free().
///
/// @param args
/// The input string containing the key/value associations
/// @param valid_keys
/// A list of valid keys (table of const char *, the last must be NULL).
/// This argument is ignored if NULL
///
/// @return
/// - A pointer to an allocated rte_kvargs structure on success
/// - NULL on error
    pub fn rte_kvargs_parse(args: *const ::std::os::raw::c_char,
                            valid_keys: *const *const ::std::os::raw::c_char)
     -> *mut rte_kvargs;
}
extern "C" {
    /// Free a rte_kvargs structure
///
/// Free a rte_kvargs structure previously allocated with
/// rte_kvargs_parse().
///
/// @param kvlist
/// The rte_kvargs structure
    pub fn rte_kvargs_free(kvlist: *mut rte_kvargs);
}
extern "C" {
    /// Call a handler function for each key/value matching the key
///
/// For each key/value association that matches the given key, calls the
/// handler function with the for a given arg_name passing the value on the
/// dictionary for that key and a given extra argument. If *kvlist* is NULL
/// function does nothing.
///
/// @param kvlist
/// The rte_kvargs structure
/// @param key_match
/// The key on which the handler should be called, or NULL to process handler
/// on all associations
/// @param handler
/// The function to call for each matching key
/// @param opaque_arg
/// A pointer passed unchanged to the handler
///
/// @return
/// - 0 on success
/// - Negative on error
    pub fn rte_kvargs_process(kvlist: *const rte_kvargs,
                              key_match: *const ::std::os::raw::c_char,
                              handler: arg_handler_t,
                              opaque_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Count the number of associations matching the given key
///
/// @param kvlist
/// The rte_kvargs structure
/// @param key_match
/// The key that should match, or NULL to count all associations
///
/// @return
/// The number of entries
    pub fn rte_kvargs_count(kvlist: *const rte_kvargs,
                            key_match: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
#[repr(u32)]
/// Symmetric Cipher Algorithms
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_cipher_algorithm {
    RTE_CRYPTO_CIPHER_NULL = 1,
    RTE_CRYPTO_CIPHER_3DES_CBC = 2,
    RTE_CRYPTO_CIPHER_3DES_CTR = 3,
    RTE_CRYPTO_CIPHER_3DES_ECB = 4,
    RTE_CRYPTO_CIPHER_AES_CBC = 5,
    RTE_CRYPTO_CIPHER_AES_CTR = 6,
    RTE_CRYPTO_CIPHER_AES_ECB = 7,
    RTE_CRYPTO_CIPHER_AES_F8 = 8,
    RTE_CRYPTO_CIPHER_AES_XTS = 9,
    RTE_CRYPTO_CIPHER_ARC4 = 10,
    RTE_CRYPTO_CIPHER_KASUMI_F8 = 11,
    RTE_CRYPTO_CIPHER_SNOW3G_UEA2 = 12,
    RTE_CRYPTO_CIPHER_ZUC_EEA3 = 13,
    RTE_CRYPTO_CIPHER_DES_CBC = 14,
    RTE_CRYPTO_CIPHER_AES_DOCSISBPI = 15,
    RTE_CRYPTO_CIPHER_DES_DOCSISBPI = 16,
    RTE_CRYPTO_CIPHER_LIST_END = 17,
}
extern "C" {
    #[link_name = "rte_crypto_cipher_algorithm_strings"]
    pub static mut rte_crypto_cipher_algorithm_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
/// Symmetric Cipher Direction
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_cipher_operation {
    RTE_CRYPTO_CIPHER_OP_ENCRYPT = 0,
    RTE_CRYPTO_CIPHER_OP_DECRYPT = 1,
}
extern "C" {
    #[link_name = "rte_crypto_cipher_operation_strings"]
    pub static mut rte_crypto_cipher_operation_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
/// Symmetric Cipher Setup Data.
///
/// This structure contains data relating to Cipher (Encryption and Decryption)
/// use to create a session.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_cipher_xform {
    pub op: rte_crypto_cipher_operation,
    pub algo: rte_crypto_cipher_algorithm,
    pub key: rte_crypto_cipher_xform__bindgen_ty_1,
    /// < Initialisation vector parameters
    pub iv: rte_crypto_cipher_xform__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_cipher_xform__bindgen_ty_1 {
    /// < pointer to key data
    pub data: *mut u8,
    /// < key length in bytes
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_cipher_xform__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_cipher_xform__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_cipher_xform__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_cipher_xform__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform__bindgen_ty_1 ) )
                . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_1 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform__bindgen_ty_1 ) )
                . length as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_1 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_cipher_xform__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_cipher_xform__bindgen_ty_2 {
    pub offset: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_cipher_xform__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_cipher_xform__bindgen_ty_2>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_cipher_xform__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_cipher_xform__bindgen_ty_2>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform__bindgen_ty_2 ) )
                . offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_2 ) , "::" , stringify ! (
                offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform__bindgen_ty_2 ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_cipher_xform__bindgen_ty_2 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_cipher_xform__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_cipher_xform() {
    assert_eq!(::std::mem::size_of::<rte_crypto_cipher_xform>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_crypto_cipher_xform ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_cipher_xform>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_crypto_cipher_xform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform ) ) . op as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_cipher_xform
                ) , "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform ) ) . algo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_cipher_xform
                ) , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform ) ) . key as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_cipher_xform
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_cipher_xform ) ) . iv as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_cipher_xform
                ) , "::" , stringify ! ( iv ) ));
}
impl Clone for rte_crypto_cipher_xform {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Symmetric Authentication / Hash Algorithms
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_auth_algorithm {
    RTE_CRYPTO_AUTH_NULL = 1,
    RTE_CRYPTO_AUTH_AES_CBC_MAC = 2,
    RTE_CRYPTO_AUTH_AES_CMAC = 3,
    RTE_CRYPTO_AUTH_AES_GMAC = 4,
    RTE_CRYPTO_AUTH_AES_XCBC_MAC = 5,
    RTE_CRYPTO_AUTH_KASUMI_F9 = 6,
    RTE_CRYPTO_AUTH_MD5 = 7,
    RTE_CRYPTO_AUTH_MD5_HMAC = 8,
    RTE_CRYPTO_AUTH_SHA1 = 9,
    RTE_CRYPTO_AUTH_SHA1_HMAC = 10,
    RTE_CRYPTO_AUTH_SHA224 = 11,
    RTE_CRYPTO_AUTH_SHA224_HMAC = 12,
    RTE_CRYPTO_AUTH_SHA256 = 13,
    RTE_CRYPTO_AUTH_SHA256_HMAC = 14,
    RTE_CRYPTO_AUTH_SHA384 = 15,
    RTE_CRYPTO_AUTH_SHA384_HMAC = 16,
    RTE_CRYPTO_AUTH_SHA512 = 17,
    RTE_CRYPTO_AUTH_SHA512_HMAC = 18,
    RTE_CRYPTO_AUTH_SNOW3G_UIA2 = 19,
    RTE_CRYPTO_AUTH_ZUC_EIA3 = 20,
    RTE_CRYPTO_AUTH_LIST_END = 21,
}
extern "C" {
    #[link_name = "rte_crypto_auth_algorithm_strings"]
    pub static mut rte_crypto_auth_algorithm_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
/// Symmetric Authentication / Hash Operations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_auth_operation {
    RTE_CRYPTO_AUTH_OP_VERIFY = 0,
    RTE_CRYPTO_AUTH_OP_GENERATE = 1,
}
extern "C" {
    #[link_name = "rte_crypto_auth_operation_strings"]
    pub static mut rte_crypto_auth_operation_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
/// Authentication / Hash transform data.
///
/// This structure contains data relating to an authentication/hash crypto
/// transforms. The fields op, algo and digest_length are common to all
/// authentication transforms and MUST be set.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_auth_xform {
    pub op: rte_crypto_auth_operation,
    pub algo: rte_crypto_auth_algorithm,
    pub key: rte_crypto_auth_xform__bindgen_ty_1,
    /// < Initialisation vector parameters
    pub iv: rte_crypto_auth_xform__bindgen_ty_2,
    pub digest_length: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_auth_xform__bindgen_ty_1 {
    /// < pointer to key data
    pub data: *mut u8,
    /// < key length in bytes
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_auth_xform__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_auth_xform__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_auth_xform__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_auth_xform__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform__bindgen_ty_1 ) ) .
                data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_1 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform__bindgen_ty_1 ) ) .
                length as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_1 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_auth_xform__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_auth_xform__bindgen_ty_2 {
    pub offset: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_auth_xform__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_auth_xform__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_auth_xform__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_auth_xform__bindgen_ty_2>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform__bindgen_ty_2 ) ) .
                offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_2 ) , "::" , stringify ! (
                offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform__bindgen_ty_2 ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_auth_xform__bindgen_ty_2 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_auth_xform__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_auth_xform() {
    assert_eq!(::std::mem::size_of::<rte_crypto_auth_xform>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rte_crypto_auth_xform )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_auth_xform>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_crypto_auth_xform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform ) ) . op as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_auth_xform )
                , "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform ) ) . algo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_auth_xform )
                , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform ) ) . key as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_auth_xform )
                , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform ) ) . iv as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_auth_xform )
                , "::" , stringify ! ( iv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_auth_xform ) ) . digest_length
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_auth_xform )
                , "::" , stringify ! ( digest_length ) ));
}
impl Clone for rte_crypto_auth_xform {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Symmetric AEAD Algorithms
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_aead_algorithm {
    RTE_CRYPTO_AEAD_AES_CCM = 1,
    RTE_CRYPTO_AEAD_AES_GCM = 2,
    RTE_CRYPTO_AEAD_LIST_END = 3,
}
extern "C" {
    #[link_name = "rte_crypto_aead_algorithm_strings"]
    pub static mut rte_crypto_aead_algorithm_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
/// Symmetric AEAD Operations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_aead_operation {
    RTE_CRYPTO_AEAD_OP_ENCRYPT = 0,
    RTE_CRYPTO_AEAD_OP_DECRYPT = 1,
}
extern "C" {
    #[link_name = "rte_crypto_aead_operation_strings"]
    pub static mut rte_crypto_aead_operation_strings:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_aead_xform {
    pub op: rte_crypto_aead_operation,
    pub algo: rte_crypto_aead_algorithm,
    pub key: rte_crypto_aead_xform__bindgen_ty_1,
    /// < Initialisation vector parameters
    pub iv: rte_crypto_aead_xform__bindgen_ty_2,
    pub digest_length: u16,
    pub aad_length: u16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_aead_xform__bindgen_ty_1 {
    /// < pointer to key data
    pub data: *mut u8,
    /// < key length in bytes
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_aead_xform__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_aead_xform__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_aead_xform__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_aead_xform__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform__bindgen_ty_1 ) ) .
                data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_1 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform__bindgen_ty_1 ) ) .
                length as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_1 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_aead_xform__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_aead_xform__bindgen_ty_2 {
    pub offset: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_aead_xform__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_aead_xform__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_aead_xform__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_aead_xform__bindgen_ty_2>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform__bindgen_ty_2 ) ) .
                offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_2 ) , "::" , stringify ! (
                offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform__bindgen_ty_2 ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_aead_xform__bindgen_ty_2 ) , "::" , stringify ! (
                length ) ));
}
impl Clone for rte_crypto_aead_xform__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_aead_xform() {
    assert_eq!(::std::mem::size_of::<rte_crypto_aead_xform>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rte_crypto_aead_xform )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_aead_xform>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_crypto_aead_xform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . op as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . algo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . key as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . iv as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( iv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . digest_length
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( digest_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_aead_xform ) ) . aad_length as
                * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_aead_xform )
                , "::" , stringify ! ( aad_length ) ));
}
impl Clone for rte_crypto_aead_xform {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Crypto transformation types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_sym_xform_type {
    RTE_CRYPTO_SYM_XFORM_NOT_SPECIFIED = 0,
    RTE_CRYPTO_SYM_XFORM_AUTH = 1,
    RTE_CRYPTO_SYM_XFORM_CIPHER = 2,
    RTE_CRYPTO_SYM_XFORM_AEAD = 3,
}
/// Symmetric crypto transform structure.
///
/// This is used to specify the crypto transforms required, multiple transforms
/// can be chained together to specify a chain transforms such as authentication
/// then cipher, or cipher then authentication. Each transform structure can
/// hold a single transform, the type field is used to specify which transform
/// is contained within the union
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_xform {
    pub next: *mut rte_crypto_sym_xform,
    pub type_: rte_crypto_sym_xform_type,
    pub __bindgen_anon_1: rte_crypto_sym_xform__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_xform__bindgen_ty_1 {
    pub auth: __BindgenUnionField<rte_crypto_auth_xform>,
    pub cipher: __BindgenUnionField<rte_crypto_cipher_xform>,
    pub aead: __BindgenUnionField<rte_crypto_aead_xform>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_xform__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_xform__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_sym_xform__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_xform__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_xform__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_xform__bindgen_ty_1 ) ) .
                auth as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_xform__bindgen_ty_1 ) , "::" , stringify ! (
                auth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_xform__bindgen_ty_1 ) ) .
                cipher as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_xform__bindgen_ty_1 ) , "::" , stringify ! (
                cipher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_xform__bindgen_ty_1 ) ) .
                aead as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_xform__bindgen_ty_1 ) , "::" , stringify ! (
                aead ) ));
}
impl Clone for rte_crypto_sym_xform__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_xform() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_xform>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( rte_crypto_sym_xform )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_xform>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_crypto_sym_xform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_xform ) ) . next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_sym_xform )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_xform ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_sym_xform )
                , "::" , stringify ! ( type_ ) ));
}
impl Clone for rte_crypto_sym_xform {
    fn clone(&self) -> Self { *self }
}
/// Cryptodev symmetric crypto session
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_sym_session {
    pub sess_private_data: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_sym_session() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_sym_session>() , 0usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_sym_session ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_sym_session>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_sym_session )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_sym_session ) ) .
                sess_private_data as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_session ) , "::" , stringify ! (
                sess_private_data ) ));
}
impl Clone for rte_cryptodev_sym_session {
    fn clone(&self) -> Self { *self }
}
/// Symmetric Cryptographic Operation.
///
/// This structure contains data relating to performing symmetric cryptographic
/// processing on a referenced mbuf data buffer.
///
/// When a symmetric crypto operation is enqueued with the device for processing
/// it must have a valid *rte_mbuf* structure attached, via m_src parameter,
/// which contains the source data which the crypto operation is to be performed
/// on.
/// While the mbuf is in use by a crypto operation no part of the mbuf should be
/// changed by the application as the device may read or write to any part of the
/// mbuf. In the case of hardware crypto devices some or all of the mbuf
/// may be DMAed in and out of the device, so writing over the original data,
/// though only the part specified by the rte_crypto_sym_op for transformation
/// will be changed.
/// Out-of-place (OOP) operation, where the source mbuf is different to the
/// destination mbuf, is a special case. Data will be copied from m_src to m_dst.
/// The part copied includes all the parts of the source mbuf that will be
/// operated on, based on the cipher.data.offset+cipher.data.length and
/// auth.data.offset+auth.data.length values in the rte_crypto_sym_op. The part
/// indicated by the cipher parameters will be transformed, any extra data around
/// this indicated by the auth parameters will be copied unchanged from source to
/// destination mbuf.
/// Also in OOP operation the cipher.data.offset and auth.data.offset apply to
/// both source and destination mbufs. As these offsets are relative to the
/// data_off parameter in each mbuf this can result in the data written to the
/// destination buffer being at a different alignment, relative to buffer start,
/// to the data in the source buffer.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op {
    /// < source mbuf
    pub m_src: *mut rte_mbuf,
    /// < destination mbuf
    pub m_dst: *mut rte_mbuf,
    pub __bindgen_anon_1: rte_crypto_sym_op__bindgen_ty_1,
    pub __bindgen_anon_2: rte_crypto_sym_op__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_1 {
    pub session: __BindgenUnionField<*mut rte_cryptodev_sym_session>,
    pub xform: __BindgenUnionField<*mut rte_crypto_sym_xform>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_sym_op__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_op__bindgen_ty_1 ) ) .
                session as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_1 ) , "::" , stringify ! (
                session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_op__bindgen_ty_1 ) ) .
                xform as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_1 ) , "::" , stringify ! ( xform
                ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2 {
    pub aead: __BindgenUnionField<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 {
    /// < Data offsets and length for AEAD
    pub data: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    /// < Digest parameters
    pub digest: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub aad: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub offset: u32,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ) . offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ) . length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( length ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub data: *mut u8,
    pub phys_addr: phys_addr_t,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ) . phys_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                , "::" , stringify ! ( phys_addr ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    pub data: *mut u8,
    /// < physical address
    pub phys_addr: phys_addr_t,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
                ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
                ) . phys_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 )
                , "::" , stringify ! ( phys_addr ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1
                ) ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1
                ) ) . digest as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( digest ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1
                ) ) . aad as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( aad ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 {
    pub cipher: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    pub auth: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    /// < Data offsets and length for ciphering
    pub data: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub offset: u32,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( length ) ));
}
impl Clone for
 rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 )
                ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( data ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 {
    pub data: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    /// < Digest parameters
    pub digest: rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub offset: u32,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
                ) ) . offset as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
                ) ) . length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1
                ) , "::" , stringify ! ( length ) ));
}
impl Clone for
 rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 {
    pub data: *mut u8,
    pub phys_addr: phys_addr_t,
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
                ) ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
                ) ) . phys_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2
                ) , "::" , stringify ! ( phys_addr ) ));
}
impl Clone for
 rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
                ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
                ) . digest as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 )
                , "::" , stringify ! ( digest ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2
                ) ) . cipher as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2
                ) ) . auth as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( auth ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op__bindgen_ty_2>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_sym_op__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_op__bindgen_ty_2 ) ) .
                aead as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_sym_op__bindgen_ty_2 ) , "::" , stringify ! ( aead
                ) ));
}
impl Clone for rte_crypto_sym_op__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_sym_op() {
    assert_eq!(::std::mem::size_of::<rte_crypto_sym_op>() , 64usize , concat !
               ( "Size of: " , stringify ! ( rte_crypto_sym_op ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_sym_op>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_crypto_sym_op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_op ) ) . m_src as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_sym_op ) ,
                "::" , stringify ! ( m_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_sym_op ) ) . m_dst as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_sym_op ) ,
                "::" , stringify ! ( m_dst ) ));
}
impl Clone for rte_crypto_sym_op {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Crypto operation types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_op_type {
    RTE_CRYPTO_OP_TYPE_UNDEFINED = 0,
    RTE_CRYPTO_OP_TYPE_SYMMETRIC = 1,
}
#[repr(u32)]
/// Status of crypto operation
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_op_status {
    RTE_CRYPTO_OP_STATUS_SUCCESS = 0,
    RTE_CRYPTO_OP_STATUS_NOT_PROCESSED = 1,
    RTE_CRYPTO_OP_STATUS_AUTH_FAILED = 2,
    RTE_CRYPTO_OP_STATUS_INVALID_SESSION = 3,
    RTE_CRYPTO_OP_STATUS_INVALID_ARGS = 4,
    RTE_CRYPTO_OP_STATUS_ERROR = 5,
}
#[repr(u32)]
/// Crypto operation session type. This is used to specify whether a crypto
/// operation has session structure attached for immutable parameters or if all
/// operation information is included in the operation data structure.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_crypto_op_sess_type {
    RTE_CRYPTO_OP_WITH_SESSION = 0,
    RTE_CRYPTO_OP_SESSIONLESS = 1,
}
/// Cryptographic Operation.
///
/// This structure contains data relating to performing cryptographic
/// operations. This operation structure is used to contain any operation which
/// is supported by the cryptodev API, PMDs should check the type parameter to
/// verify that the operation is a support function of the device. Crypto
/// operations are enqueued and dequeued in crypto PMDs using the
/// rte_cryptodev_enqueue_burst() / rte_cryptodev_dequeue_burst() .
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_op {
    pub type_: u8,
    pub status: u8,
    pub sess_type: u8,
    pub reserved: [u8; 5usize],
    pub mempool: *mut rte_mempool,
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_crypto_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_op__bindgen_ty_1 {
    pub sym: __BindgenUnionField<[rte_crypto_sym_op; 0usize]>,
    pub bindgen_union_field: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_crypto_op__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_crypto_op__bindgen_ty_1>() , 0usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_crypto_op__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_op__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_crypto_op__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op__bindgen_ty_1 ) ) . sym as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_op__bindgen_ty_1 ) , "::" , stringify ! ( sym ) ));
}
impl Clone for rte_crypto_op__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_crypto_op() {
    assert_eq!(::std::mem::size_of::<rte_crypto_op>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_crypto_op ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_op>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_crypto_op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . status as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . sess_type as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( sess_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . reserved as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . mempool as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( mempool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op ) ) . phys_addr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_op ) , "::"
                , stringify ! ( phys_addr ) ));
}
impl Clone for rte_crypto_op {
    fn clone(&self) -> Self { *self }
}
/// Private data structure belonging to a crypto symmetric operation pool.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_op_pool_private {
    pub type_: rte_crypto_op_type,
    pub priv_size: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_op_pool_private() {
    assert_eq!(::std::mem::size_of::<rte_crypto_op_pool_private>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_crypto_op_pool_private ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_op_pool_private>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_crypto_op_pool_private )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op_pool_private ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_op_pool_private ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_op_pool_private ) ) .
                priv_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_op_pool_private ) , "::" , stringify ! ( priv_size
                ) ));
}
impl Clone for rte_crypto_op_pool_private {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Creates a crypto operation pool
///
/// @param	name		pool name
/// @param	type		crypto operation type, use
/// RTE_CRYPTO_OP_TYPE_UNDEFINED for a pool which
/// supports all operation types
/// @param	nb_elts		number of elements in pool
/// @param	cache_size	Number of elements to cache on lcore, see
/// *rte_mempool_create* for further details about
/// cache size
/// @param	priv_size	Size of private data to allocate with each
/// operation
/// @param	socket_id	Socket to allocate memory on
///
/// @return
/// - On success pointer to mempool
/// - On failure NULL
    pub fn rte_crypto_op_pool_create(name: *const ::std::os::raw::c_char,
                                     type_: rte_crypto_op_type,
                                     nb_elts: ::std::os::raw::c_uint,
                                     cache_size: ::std::os::raw::c_uint,
                                     priv_size: u16,
                                     socket_id: ::std::os::raw::c_int)
     -> *mut rte_mempool;
}
#[repr(u32)]
/// Type of generic device
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_devtype {
    RTE_DEVTYPE_WHITELISTED_PCI = 0,
    RTE_DEVTYPE_BLACKLISTED_PCI = 1,
    RTE_DEVTYPE_VIRTUAL = 2,
}
/// Structure that stores a device given by the user with its arguments
///
/// A user device is a physical or a virtual device given by the user to
/// the DPDK application at startup through command line arguments.
///
/// The structure stores the configuration of the device, its PCI
/// identifier if it's a PCI device or the driver name if it's a virtual
/// device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_devargs {
    /// Next in list.
    pub next: rte_devargs__bindgen_ty_1,
    /// Type of device.
    pub type_: rte_devtype,
    /// Device policy.
    pub policy: rte_dev_policy,
    /// Bus handle for the device.
    pub bus: *mut rte_bus,
    /// Name of the device.
    pub name: [::std::os::raw::c_char; 32usize],
    /// Arguments string as given by user or "" for no argument.
    pub args: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_devargs__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_devargs__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_devargs__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_devargs__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_devargs__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_devargs__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for rte_devargs__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_devargs() {
    assert_eq!(::std::mem::size_of::<rte_devargs>() , 72usize , concat ! (
               "Size of: " , stringify ! ( rte_devargs ) ));
    assert_eq! (::std::mem::align_of::<rte_devargs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_devargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . type_ as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . policy as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( policy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . bus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . name as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs ) ) . args as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs ) , "::" ,
                stringify ! ( args ) ));
}
impl Clone for rte_devargs {
    fn clone(&self) -> Self { *self }
}
/// user device double-linked queue type definition
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_devargs_list {
    pub tqh_first: *mut rte_devargs,
    pub tqh_last: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs_list() {
    assert_eq!(::std::mem::size_of::<rte_devargs_list>() , 16usize , concat !
               ( "Size of: " , stringify ! ( rte_devargs_list ) ));
    assert_eq! (::std::mem::align_of::<rte_devargs_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_devargs_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_devargs_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_devargs_list {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "devargs_list"]
    pub static mut devargs_list: rte_devargs_list;
}
extern "C" {
    /// Parse a devargs string.
///
/// For PCI devices, the format of arguments string is "PCI_ADDR" or
/// "PCI_ADDR,key=val,key2=val2,...". Examples: "08:00.1", "0000:5:00.0",
/// "04:00.0,arg=val".
///
/// For virtual devices, the format of arguments string is "DRIVER_NAME*"
/// or "DRIVER_NAME*,key=val,key2=val2,...". Examples: "net_ring",
/// "net_ring0", "net_pmdAnything,arg=0:arg2=1".
///
/// The function parses the arguments string to get driver name and driver
/// arguments.
///
/// @param devargs_str
/// The arguments as given by the user.
/// @param drvname
/// The pointer to the string to store parsed driver name.
/// @param drvargs
/// The pointer to the string to store parsed driver arguments.
///
/// @return
/// - 0 on success
/// - A negative value on error
    pub fn rte_eal_parse_devargs_str(devargs_str:
                                         *const ::std::os::raw::c_char,
                                     drvname:
                                         *mut *mut ::std::os::raw::c_char,
                                     drvargs:
                                         *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Parse a device string.
///
/// Verify that a bus is capable of handling the device passed
/// in argument. Store which bus will handle the device, its name
/// and the eventual device parameters.
///
/// @param dev
/// The device declaration string.
/// @param da
/// The devargs structure holding the device information.
///
/// @return
/// - 0 on success.
/// - Negative errno on error.
    pub fn rte_eal_devargs_parse(dev: *const ::std::os::raw::c_char,
                                 da: *mut rte_devargs)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Insert an rte_devargs in the global list.
///
/// @param da
/// The devargs structure to insert.
///
/// @return
/// - 0 on success
/// - Negative on error.
    pub fn rte_eal_devargs_insert(da: *mut rte_devargs)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a device to the user device list
///
/// For PCI devices, the format of arguments string is "PCI_ADDR" or
/// "PCI_ADDR,key=val,key2=val2,...". Examples: "08:00.1", "0000:5:00.0",
/// "04:00.0,arg=val".
///
/// For virtual devices, the format of arguments string is "DRIVER_NAME*"
/// or "DRIVER_NAME*,key=val,key2=val2,...". Examples: "net_ring",
/// "net_ring0", "net_pmdAnything,arg=0:arg2=1". The validity of the
/// driver name is not checked by this function, it is done when probing
/// the drivers.
///
/// @param devtype
/// The type of the device.
/// @param devargs_str
/// The arguments as given by the user.
///
/// @return
/// - 0 on success
/// - A negative value on error
    pub fn rte_eal_devargs_add(devtype: rte_devtype,
                               devargs_str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a device from the user device list.
/// Its resources are freed.
/// If the devargs cannot be found, nothing happens.
///
/// @param busname
/// bus name of the devargs to remove.
///
/// @param devname
/// device name of the devargs to remove.
///
/// @return
/// 0 on success.
/// <0 on error.
/// >0 if the devargs was not within the user device list.
    pub fn rte_eal_devargs_remove(busname: *const ::std::os::raw::c_char,
                                  devname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Count the number of user devices of a specified type
///
/// @param devtype
/// The type of the devices to counted.
///
/// @return
/// The number of devices.
    pub fn rte_eal_devargs_type_count(devtype: rte_devtype)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// This function dumps the list of user device and their arguments.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_eal_devargs_dump(f: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vdev_device {
    /// < Next attached vdev
    pub next: rte_vdev_device__bindgen_ty_1,
    /// < Inherit core device
    pub device: rte_device,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vdev_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_vdev_device,
    pub tqe_prev: *mut *mut rte_vdev_device,
}
#[test]
fn bindgen_test_layout_rte_vdev_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_vdev_device__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_vdev_device__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_vdev_device__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_vdev_device__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_device__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_vdev_device__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_device__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_vdev_device__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for rte_vdev_device__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_vdev_device() {
    assert_eq!(::std::mem::size_of::<rte_vdev_device>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rte_vdev_device ) ));
    assert_eq! (::std::mem::align_of::<rte_vdev_device>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_vdev_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_device ) ) . next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_device ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_device ) ) . device as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_device ) ,
                "::" , stringify ! ( device ) ));
}
impl Clone for rte_vdev_device {
    fn clone(&self) -> Self { *self }
}
/// Double linked list of virtual device drivers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vdev_driver_list {
    pub tqh_first: *mut rte_vdev_driver,
    pub tqh_last: *mut *mut rte_vdev_driver,
}
#[test]
fn bindgen_test_layout_vdev_driver_list() {
    assert_eq!(::std::mem::size_of::<vdev_driver_list>() , 16usize , concat !
               ( "Size of: " , stringify ! ( vdev_driver_list ) ));
    assert_eq! (::std::mem::align_of::<vdev_driver_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( vdev_driver_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_driver_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_driver_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vdev_driver_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vdev_driver_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for vdev_driver_list {
    fn clone(&self) -> Self { *self }
}
/// Probe function called for each virtual device driver once.
pub type rte_vdev_probe_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_vdev_device)
                              -> ::std::os::raw::c_int>;
/// Remove function called for each virtual device driver once.
pub type rte_vdev_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_vdev_device)
                              -> ::std::os::raw::c_int>;
/// A virtual device driver abstraction.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vdev_driver {
    /// < Next in list.
    pub next: rte_vdev_driver__bindgen_ty_1,
    /// < Inherited general driver.
    pub driver: rte_driver,
    /// < Virtual device probe function.
    pub probe: rte_vdev_probe_t,
    /// < Virtual device remove function.
    pub remove: rte_vdev_remove_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vdev_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_vdev_driver,
    pub tqe_prev: *mut *mut rte_vdev_driver,
}
#[test]
fn bindgen_test_layout_rte_vdev_driver__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_vdev_driver__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_vdev_driver__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_vdev_driver__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_vdev_driver__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_vdev_driver__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_vdev_driver__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for rte_vdev_driver__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_vdev_driver() {
    assert_eq!(::std::mem::size_of::<rte_vdev_driver>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rte_vdev_driver ) ));
    assert_eq! (::std::mem::align_of::<rte_vdev_driver>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_vdev_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver ) ) . next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_driver ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver ) ) . driver as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_driver ) ,
                "::" , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver ) ) . probe as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_driver ) ,
                "::" , stringify ! ( probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vdev_driver ) ) . remove as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vdev_driver ) ,
                "::" , stringify ! ( remove ) ));
}
impl Clone for rte_vdev_driver {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Register a virtual device driver.
///
/// @param driver
/// A pointer to a rte_vdev_driver structure describing the driver
/// to be registered.
    pub fn rte_vdev_register(driver: *mut rte_vdev_driver);
}
extern "C" {
    /// Unregister a virtual device driver.
///
/// @param driver
/// A pointer to a rte_vdev_driver structure describing the driver
/// to be unregistered.
    pub fn rte_vdev_unregister(driver: *mut rte_vdev_driver);
}
extern "C" {
    #[link_name = "rte_cyptodev_names"]
    pub static mut rte_cyptodev_names: *mut *const ::std::os::raw::c_char;
}
/// Crypto parameters range description
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_crypto_param_range {
    /// < minimum size
    pub min: u16,
    /// < maximum size
    pub max: u16,
    pub increment: u16,
}
#[test]
fn bindgen_test_layout_rte_crypto_param_range() {
    assert_eq!(::std::mem::size_of::<rte_crypto_param_range>() , 6usize ,
               concat ! ( "Size of: " , stringify ! ( rte_crypto_param_range )
               ));
    assert_eq! (::std::mem::align_of::<rte_crypto_param_range>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_crypto_param_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_param_range ) ) . min as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_param_range
                ) , "::" , stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_param_range ) ) . max as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_param_range
                ) , "::" , stringify ! ( max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_param_range ) ) . increment as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_crypto_param_range
                ) , "::" , stringify ! ( increment ) ));
}
impl Clone for rte_crypto_param_range {
    fn clone(&self) -> Self { *self }
}
/// Symmetric Crypto Capability
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_symmetric_capability {
    pub xform_type: rte_crypto_sym_xform_type,
    pub __bindgen_anon_1: rte_cryptodev_symmetric_capability__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_symmetric_capability__bindgen_ty_1 {
    pub auth: __BindgenUnionField<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1>,
    pub cipher: __BindgenUnionField<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2>,
    pub aead: __BindgenUnionField<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1 {
    pub algo: rte_crypto_auth_algorithm,
    pub block_size: u16,
    pub key_size: rte_crypto_param_range,
    pub digest_size: rte_crypto_param_range,
    pub aad_size: rte_crypto_param_range,
    pub iv_size: rte_crypto_param_range,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . algo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . block_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( block_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . key_size as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . digest_size as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( digest_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . aad_size as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( aad_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) ) . iv_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( iv_size ) ));
}
impl Clone for rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2 {
    pub algo: rte_crypto_cipher_algorithm,
    pub block_size: u16,
    pub key_size: rte_crypto_param_range,
    pub iv_size: rte_crypto_param_range,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2>()
               , 20usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) ) . algo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) ) . block_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) , "::" , stringify ! ( block_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) ) . key_size as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) , "::" , stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) ) . iv_size as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
                ) , "::" , stringify ! ( iv_size ) ));
}
impl Clone for rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_2
 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3 {
    pub algo: rte_crypto_aead_algorithm,
    pub block_size: u16,
    pub key_size: rte_crypto_param_range,
    pub digest_size: rte_crypto_param_range,
    pub aad_size: rte_crypto_param_range,
    pub iv_size: rte_crypto_param_range,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . algo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( algo ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . block_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( block_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . key_size as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( key_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . digest_size as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( digest_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . aad_size as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( aad_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) ) . iv_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
                ) , "::" , stringify ! ( iv_size ) ));
}
impl Clone for rte_cryptodev_symmetric_capability__bindgen_ty_1__bindgen_ty_3
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_cryptodev_symmetric_capability__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_symmetric_capability__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_symmetric_capability__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_symmetric_capability__bindgen_ty_1
                ) ) . auth as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1 ) , "::" ,
                stringify ! ( auth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_symmetric_capability__bindgen_ty_1
                ) ) . cipher as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1 ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_symmetric_capability__bindgen_ty_1
                ) ) . aead as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability__bindgen_ty_1 ) , "::" ,
                stringify ! ( aead ) ));
}
impl Clone for rte_cryptodev_symmetric_capability__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_cryptodev_symmetric_capability() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_symmetric_capability>() ,
               36usize , concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_symmetric_capability
               ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_symmetric_capability>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_symmetric_capability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_symmetric_capability ) ) .
                xform_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_symmetric_capability ) , "::" , stringify ! (
                xform_type ) ));
}
impl Clone for rte_cryptodev_symmetric_capability {
    fn clone(&self) -> Self { *self }
}
/// Structure used to capture a capability of a crypto device
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_capabilities {
    pub op: rte_crypto_op_type,
    pub __bindgen_anon_1: rte_cryptodev_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_capabilities__bindgen_ty_1 {
    pub sym: __BindgenUnionField<rte_cryptodev_symmetric_capability>,
    pub bindgen_union_field: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_rte_cryptodev_capabilities__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_capabilities__bindgen_ty_1>()
               , 36usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_capabilities__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_capabilities__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_capabilities__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_cryptodev_capabilities__bindgen_ty_1 ) )
                . sym as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_capabilities__bindgen_ty_1 ) , "::" , stringify
                ! ( sym ) ));
}
impl Clone for rte_cryptodev_capabilities__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_cryptodev_capabilities() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_capabilities>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_capabilities ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_capabilities>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_capabilities )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_capabilities ) ) . op as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_capabilities ) , "::" , stringify ! ( op ) ));
}
impl Clone for rte_cryptodev_capabilities {
    fn clone(&self) -> Self { *self }
}
/// Structure used to describe crypto algorithms
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_sym_capability_idx {
    pub type_: rte_crypto_sym_xform_type,
    pub algo: rte_cryptodev_sym_capability_idx__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_sym_capability_idx__bindgen_ty_1 {
    pub cipher: __BindgenUnionField<rte_crypto_cipher_algorithm>,
    pub auth: __BindgenUnionField<rte_crypto_auth_algorithm>,
    pub aead: __BindgenUnionField<rte_crypto_aead_algorithm>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_sym_capability_idx__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_sym_capability_idx__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_sym_capability_idx__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_sym_capability_idx__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_sym_capability_idx__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_sym_capability_idx__bindgen_ty_1 )
                ) . cipher as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_capability_idx__bindgen_ty_1 ) , "::" ,
                stringify ! ( cipher ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_sym_capability_idx__bindgen_ty_1 )
                ) . auth as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_capability_idx__bindgen_ty_1 ) , "::" ,
                stringify ! ( auth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_cryptodev_sym_capability_idx__bindgen_ty_1 )
                ) . aead as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_capability_idx__bindgen_ty_1 ) , "::" ,
                stringify ! ( aead ) ));
}
impl Clone for rte_cryptodev_sym_capability_idx__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_cryptodev_sym_capability_idx() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_sym_capability_idx>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_sym_capability_idx )
               ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_sym_capability_idx>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_sym_capability_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_sym_capability_idx ) ) .
                type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_capability_idx ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_sym_capability_idx ) ) .
                algo as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_sym_capability_idx ) , "::" , stringify ! ( algo
                ) ));
}
impl Clone for rte_cryptodev_sym_capability_idx {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Provide capabilities available for defined device and algorithm
///
/// @param	dev_id		The identifier of the device.
/// @param	idx		Description of crypto algorithms.
///
/// @return
/// - Return description of the symmetric crypto capability if exist.
/// - Return NULL if the capability not exist.
    pub fn rte_cryptodev_sym_capability_get(dev_id: u8,
                                            idx:
                                                *const rte_cryptodev_sym_capability_idx)
     -> *const rte_cryptodev_symmetric_capability;
}
extern "C" {
    /// Check if key size and initial vector are supported
/// in crypto cipher capability
///
/// @param	capability	Description of the symmetric crypto capability.
/// @param	key_size	Cipher key size.
/// @param	iv_size		Cipher initial vector size.
///
/// @return
/// - Return 0 if the parameters are in range of the capability.
/// - Return -1 if the parameters are out of range of the capability.
    pub fn rte_cryptodev_sym_capability_check_cipher(capability:
                                                         *const rte_cryptodev_symmetric_capability,
                                                     key_size: u16,
                                                     iv_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if key size and initial vector are supported
/// in crypto auth capability
///
/// @param	capability	Description of the symmetric crypto capability.
/// @param	key_size	Auth key size.
/// @param	digest_size	Auth digest size.
/// @param	iv_size		Auth initial vector size.
///
/// @return
/// - Return 0 if the parameters are in range of the capability.
/// - Return -1 if the parameters are out of range of the capability.
    pub fn rte_cryptodev_sym_capability_check_auth(capability:
                                                       *const rte_cryptodev_symmetric_capability,
                                                   key_size: u16,
                                                   digest_size: u16,
                                                   iv_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if key, digest, AAD and initial vector sizes are supported
/// in crypto AEAD capability
///
/// @param	capability	Description of the symmetric crypto capability.
/// @param	key_size	AEAD key size.
/// @param	digest_size	AEAD digest size.
/// @param	aad_size	AEAD AAD size.
/// @param	iv_size		AEAD IV size.
///
/// @return
/// - Return 0 if the parameters are in range of the capability.
/// - Return -1 if the parameters are out of range of the capability.
    pub fn rte_cryptodev_sym_capability_check_aead(capability:
                                                       *const rte_cryptodev_symmetric_capability,
                                                   key_size: u16,
                                                   digest_size: u16,
                                                   aad_size: u16,
                                                   iv_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Provide the cipher algorithm enum, given an algorithm string
///
/// @param	algo_enum	A pointer to the cipher algorithm
/// enum to be filled
/// @param	algo_string	Authentication algo string
///
/// @return
/// - Return -1 if string is not valid
/// - Return 0 is the string is valid
    pub fn rte_cryptodev_get_cipher_algo_enum(algo_enum:
                                                  *mut rte_crypto_cipher_algorithm,
                                              algo_string:
                                                  *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Provide the authentication algorithm enum, given an algorithm string
///
/// @param	algo_enum	A pointer to the authentication algorithm
/// enum to be filled
/// @param	algo_string	Authentication algo string
///
/// @return
/// - Return -1 if string is not valid
/// - Return 0 is the string is valid
    pub fn rte_cryptodev_get_auth_algo_enum(algo_enum:
                                                *mut rte_crypto_auth_algorithm,
                                            algo_string:
                                                *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Provide the AEAD algorithm enum, given an algorithm string
///
/// @param	algo_enum	A pointer to the AEAD algorithm
/// enum to be filled
/// @param	algo_string	AEAD algorithm string
///
/// @return
/// - Return -1 if string is not valid
/// - Return 0 is the string is valid
    pub fn rte_cryptodev_get_aead_algo_enum(algo_enum:
                                                *mut rte_crypto_aead_algorithm,
                                            algo_string:
                                                *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the name of a crypto device feature flag
///
/// @param	flag	The mask describing the flag.
///
/// @return
/// The name of this flag, or NULL if it's not a valid feature flag.
    pub fn rte_cryptodev_get_feature_name(flag: u64)
     -> *const ::std::os::raw::c_char;
}
/// Crypto device information
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_info {
    /// < Driver name.
    pub driver_name: *const ::std::os::raw::c_char,
    /// < Driver identifier
    pub driver_id: u8,
    /// < PCI information.
    pub pci_dev: *mut rte_pci_device,
    /// < Feature flags
    pub feature_flags: u64,
    pub capabilities: *const rte_cryptodev_capabilities,
    pub max_nb_queue_pairs: ::std::os::raw::c_uint,
    pub sym: rte_cryptodev_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_info__bindgen_ty_1 {
    pub max_nb_sessions: ::std::os::raw::c_uint,
    pub max_nb_sessions_per_qp: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_info__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_info__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_info__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info__bindgen_ty_1 ) ) .
                max_nb_sessions as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_info__bindgen_ty_1 ) , "::" , stringify ! (
                max_nb_sessions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info__bindgen_ty_1 ) ) .
                max_nb_sessions_per_qp as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_info__bindgen_ty_1 ) , "::" , stringify ! (
                max_nb_sessions_per_qp ) ));
}
impl Clone for rte_cryptodev_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_cryptodev_info() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_info>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( rte_cryptodev_info ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_cryptodev_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . driver_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( driver_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . driver_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( driver_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . pci_dev as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( pci_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . feature_flags as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( feature_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . capabilities as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) .
                max_nb_queue_pairs as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( max_nb_queue_pairs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_info ) ) . sym as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_info ) ,
                "::" , stringify ! ( sym ) ));
}
impl Clone for rte_cryptodev_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Definitions of Crypto device event types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_cryptodev_event_type {
    RTE_CRYPTODEV_EVENT_UNKNOWN = 0,
    RTE_CRYPTODEV_EVENT_ERROR = 1,
    RTE_CRYPTODEV_EVENT_MAX = 2,
}
/// Crypto device queue pair configuration structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_qp_conf {
    /// < Number of descriptors per queue pair
    pub nb_descriptors: u32,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_qp_conf() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_qp_conf>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( rte_cryptodev_qp_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_qp_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_qp_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_qp_conf ) ) .
                nb_descriptors as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_qp_conf )
                , "::" , stringify ! ( nb_descriptors ) ));
}
impl Clone for rte_cryptodev_qp_conf {
    fn clone(&self) -> Self { *self }
}
/// Typedef for application callback function to be registered by application
/// software for notification of device events
///
/// @param	dev_id	Crypto device identifier
/// @param	event	Crypto device event to register for notification of.
/// @param	cb_arg	User specified parameter to be passed as to passed to
/// users callback function.
pub type rte_cryptodev_cb_fn =
    ::std::option::Option<unsafe extern "C" fn(dev_id: u8,
                                               event:
                                                   rte_cryptodev_event_type,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)>;
/// Crypto Device statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_stats {
    pub enqueued_count: u64,
    pub dequeued_count: u64,
    pub enqueue_err_count: u64,
    pub dequeue_err_count: u64,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_stats() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_stats>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( rte_cryptodev_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_stats>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_stats ) ) . enqueued_count
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_stats ) ,
                "::" , stringify ! ( enqueued_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_stats ) ) . dequeued_count
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_stats ) ,
                "::" , stringify ! ( dequeued_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_stats ) ) .
                enqueue_err_count as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_cryptodev_stats ) ,
                "::" , stringify ! ( enqueue_err_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_stats ) ) .
                dequeue_err_count as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_cryptodev_stats ) ,
                "::" , stringify ! ( dequeue_err_count ) ));
}
impl Clone for rte_cryptodev_stats {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// @deprecated
///
/// Create a virtual crypto device
///
/// @param	name	Cryptodev PMD name of device to be created.
/// @param	args	Options arguments for device.
///
/// @return
/// - On successful creation of the cryptodev the device index is returned,
/// which will be between 0 and rte_cryptodev_count().
/// - In the case of a failure, returns -1.
    pub fn rte_cryptodev_create_vdev(name: *const ::std::os::raw::c_char,
                                     args: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the device identifier for the named crypto device.
///
/// @param	name	device name to select the device structure.
///
/// @return
/// - Returns crypto device identifier on success.
/// - Return -1 on failure to find named crypto device.
    pub fn rte_cryptodev_get_dev_id(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the total number of crypto devices that have been successfully
/// initialised.
///
/// @return
/// - The total number of usable crypto devices.
    pub fn rte_cryptodev_count() -> u8;
}
extern "C" {
    /// Get number of crypto device defined type.
///
/// @param	driver_id	driver identifier.
///
/// @return
/// Returns number of crypto device.
    pub fn rte_cryptodev_device_count_by_driver(driver_id: u8) -> u8;
}
extern "C" {
    /// Get number and identifiers of attached crypto devices that
/// use the same crypto driver.
///
/// @param	driver_name	driver name.
/// @param	devices		output devices identifiers.
/// @param	nb_devices	maximal number of devices.
///
/// @return
/// Returns number of attached crypto device.
    pub fn rte_cryptodev_devices_get(driver_name:
                                         *const ::std::os::raw::c_char,
                                     devices: *mut u8, nb_devices: u8) -> u8;
}
extern "C" {
    pub fn rte_cryptodev_socket_id(dev_id: u8) -> ::std::os::raw::c_int;
}
/// Crypto device configuration structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_config {
    /// < Socket to allocate resources on
    pub socket_id: ::std::os::raw::c_int,
    pub nb_queue_pairs: u16,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_config() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_config>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_cryptodev_config ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_config>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_config ) ) . socket_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_config )
                , "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_config ) ) . nb_queue_pairs
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_config )
                , "::" , stringify ! ( nb_queue_pairs ) ));
}
impl Clone for rte_cryptodev_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Configure a device.
///
/// This function must be invoked first before any other function in the
/// API. This function can also be re-invoked when a device is in the
/// stopped state.
///
/// @param	dev_id		The identifier of the device to configure.
/// @param	config		The crypto device configuration structure.
///
/// @return
/// - 0: Success, device configured.
/// - <0: Error code returned by the driver configuration function.
    pub fn rte_cryptodev_configure(dev_id: u8,
                                   config: *mut rte_cryptodev_config)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start an device.
///
/// The device start step is the last one and consists of setting the configured
/// offload features and in starting the transmit and the receive units of the
/// device.
/// On success, all basic functions exported by the API (link status,
/// receive/transmit, and so on) can be invoked.
///
/// @param dev_id
/// The identifier of the device.
/// @return
/// - 0: Success, device started.
/// - <0: Error code of the driver device start function.
    pub fn rte_cryptodev_start(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop an device. The device can be restarted with a call to
/// rte_cryptodev_start()
///
/// @param	dev_id		The identifier of the device.
    pub fn rte_cryptodev_stop(dev_id: u8);
}
extern "C" {
    /// Close an device. The device cannot be restarted!
///
/// @param	dev_id		The identifier of the device.
///
/// @return
/// - 0 on successfully closing device
/// - <0 on failure to close device
    pub fn rte_cryptodev_close(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up a receive queue pair for a device.
///
///
/// @param	dev_id		The identifier of the device.
/// @param	queue_pair_id	The index of the queue pairs to set up. The
/// value must be in the range [0, nb_queue_pair
/// - 1] previously supplied to
/// rte_cryptodev_configure().
/// @param	qp_conf		The pointer to the configuration data to be
/// used for the queue pair. NULL value is
/// allowed, in which case default configuration
/// will be used.
/// @param	socket_id	The *socket_id* argument is the socket
/// identifier in case of NUMA. The value can be
/// *SOCKET_ID_ANY* if there is no NUMA constraint
/// for the DMA memory allocated for the receive
/// queue pair.
/// @param	session_pool	Pointer to device session mempool, used
/// for session-less operations.
///
/// @return
/// - 0: Success, queue pair correctly set up.
/// - <0: Queue pair configuration failed
    pub fn rte_cryptodev_queue_pair_setup(dev_id: u8, queue_pair_id: u16,
                                          qp_conf:
                                              *const rte_cryptodev_qp_conf,
                                          socket_id: ::std::os::raw::c_int,
                                          session_pool: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start a specified queue pair of a device. It is used
/// when deferred_start flag of the specified queue is true.
///
/// @param	dev_id		The identifier of the device
/// @param	queue_pair_id	The index of the queue pair to start. The value
/// must be in the range [0, nb_queue_pair - 1]
/// previously supplied to
/// rte_crypto_dev_configure().
/// @return
/// - 0: Success, the transmit queue is correctly set up.
/// - -EINVAL: The dev_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_cryptodev_queue_pair_start(dev_id: u8, queue_pair_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop specified queue pair of a device
///
/// @param	dev_id		The identifier of the device
/// @param	queue_pair_id	The index of the queue pair to stop. The value
/// must be in the range [0, nb_queue_pair - 1]
/// previously supplied to
/// rte_cryptodev_configure().
/// @return
/// - 0: Success, the transmit queue is correctly set up.
/// - -EINVAL: The dev_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_cryptodev_queue_pair_stop(dev_id: u8, queue_pair_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of queue pairs on a specific crypto device
///
/// @param	dev_id		Crypto device identifier.
/// @return
/// - The number of configured queue pairs.
    pub fn rte_cryptodev_queue_pair_count(dev_id: u8) -> u16;
}
extern "C" {
    /// Retrieve the general I/O statistics of a device.
///
/// @param	dev_id		The identifier of the device.
/// @param	stats		A pointer to a structure of type
/// *rte_cryptodev_stats* to be filled with the
/// values of device counters.
/// @return
/// - Zero if successful.
/// - Non-zero otherwise.
    pub fn rte_cryptodev_stats_get(dev_id: u8,
                                   stats: *mut rte_cryptodev_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset the general I/O statistics of a device.
///
/// @param	dev_id		The identifier of the device.
    pub fn rte_cryptodev_stats_reset(dev_id: u8);
}
extern "C" {
    /// Retrieve the contextual information of a device.
///
/// @param	dev_id		The identifier of the device.
/// @param	dev_info	A pointer to a structure of type
/// *rte_cryptodev_info* to be filled with the
/// contextual information of the device.
    pub fn rte_cryptodev_info_get(dev_id: u8,
                                  dev_info: *mut rte_cryptodev_info);
}
extern "C" {
    /// Register a callback function for specific device id.
///
/// @param	dev_id		Device id.
/// @param	event		Event interested.
/// @param	cb_fn		User supplied callback function to be called.
/// @param	cb_arg		Pointer to the parameters for the registered
/// callback.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_cryptodev_callback_register(dev_id: u8,
                                           event: rte_cryptodev_event_type,
                                           cb_fn: rte_cryptodev_cb_fn,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unregister a callback function for specific device id.
///
/// @param	dev_id		The device identifier.
/// @param	event		Event interested.
/// @param	cb_fn		User supplied callback function to be called.
/// @param	cb_arg		Pointer to the parameters for the registered
/// callback.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_cryptodev_callback_unregister(dev_id: u8,
                                             event: rte_cryptodev_event_type,
                                             cb_fn: rte_cryptodev_cb_fn,
                                             cb_arg:
                                                 *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type dequeue_pkt_burst_t =
    ::std::option::Option<unsafe extern "C" fn(qp:
                                                   *mut ::std::os::raw::c_void,
                                               ops: *mut *mut rte_crypto_op,
                                               nb_ops: u16) -> u16>;
pub type enqueue_pkt_burst_t =
    ::std::option::Option<unsafe extern "C" fn(qp:
                                                   *mut ::std::os::raw::c_void,
                                               ops: *mut *mut rte_crypto_op,
                                               nb_ops: u16) -> u16>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cryptodev_callback {
    _unused: [u8; 0],
}
/// Structure to keep track of registered callbacks
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_cb_list {
    pub tqh_first: *mut rte_cryptodev_callback,
    pub tqh_last: *mut *mut rte_cryptodev_callback,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_cb_list() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_cb_list>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_cryptodev_cb_list )
               ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_cb_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_cb_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_cb_list ) ) . tqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_cb_list )
                , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_cb_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_cb_list )
                , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_cryptodev_cb_list {
    fn clone(&self) -> Self { *self }
}
/// The data structure associated with each crypto device.
#[repr(C)]
#[derive(Copy)]
pub struct rte_cryptodev {
    pub dequeue_burst: dequeue_pkt_burst_t,
    pub enqueue_burst: enqueue_pkt_burst_t,
    pub data: *mut rte_cryptodev_data,
    pub dev_ops: *mut rte_cryptodev_ops,
    pub feature_flags: u64,
    pub device: *mut rte_device,
    pub driver_id: u8,
    pub link_intr_cbs: rte_cryptodev_cb_list,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 55usize],
}
#[test]
fn bindgen_test_layout_rte_cryptodev() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev>() , 128usize , concat ! (
               "Size of: " , stringify ! ( rte_cryptodev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . dequeue_burst as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( dequeue_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . enqueue_burst as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( enqueue_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . dev_ops as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( dev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . feature_flags as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( feature_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . device as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . driver_id as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( driver_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev ) ) . link_intr_cbs as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev ) , "::"
                , stringify ! ( link_intr_cbs ) ));
}
impl Clone for rte_cryptodev {
    fn clone(&self) -> Self { *self }
}
impl rte_cryptodev {
    #[inline]
    pub fn attached(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_attached(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(attached: u8) -> u8 {
        ({ 0 } | ((attached as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
/// The data part, with no function pointers, associated with each device.
///
/// This structure is safe to place in shared memory to be common among
/// different processes in a multi-process configuration.
#[repr(C)]
pub struct rte_cryptodev_data {
    pub dev_id: u8,
    pub socket_id: u8,
    pub name: [::std::os::raw::c_char; 64usize],
    pub _bitfield_1: u8,
    pub session_pool: *mut rte_mempool,
    pub queue_pairs: *mut *mut ::std::os::raw::c_void,
    pub nb_queue_pairs: u16,
    pub dev_private: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_0: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_rte_cryptodev_data() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_data>() , 128usize , concat
               ! ( "Size of: " , stringify ! ( rte_cryptodev_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . dev_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . socket_id as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . name as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . session_pool as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( session_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . queue_pairs as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( queue_pairs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . nb_queue_pairs
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( nb_queue_pairs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_data ) ) . dev_private as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_data ) ,
                "::" , stringify ! ( dev_private ) ));
}
impl rte_cryptodev_data {
    #[inline]
    pub fn dev_started(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(dev_started: u8) -> u8 {
        ({ 0 } | ((dev_started as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
extern "C" {
    #[link_name = "rte_cryptodevs"]
    pub static mut rte_cryptodevs: *mut rte_cryptodev;
}
extern "C" {
    /// Create symmetric crypto session header (generic with no private data)
///
/// @param   mempool    Symmetric session mempool to allocate session
/// objects from
/// @return
/// - On success return pointer to sym-session
/// - On failure returns NULL
    pub fn rte_cryptodev_sym_session_create(mempool: *mut rte_mempool)
     -> *mut rte_cryptodev_sym_session;
}
extern "C" {
    /// Frees symmetric crypto session header, after checking that all
/// the device private data has been freed, returning it
/// to its original mempool.
///
/// @param   sess     Session header to be freed.
///
/// @return
/// - 0 if successful.
/// - -EINVAL if session is NULL.
/// - -EBUSY if not all device private data has been freed.
    pub fn rte_cryptodev_sym_session_free(sess:
                                              *mut rte_cryptodev_sym_session)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Fill out private data for the device id, based on its device type.
///
/// @param   dev_id   ID of device that we want the session to be used on
/// @param   sess     Session where the private data will be attached to
/// @param   xforms   Symmetric crypto transform operations to apply on flow
/// processed with this session
/// @param   mempool  Mempool where the private data is allocated.
///
/// @return
/// - On success, zero.
/// - -EINVAL if input parameters are invalid.
/// - -ENOTSUP if crypto device does not support the crypto transform.
/// - -ENOMEM if the private session could not be allocated.
    pub fn rte_cryptodev_sym_session_init(dev_id: u8,
                                          sess:
                                              *mut rte_cryptodev_sym_session,
                                          xforms: *mut rte_crypto_sym_xform,
                                          mempool: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Frees private data for the device id, based on its device type,
/// returning it to its mempool.
///
/// @param   dev_id   ID of device that uses the session.
/// @param   sess     Session containing the reference to the private data
///
/// @return
/// - 0 if successful.
/// - -EINVAL if device is invalid or session is NULL.
    pub fn rte_cryptodev_sym_session_clear(dev_id: u8,
                                           sess:
                                               *mut rte_cryptodev_sym_session)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the size of the header session, for all registered drivers.
///
/// @return
/// Size of the header session.
    pub fn rte_cryptodev_get_header_session_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the size of the private session data for a device.
///
/// @param	dev_id		The device identifier.
///
/// @return
/// - Size of the private data, if successful
/// - 0 if device is invalid or does not have private session
    pub fn rte_cryptodev_get_private_session_size(dev_id: u8)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Attach queue pair with sym session.
///
/// @param	dev_id		Device to which the session will be attached.
/// @param	qp_id		Queue pair to which the session will be attached.
/// @param	session		Session pointer previously allocated by
/// *rte_cryptodev_sym_session_create*.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_cryptodev_queue_pair_attach_sym_session(dev_id: u8, qp_id: u16,
                                                       session:
                                                           *mut rte_cryptodev_sym_session)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach queue pair with sym session.
///
/// @param	dev_id		Device to which the session is attached.
/// @param	qp_id		Queue pair to which the session is attached.
/// @param	session		Session pointer previously allocated by
/// *rte_cryptodev_sym_session_create*.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_cryptodev_queue_pair_detach_sym_session(dev_id: u8, qp_id: u16,
                                                       session:
                                                           *mut rte_cryptodev_sym_session)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Provide driver identifier.
///
/// @param name
/// The pointer to a driver name.
/// @return
/// The driver type identifier or -1 if no driver found
    pub fn rte_cryptodev_driver_id_get(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Provide driver name.
///
/// @param driver_id
/// The driver identifier.
/// @return
/// The driver name or null if no driver found
    pub fn rte_cryptodev_driver_name_get(driver_id: u8)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @internal
/// Allocate Cryptodev driver.
///
/// @param driver
/// Pointer to rte_driver.
/// @return
/// The driver type identifier
    pub fn rte_cryptodev_allocate_driver(driver: *const rte_driver) -> u8;
}
/// Interrupt handle
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    /// < interrupt event file descriptor
    pub fd: ::std::os::raw::c_int,
    /// < handle type
    pub type_: rte_intr_handle_type,
    /// < max interrupt requested
    pub max_intr: u32,
    /// < number of available efd(event fd)
    pub nb_efd: u32,
    /// < intr vectors/efds mapping
    pub efds: [::std::os::raw::c_int; 32usize],
    pub elist: [rte_epoll_event; 32usize],
    /// < intr vector number array
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_handle__bindgen_ty_1 {
    /// < VFIO device file descriptor
    pub vfio_dev_fd: __BindgenUnionField<::std::os::raw::c_int>,
    /// < UIO config file descriptor
    /// for uio_pci_generic
    pub uio_cfg_fd: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( rte_intr_handle__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_intr_handle__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle__bindgen_ty_1 ) ) .
                vfio_dev_fd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_intr_handle__bindgen_ty_1 ) , "::" , stringify ! (
                vfio_dev_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle__bindgen_ty_1 ) ) .
                uio_cfg_fd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_intr_handle__bindgen_ty_1 ) , "::" , stringify ! (
                uio_cfg_fd ) ));
}
impl Clone for rte_intr_handle__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(::std::mem::size_of::<rte_intr_handle>() , 1696usize , concat !
               ( "Size of: " , stringify ! ( rte_intr_handle ) ));
    assert_eq! (::std::mem::align_of::<rte_intr_handle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_intr_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . fd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . type_ as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . max_intr as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( max_intr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . nb_efd as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( nb_efd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . efds as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( efds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . elist as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( elist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . intr_vec as * const
                _ as usize } , 1688usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_intr_handle ) ,
                "::" , stringify ! ( intr_vec ) ));
}
impl Clone for rte_intr_handle {
    fn clone(&self) -> Self { *self }
}
/// Function to be registered for the specific interrupt
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_intr_handle_type {
    RTE_INTR_HANDLE_UNKNOWN = 0,
    RTE_INTR_HANDLE_UIO = 1,
    RTE_INTR_HANDLE_UIO_INTX = 2,
    RTE_INTR_HANDLE_VFIO_LEGACY = 3,
    RTE_INTR_HANDLE_VFIO_MSI = 4,
    RTE_INTR_HANDLE_VFIO_MSIX = 5,
    RTE_INTR_HANDLE_ALARM = 6,
    RTE_INTR_HANDLE_EXT = 7,
    RTE_INTR_HANDLE_VDEV = 8,
    RTE_INTR_HANDLE_MAX = 9,
}
pub type rte_intr_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(fd: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_epoll_data {
    /// < event type
    pub event: u32,
    /// < User data
    pub data: *mut ::std::os::raw::c_void,
    /// < IN: callback fun
    pub cb_fun: rte_intr_event_cb_t,
    /// < IN: callback arg
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(::std::mem::size_of::<rte_epoll_data>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rte_epoll_data ) ));
    assert_eq! (::std::mem::align_of::<rte_epoll_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_epoll_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . event as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_data ) , "::"
                , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_data ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . cb_fun as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_data ) , "::"
                , stringify ! ( cb_fun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . cb_arg as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_data ) , "::"
                , stringify ! ( cb_arg ) ));
}
impl Clone for rte_epoll_data {
    fn clone(&self) -> Self { *self }
}
pub const RTE_EPOLL_INVALID: _bindgen_ty_22 =
    _bindgen_ty_22::RTE_EPOLL_INVALID;
pub const RTE_EPOLL_VALID: _bindgen_ty_22 = _bindgen_ty_22::RTE_EPOLL_VALID;
pub const RTE_EPOLL_EXEC: _bindgen_ty_22 = _bindgen_ty_22::RTE_EPOLL_EXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    RTE_EPOLL_INVALID = 0,
    RTE_EPOLL_VALID = 1,
    RTE_EPOLL_EXEC = 2,
}
/// interrupt epoll event obj, taken by epoll_event.ptr
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_epoll_event {
    /// < OUT: event status
    pub status: u32,
    /// < OUT: event fd
    pub fd: ::std::os::raw::c_int,
    /// < OUT: epoll instance the ev associated with
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(::std::mem::size_of::<rte_epoll_event>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_epoll_event ) ));
    assert_eq! (::std::mem::align_of::<rte_epoll_event>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_epoll_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . status as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_event ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . fd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_event ) ,
                "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . epfd as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_event ) ,
                "::" , stringify ! ( epfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . epdata as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_epoll_event ) ,
                "::" , stringify ! ( epdata ) ));
}
impl Clone for rte_epoll_event {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// It waits for events on the epoll instance.
///
/// @param epfd
/// Epoll instance fd on which the caller wait for events.
/// @param events
/// Memory area contains the events that will be available for the caller.
/// @param maxevents
/// Up to maxevents are returned, must greater than zero.
/// @param timeout
/// Specifying a timeout of -1 causes a block indefinitely.
/// Specifying a timeout equal to zero cause to return immediately.
/// @return
/// - On success, returns the number of available event.
/// - On failure, a negative value.
    pub fn rte_epoll_wait(epfd: ::std::os::raw::c_int,
                          events: *mut rte_epoll_event,
                          maxevents: ::std::os::raw::c_int,
                          timeout: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It performs control operations on epoll instance referred by the epfd.
/// It requests that the operation op be performed for the target fd.
///
/// @param epfd
/// Epoll instance fd on which the caller perform control operations.
/// @param op
/// The operation be performed for the target fd.
/// @param fd
/// The target fd on which the control ops perform.
/// @param event
/// Describes the object linked to the fd.
/// Note: The caller must take care the object deletion after CTL_DEL.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_epoll_ctl(epfd: ::std::os::raw::c_int,
                         op: ::std::os::raw::c_int, fd: ::std::os::raw::c_int,
                         event: *mut rte_epoll_event)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// The function returns the per thread epoll instance.
///
/// @return
/// epfd the epoll instance referred to.
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @param intr_handle
/// Pointer to the interrupt handle.
/// @param epfd
/// Epoll instance fd which the intr vector associated to.
/// @param op
/// The operation be performed for the vector.
/// Operation type of {ADD, DEL}.
/// @param vec
/// RX intr vector number added to the epoll instance wait list.
/// @param data
/// User raw data.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_intr_rx_ctl(intr_handle: *mut rte_intr_handle,
                           epfd: ::std::os::raw::c_int,
                           op: ::std::os::raw::c_int,
                           vec: ::std::os::raw::c_uint,
                           data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It deletes registered eventfds.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    /// It enables the packet I/O interrupt event if it's necessary.
/// It creates event fd for each interrupt vector when MSIX is used,
/// otherwise it multiplexes a single event fd.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
/// @param nb_efd
/// Number of interrupt vector trying to enable.
/// The value 0 is not allowed.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_intr_efd_enable(intr_handle: *mut rte_intr_handle, nb_efd: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It disables the packet I/O interrupt event.
/// It deletes registered eventfds and closes the open fds.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    /// The packet I/O interrupt on datapath is enabled or not.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// The interrupt handle instance allows other causes or not.
/// Other causes stand for any none packet I/O interrupts.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// The multiple interrupt vector capability of interrupt handle instance.
/// It returns zero if no multiple interrupt vector support.
///
/// @param intr_handle
/// Pointer to the interrupt handle.
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It registers the callback for the specific interrupt. Multiple
/// callbacks cal be registered at the same time.
/// @param intr_handle
/// Pointer to the interrupt handle.
/// @param cb
/// callback address.
/// @param cb_arg
/// address of parameter for callback.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_intr_callback_register(intr_handle: *const rte_intr_handle,
                                      cb: rte_intr_callback_fn,
                                      cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It unregisters the callback according to the specified interrupt handle.
///
/// @param intr_handle
/// pointer to the interrupt handle.
/// @param cb
/// callback address.
/// @param cb_arg
/// address of parameter for callback, (void *)-1 means to remove all
/// registered which has the same callback address.
///
/// @return
/// - On success, return the number of callback entities removed.
/// - On failure, a negative value.
    pub fn rte_intr_callback_unregister(intr_handle: *const rte_intr_handle,
                                        cb: rte_intr_callback_fn,
                                        cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It enables the interrupt for the specified handle.
///
/// @param intr_handle
/// pointer to the interrupt handle.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// It disables the interrupt for the specified handle.
///
/// @param intr_handle
/// pointer to the interrupt handle.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pathname of PCI devices directory.
    pub fn pci_get_sysfs_path() -> *const ::std::os::raw::c_char;
}
/// A structure describing a PCI device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_device {
    /// < Next probed PCI device.
    pub next: rte_pci_device__bindgen_ty_1,
    /// < Inherit core device
    pub device: rte_device,
    /// < PCI location.
    pub addr: rte_pci_addr,
    /// < PCI ID.
    pub id: rte_pci_id,
    pub mem_resource: [rte_mem_resource; 6usize],
    /// < Interrupt handle
    pub intr_handle: rte_intr_handle,
    /// < Associated driver
    pub driver: *mut rte_pci_driver,
    /// < sriov enable if not zero
    pub max_vfs: u16,
    /// < Kernel driver passthrough
    pub kdrv: rte_kernel_driver,
    /// < PCI location (ASCII)
    pub name: [::std::os::raw::c_char; 18usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_device,
    pub tqe_prev: *mut *mut rte_pci_device,
}
#[test]
fn bindgen_test_layout_rte_pci_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_pci_device__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pci_device__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_device__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_device__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pci_device__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pci_device__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev
                ) ));
}
impl Clone for rte_pci_device__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_pci_device() {
    assert_eq!(::std::mem::size_of::<rte_pci_device>() , 1968usize , concat !
               ( "Size of: " , stringify ! ( rte_pci_device ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . device as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . addr as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . id as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . mem_resource as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( mem_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . intr_handle as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( intr_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . driver as * const _
                as usize } , 1928usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . max_vfs as * const _
                as usize } , 1936usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( max_vfs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . kdrv as * const _ as
                usize } , 1940usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( kdrv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device ) ) . name as * const _ as
                usize } , 1944usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for rte_pci_device {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a PCI driver.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_driver {
    /// < Next in list.
    pub next: rte_pci_driver__bindgen_ty_1,
    /// < Inherit core driver.
    pub driver: rte_driver,
    /// < PCI bus reference.
    pub bus: *mut rte_pci_bus,
    /// < Device Probe function.
    pub probe: pci_probe_t,
    /// < Device Remove function.
    pub remove: pci_remove_t,
    /// < ID table, NULL terminated.
    pub id_table: *const rte_pci_id,
    /// < Flags contolling handling of device.
    pub drv_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_driver,
    pub tqe_prev: *mut *mut rte_pci_driver,
}
#[test]
fn bindgen_test_layout_rte_pci_driver__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_pci_driver__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pci_driver__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_driver__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_driver__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pci_driver__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pci_driver__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev
                ) ));
}
impl Clone for rte_pci_driver__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_pci_driver() {
    assert_eq!(::std::mem::size_of::<rte_pci_driver>() , 88usize , concat ! (
               "Size of: " , stringify ! ( rte_pci_driver ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . driver as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . bus as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . probe as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . remove as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( remove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . id_table as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( id_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver ) ) . drv_flags as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver ) , "::"
                , stringify ! ( drv_flags ) ));
}
impl Clone for rte_pci_driver {
    fn clone(&self) -> Self { *self }
}
/// List of PCI devices
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_device_list {
    pub tqh_first: *mut rte_pci_device,
    pub tqh_last: *mut *mut rte_pci_device,
}
#[test]
fn bindgen_test_layout_rte_pci_device_list() {
    assert_eq!(::std::mem::size_of::<rte_pci_device_list>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_pci_device_list ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_device_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pci_device_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_device_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_device_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_pci_device_list {
    fn clone(&self) -> Self { *self }
}
/// List of PCI drivers
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_driver_list {
    pub tqh_first: *mut rte_pci_driver,
    pub tqh_last: *mut *mut rte_pci_driver,
}
#[test]
fn bindgen_test_layout_rte_pci_driver_list() {
    assert_eq!(::std::mem::size_of::<rte_pci_driver_list>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_pci_driver_list ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_driver_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pci_driver_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_driver_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_driver_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_pci_driver_list {
    fn clone(&self) -> Self { *self }
}
/// A structure describing an ID for a PCI driver. Each driver provides a
/// table of these IDs for each device that it supports.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_id {
    /// < Class ID (class, subclass, pi) or RTE_CLASS_ANY_ID.
    pub class_id: u32,
    /// < Vendor ID or PCI_ANY_ID.
    pub vendor_id: u16,
    /// < Device ID or PCI_ANY_ID.
    pub device_id: u16,
    /// < Subsystem vendor ID or PCI_ANY_ID.
    pub subsystem_vendor_id: u16,
    /// < Subsystem device ID or PCI_ANY_ID.
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(::std::mem::size_of::<rte_pci_id>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_pci_id ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_id>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . class_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_id ) , "::" ,
                stringify ! ( class_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . vendor_id as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_id ) , "::" ,
                stringify ! ( vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . device_id as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_id ) , "::" ,
                stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . subsystem_vendor_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_id ) , "::" ,
                stringify ! ( subsystem_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . subsystem_device_id as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_id ) , "::" ,
                stringify ! ( subsystem_device_id ) ));
}
impl Clone for rte_pci_id {
    fn clone(&self) -> Self { *self }
}
/// A structure describing the location of a PCI device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_addr {
    /// < Device domain
    pub domain: u32,
    /// < Device bus
    pub bus: u8,
    /// < Device ID
    pub devid: u8,
    /// < Device function.
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(::std::mem::size_of::<rte_pci_addr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_pci_addr ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . domain as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_addr ) , "::" ,
                stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . bus as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_addr ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . devid as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_addr ) , "::" ,
                stringify ! ( devid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . function as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_addr ) , "::" ,
                stringify ! ( function ) ));
}
impl Clone for rte_pci_addr {
    fn clone(&self) -> Self { *self }
}
/// Initialisation function for the driver called during PCI probing.
pub type pci_probe_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_pci_driver,
                                               arg2: *mut rte_pci_device)
                              -> ::std::os::raw::c_int>;
/// Uninitialisation function for the driver called during hotplugging.
pub type pci_remove_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_pci_device)
                              -> ::std::os::raw::c_int>;
/// Structure describing the PCI bus
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_bus {
    /// < Inherit the generic class
    pub bus: rte_bus,
    /// < List of PCI devices
    pub device_list: rte_pci_device_list,
    /// < List of PCI drivers
    pub driver_list: rte_pci_driver_list,
}
#[test]
fn bindgen_test_layout_rte_pci_bus() {
    assert_eq!(::std::mem::size_of::<rte_pci_bus>() , 112usize , concat ! (
               "Size of: " , stringify ! ( rte_pci_bus ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_bus>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_bus ) ) . bus as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_bus ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_bus ) ) . device_list as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_bus ) , "::" ,
                stringify ! ( device_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_bus ) ) . driver_list as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_bus ) , "::" ,
                stringify ! ( driver_list ) ));
}
impl Clone for rte_pci_bus {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a PCI mapping.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map {
    pub addr: *mut ::std::os::raw::c_void,
    pub path: *mut ::std::os::raw::c_char,
    pub offset: u64,
    pub size: u64,
    pub phaddr: u64,
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(::std::mem::size_of::<pci_map>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pci_map ) ));
    assert_eq! (::std::mem::align_of::<pci_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pci_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . addr as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . path as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . offset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . size as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . phaddr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( phaddr ) ));
}
impl Clone for pci_map {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a mapped PCI resource.
/// For multi-process we need to reproduce all PCI mappings in secondary
/// processes, so save them in a tailq.
#[repr(C)]
pub struct mapped_pci_resource {
    pub next: mapped_pci_resource__bindgen_ty_1,
    pub pci_addr: rte_pci_addr,
    pub path: [::std::os::raw::c_char; 4096usize],
    pub nb_maps: ::std::os::raw::c_int,
    pub maps: [pci_map; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mapped_pci_resource__bindgen_ty_1 {
    pub tqe_next: *mut mapped_pci_resource,
    pub tqe_prev: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_resource__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mapped_pci_resource__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( mapped_pci_resource__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mapped_pci_resource__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mapped_pci_resource__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mapped_pci_resource__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mapped_pci_resource__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for mapped_pci_resource__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_mapped_pci_resource() {
    assert_eq!(::std::mem::size_of::<mapped_pci_resource>() , 4368usize ,
               concat ! ( "Size of: " , stringify ! ( mapped_pci_resource )
               ));
    assert_eq! (::std::mem::align_of::<mapped_pci_resource>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mapped_pci_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_resource ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource ) ) . pci_addr as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_resource ) ,
                "::" , stringify ! ( pci_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource ) ) . path as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_resource ) ,
                "::" , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource ) ) . nb_maps as *
                const _ as usize } , 4120usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_resource ) ,
                "::" , stringify ! ( nb_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_resource ) ) . maps as * const
                _ as usize } , 4128usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_resource ) ,
                "::" , stringify ! ( maps ) ));
}
/// mapped pci device list
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mapped_pci_res_list {
    pub tqh_first: *mut mapped_pci_resource,
    pub tqh_last: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_res_list() {
    assert_eq!(::std::mem::size_of::<mapped_pci_res_list>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( mapped_pci_res_list ) ));
    assert_eq! (::std::mem::align_of::<mapped_pci_res_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mapped_pci_res_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_res_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_res_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mapped_pci_res_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mapped_pci_res_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for mapped_pci_res_list {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Scan the content of the PCI bus, and the devices in the devices
/// list
///
/// @return
/// 0 on success, negative on error
    pub fn rte_pci_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Probe the PCI bus
///
/// @return
/// - 0 on success.
/// - !0 on error.
    pub fn rte_pci_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Map the PCI device resources in user space virtual memory address
///
/// Note that driver should not call this function when flag
/// RTE_PCI_DRV_NEED_MAPPING is set, as EAL will do that for
/// you when it's on.
///
/// @param dev
/// A pointer to a rte_pci_device structure describing the device
/// to use
///
/// @return
/// 0 on success, negative on error and positive if no driver
/// is found for the device.
    pub fn rte_pci_map_device(dev: *mut rte_pci_device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unmap this device
///
/// @param dev
/// A pointer to a rte_pci_device structure describing the device
/// to use
    pub fn rte_pci_unmap_device(dev: *mut rte_pci_device);
}
extern "C" {
    /// @internal
/// Map a particular resource from a file.
///
/// @param requested_addr
/// The starting address for the new mapping range.
/// @param fd
/// The file descriptor.
/// @param offset
/// The offset for the mapping range.
/// @param size
/// The size for the mapping range.
/// @param additional_flags
/// The additional flags for the mapping range.
/// @return
/// - On success, the function returns a pointer to the mapped area.
/// - On error, the value MAP_FAILED is returned.
    pub fn pci_map_resource(requested_addr: *mut ::std::os::raw::c_void,
                            fd: ::std::os::raw::c_int, offset: off_t,
                            size: usize,
                            additional_flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @internal
/// Unmap a particular resource.
///
/// @param requested_addr
/// The address for the unmapping range.
/// @param size
/// The size for the unmapping range.
    pub fn pci_unmap_resource(requested_addr: *mut ::std::os::raw::c_void,
                              size: usize);
}
extern "C" {
    /// Probe the single PCI device.
///
/// Scan the content of the PCI bus, and find the pci device specified by pci
/// address, then call the probe() function for registered driver that has a
/// matching entry in its id_table for discovered device.
///
/// @param addr
/// The PCI Bus-Device-Function address to probe.
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_pci_probe_one(addr: *const rte_pci_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close the single PCI device.
///
/// Scan the content of the PCI bus, and find the pci device specified by pci
/// address, then call the remove() function for registered driver that has a
/// matching entry in its id_table for discovered device.
///
/// @param addr
/// The PCI Bus-Device-Function address to close.
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_pci_detach(addr: *const rte_pci_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump the content of the PCI bus.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_pci_dump(f: *mut FILE);
}
extern "C" {
    /// Register a PCI driver.
///
/// @param driver
/// A pointer to a rte_pci_driver structure describing the driver
/// to be registered.
    pub fn rte_pci_register(driver: *mut rte_pci_driver);
}
extern "C" {
    /// Unregister a PCI driver.
///
/// @param driver
/// A pointer to a rte_pci_driver structure describing the driver
/// to be unregistered.
    pub fn rte_pci_unregister(driver: *mut rte_pci_driver);
}
extern "C" {
    /// Read PCI config space.
///
/// @param device
/// A pointer to a rte_pci_device structure describing the device
/// to use
/// @param buf
/// A data buffer where the bytes should be read into
/// @param len
/// The length of the data buffer.
/// @param offset
/// The offset into PCI config space
    pub fn rte_pci_read_config(device: *const rte_pci_device,
                               buf: *mut ::std::os::raw::c_void, len: usize,
                               offset: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Write PCI config space.
///
/// @param device
/// A pointer to a rte_pci_device structure describing the device
/// to use
/// @param buf
/// A data buffer containing the bytes should be written
/// @param len
/// The length of the data buffer.
/// @param offset
/// The offset into PCI config space
    pub fn rte_pci_write_config(device: *const rte_pci_device,
                                buf: *const ::std::os::raw::c_void,
                                len: usize, offset: off_t)
     -> ::std::os::raw::c_int;
}
/// A structure used to access io resources for a pci device.
/// rte_pci_ioport is arch, os, driver specific, and should not be used outside
/// of pci ioport api.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_ioport {
    pub dev: *mut rte_pci_device,
    pub base: u64,
    pub len: u64,
}
#[test]
fn bindgen_test_layout_rte_pci_ioport() {
    assert_eq!(::std::mem::size_of::<rte_pci_ioport>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_pci_ioport ) ));
    assert_eq! (::std::mem::align_of::<rte_pci_ioport>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pci_ioport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . dev as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_ioport ) , "::"
                , stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . base as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_ioport ) , "::"
                , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pci_ioport ) , "::"
                , stringify ! ( len ) ));
}
impl Clone for rte_pci_ioport {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Initialize a rte_pci_ioport object for a pci device io resource.
///
/// This object is then used to gain access to those io resources (see below).
///
/// @param dev
/// A pointer to a rte_pci_device structure describing the device
/// to use.
/// @param bar
/// Index of the io pci resource we want to access.
/// @param p
/// The rte_pci_ioport object to be initialized.
/// @return
/// 0 on success, negative on error.
    pub fn rte_pci_ioport_map(dev: *mut rte_pci_device,
                              bar: ::std::os::raw::c_int,
                              p: *mut rte_pci_ioport)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Release any resources used in a rte_pci_ioport object.
///
/// @param p
/// The rte_pci_ioport object to be uninitialized.
/// @return
/// 0 on success, negative on error.
    pub fn rte_pci_ioport_unmap(p: *mut rte_pci_ioport)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read from a io pci resource.
///
/// @param p
/// The rte_pci_ioport object from which we want to read.
/// @param data
/// A data buffer where the bytes should be read into
/// @param len
/// The length of the data buffer.
/// @param offset
/// The offset into the pci io resource.
    pub fn rte_pci_ioport_read(p: *mut rte_pci_ioport,
                               data: *mut ::std::os::raw::c_void, len: usize,
                               offset: off_t);
}
extern "C" {
    /// Write to a io pci resource.
///
/// @param p
/// The rte_pci_ioport object to which we want to write.
/// @param data
/// A data buffer where the bytes should be read into
/// @param len
/// The length of the data buffer.
/// @param offset
/// The offset into the pci io resource.
    pub fn rte_pci_ioport_write(p: *mut rte_pci_ioport,
                                data: *const ::std::os::raw::c_void,
                                len: usize, offset: off_t);
}
/// Initialisation function of a crypto driver invoked for each matching
/// crypto PCI device detected during the PCI probing phase.
///
/// @param	dev	The dev pointer is the address of the *rte_cryptodev*
/// structure associated with the matching device and which
/// has been [automatically] allocated in the
/// *rte_crypto_devices* array.
///
/// @return
/// - 0: Success, the device is properly initialised by the driver.
/// In particular, the driver MUST have set up the *dev_ops* pointer
/// of the *dev* structure.
/// - <0: Error code of the device initialisation failure.
pub type cryptodev_pci_init_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
/// Finalisation function of a driver invoked for each matching
/// PCI device detected during the PCI closing phase.
///
/// @param	dev	The dev pointer is the address of the *rte_cryptodev*
/// structure associated with the matching device and which
/// has been [automatically] allocated in the
/// *rte_crypto_devices* array.
///
/// * @return
/// - 0: Success, the device is properly finalised by the driver.
/// In particular, the driver MUST free the *dev_ops* pointer
/// of the *dev* structure.
/// - <0: Error code of the device initialisation failure.
pub type cryptodev_pci_uninit_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// @internal
/// Wrapper for use by pci drivers as a .probe function to attach to a crypto
/// interface.
    pub fn rte_cryptodev_pci_generic_probe(pci_dev: *mut rte_pci_device,
                                           private_data_size: usize,
                                           dev_init: cryptodev_pci_init_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal
/// Wrapper for use by pci drivers as a .remove function to detach a crypto
/// interface.
    pub fn rte_cryptodev_pci_generic_remove(pci_dev: *mut rte_pci_device,
                                            dev_uninit:
                                                cryptodev_pci_uninit_t)
     -> ::std::os::raw::c_int;
}
/// Global structure used for maintaining state of allocated crypto devices
#[repr(C)]
pub struct rte_cryptodev_global {
    /// < Device information array
    pub devs: *mut rte_cryptodev,
    pub data: [*mut rte_cryptodev_data; 64usize],
    /// < Number of devices found
    pub nb_devs: u8,
    /// < Max number of devices
    pub max_devs: u8,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_global() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_global>() , 528usize ,
               concat ! ( "Size of: " , stringify ! ( rte_cryptodev_global )
               ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_global>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_global ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_global ) ) . devs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_global )
                , "::" , stringify ! ( devs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_global ) ) . data as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_global )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_global ) ) . nb_devs as *
                const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_global )
                , "::" , stringify ! ( nb_devs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_global ) ) . max_devs as *
                const _ as usize } , 521usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_global )
                , "::" , stringify ! ( max_devs ) ));
}
extern "C" {
    #[link_name = "rte_cryptodev_globals"]
    pub static mut rte_cryptodev_globals: *mut rte_cryptodev_global;
}
extern "C" {
    /// Get the rte_cryptodev structure device pointer for the device. Assumes a
/// valid device index.
///
/// @param	dev_id	Device ID value to select the device structure.
///
/// @return
/// - The rte_cryptodev structure pointer for the given device ID.
    pub fn rte_cryptodev_pmd_get_dev(dev_id: u8) -> *mut rte_cryptodev;
}
extern "C" {
    /// Get the rte_cryptodev structure device pointer for the named device.
///
/// @param	name	device name to select the device structure.
///
/// @return
/// - The rte_cryptodev structure pointer for the given device ID.
    pub fn rte_cryptodev_pmd_get_named_dev(name:
                                               *const ::std::os::raw::c_char)
     -> *mut rte_cryptodev;
}
extern "C" {
    /// Validate if the crypto device index is valid attached crypto device.
///
/// @param	dev_id	Crypto device index.
///
/// @return
/// - If the device index is valid (1) or not (0).
    pub fn rte_cryptodev_pmd_is_valid_dev(dev_id: u8)
     -> ::std::os::raw::c_uint;
}
/// Function used to configure device.
///
/// @param	dev	Crypto device pointer
/// config	Crypto device configurations
///
/// @return	Returns 0 on success
pub type cryptodev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               config:
                                                   *mut rte_cryptodev_config)
                              -> ::std::os::raw::c_int>;
/// Function used to start a configured device.
///
/// @param	dev	Crypto device pointer
///
/// @return	Returns 0 on success
pub type cryptodev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
/// Function used to stop a configured device.
///
/// @param	dev	Crypto device pointer
pub type cryptodev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)>;
/// Function used to close a configured device.
///
/// @param	dev	Crypto device pointer
/// @return
/// - 0 on success.
/// - EAGAIN if can't close as device is busy
pub type cryptodev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
/// Function used to get statistics of a device.
///
/// @param	dev	Crypto device pointer
/// @param	stats	Pointer to crypto device stats structure to populate
pub type cryptodev_stats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               stats:
                                                   *mut rte_cryptodev_stats)>;
/// Function used to reset statistics of a device.
///
/// @param	dev	Crypto device pointer
pub type cryptodev_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)>;
/// Function used to get specific information of a device.
///
/// @param	dev	Crypto device pointer
pub type cryptodev_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               dev_info:
                                                   *mut rte_cryptodev_info)>;
/// Start queue pair of a device.
///
/// @param	dev	Crypto device pointer
/// @param	qp_id	Queue Pair Index
///
/// @return	Returns 0 on success.
pub type cryptodev_queue_pair_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16)
                              -> ::std::os::raw::c_int>;
/// Stop queue pair of a device.
///
/// @param	dev	Crypto device pointer
/// @param	qp_id	Queue Pair Index
///
/// @return	Returns 0 on success.
pub type cryptodev_queue_pair_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16)
                              -> ::std::os::raw::c_int>;
/// Setup a queue pair for a device.
///
/// @param	dev		Crypto device pointer
/// @param	qp_id		Queue Pair Index
/// @param	qp_conf		Queue configuration structure
/// @param	socket_id	Socket Index
/// @param	session_pool	Pointer to device session mempool
///
/// @return	Returns 0 on success.
pub type cryptodev_queue_pair_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16,
                                               qp_conf:
                                                   *const rte_cryptodev_qp_conf,
                                               socket_id:
                                                   ::std::os::raw::c_int,
                                               session_pool: *mut rte_mempool)
                              -> ::std::os::raw::c_int>;
/// Release memory resources allocated by given queue pair.
///
/// @param	dev	Crypto device pointer
/// @param	qp_id	Queue Pair Index
///
/// @return
/// - 0 on success.
/// - EAGAIN if can't close as device is busy
pub type cryptodev_queue_pair_release_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16)
                              -> ::std::os::raw::c_int>;
/// Get number of available queue pairs of a device.
///
/// @param	dev	Crypto device pointer
///
/// @return	Returns number of queue pairs on success.
pub type cryptodev_queue_pair_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> u32>;
/// Create a session mempool to allocate sessions from
///
/// @param	dev		Crypto device pointer
/// @param	nb_objs		number of sessions objects in mempool
/// @param	obj_cache	l-core object cache size, see *rte_ring_create*
/// @param	socket_id	Socket Id to allocate  mempool on.
///
/// @return
/// - On success returns a pointer to a rte_mempool
/// - On failure returns a NULL pointer
pub type cryptodev_sym_create_session_pool_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               nb_objs:
                                                   ::std::os::raw::c_uint,
                                               obj_cache_size:
                                                   ::std::os::raw::c_uint,
                                               socket_id:
                                                   ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/// Get the size of a cryptodev session
///
/// @param	dev		Crypto device pointer
///
/// @return
/// - On success returns the size of the session structure for device
/// - On failure returns 0
pub type cryptodev_sym_get_session_private_size_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_uint>;
/// Configure a Crypto session on a device.
///
/// @param	dev		Crypto device pointer
/// @param	xform		Single or chain of crypto xforms
/// @param	priv_sess	Pointer to cryptodev's private session structure
/// @param	mp		Mempool where the private session is allocated
///
/// @return
/// - Returns 0 if private session structure have been created successfully.
/// - Returns -EINVAL if input parameters are invalid.
/// - Returns -ENOTSUP if crypto device does not support the crypto transform.
/// - Returns -ENOMEM if the private session could not be allocated.
pub type cryptodev_sym_configure_session_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               xform:
                                                   *mut rte_crypto_sym_xform,
                                               session:
                                                   *mut rte_cryptodev_sym_session,
                                               mp: *mut rte_mempool)
                              -> ::std::os::raw::c_int>;
/// Free driver private session data.
///
/// @param	dev		Crypto device pointer
/// @param	sess		Cryptodev session structure
pub type cryptodev_sym_free_session_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               sess:
                                                   *mut rte_cryptodev_sym_session)>;
/// Optional API for drivers to attach sessions with queue pair.
/// @param	dev		Crypto device pointer
/// @param	qp_id		queue pair id for attaching session
/// @param	priv_sess       Pointer to cryptodev's private session structure
/// @return
/// - Return 0 on success
pub type cryptodev_sym_queue_pair_attach_session_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16,
                                               session_private:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Optional API for drivers to detach sessions from queue pair.
/// @param	dev		Crypto device pointer
/// @param	qp_id		queue pair id for detaching session
/// @param	priv_sess       Pointer to cryptodev's private session structure
/// @return
/// - Return 0 on success
pub type cryptodev_sym_queue_pair_detach_session_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16,
                                               session_private:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Crypto device operations function pointer table
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_ops {
    /// < Configure device.
    pub dev_configure: cryptodev_configure_t,
    /// < Start device.
    pub dev_start: cryptodev_start_t,
    /// < Stop device.
    pub dev_stop: cryptodev_stop_t,
    /// < Close device.
    pub dev_close: cryptodev_close_t,
    /// < Get device info.
    pub dev_infos_get: cryptodev_info_get_t,
    pub stats_get: cryptodev_stats_get_t,
    pub stats_reset: cryptodev_stats_reset_t,
    pub queue_pair_setup: cryptodev_queue_pair_setup_t,
    pub queue_pair_release: cryptodev_queue_pair_release_t,
    pub queue_pair_start: cryptodev_queue_pair_start_t,
    pub queue_pair_stop: cryptodev_queue_pair_stop_t,
    pub queue_pair_count: cryptodev_queue_pair_count_t,
    pub session_get_size: cryptodev_sym_get_session_private_size_t,
    pub session_configure: cryptodev_sym_configure_session_t,
    pub session_clear: cryptodev_sym_free_session_t,
    pub qp_attach_session: cryptodev_sym_queue_pair_attach_session_t,
    pub qp_detach_session: cryptodev_sym_queue_pair_attach_session_t,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_ops() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_ops>() , 136usize , concat
               ! ( "Size of: " , stringify ! ( rte_cryptodev_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_ops>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_cryptodev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . dev_configure as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( dev_configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . dev_start as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( dev_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . dev_stop as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( dev_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . dev_close as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( dev_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . dev_infos_get as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( dev_infos_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . stats_get as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( stats_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . stats_reset as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( stats_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . queue_pair_setup
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( queue_pair_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) .
                queue_pair_release as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( queue_pair_release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . queue_pair_start
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( queue_pair_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . queue_pair_stop
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( queue_pair_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . queue_pair_count
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( queue_pair_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . session_get_size
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( session_get_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . session_configure
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( session_configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . session_clear as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( session_clear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . qp_attach_session
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( qp_attach_session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_ops ) ) . qp_detach_session
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_ops ) ,
                "::" , stringify ! ( qp_detach_session ) ));
}
impl Clone for rte_cryptodev_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Function for internal use by dummy drivers primarily, e.g. ring-based
/// driver.
/// Allocates a new cryptodev slot for an crypto device and returns the pointer
/// to that slot for the driver to use.
///
/// @param	name		Unique identifier name for each device
/// @param	socket_id	Socket to allocate resources on.
/// @return
/// - Slot in the rte_dev_devices array for a new device;
    pub fn rte_cryptodev_pmd_allocate(name: *const ::std::os::raw::c_char,
                                      socket_id: ::std::os::raw::c_int)
     -> *mut rte_cryptodev;
}
extern "C" {
    /// Function for internal use by dummy drivers primarily, e.g. ring-based
/// driver.
/// Release the specified cryptodev device.
///
/// @param cryptodev
/// The *cryptodev* pointer is the address of the *rte_cryptodev* structure.
/// @return
/// - 0 on success, negative on error
    pub fn rte_cryptodev_pmd_release_device(cryptodev: *mut rte_cryptodev)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Executes all the user application registered callbacks for the specific
/// device.
/// *
/// @param	dev	Pointer to cryptodev struct
/// @param	event	Crypto device interrupt event type.
///
/// @return
/// void
    pub fn rte_cryptodev_pmd_callback_process(dev: *mut rte_cryptodev,
                                              event:
                                                  rte_cryptodev_event_type);
}
extern "C" {
    /// @internal
/// Create unique device name
    pub fn rte_cryptodev_pmd_create_dev_name(name:
                                                 *mut ::std::os::raw::c_char,
                                             dev_name_prefix:
                                                 *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type rte_cryptodev_scheduler_slave_attach_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               slave_id: u8)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_slave_detach_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               slave_id: u8)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_config_queue_pair =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               qp_id: u16)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_create_private_ctx =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_config_option_set =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               option_type: u32,
                                               option:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type rte_cryptodev_scheduler_config_option_get =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_cryptodev,
                                               option_type: u32,
                                               option:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_scheduler_ops {
    pub slave_attach: rte_cryptodev_scheduler_slave_attach_t,
    pub slave_detach: rte_cryptodev_scheduler_slave_attach_t,
    pub scheduler_start: rte_cryptodev_scheduler_start_t,
    pub scheduler_stop: rte_cryptodev_scheduler_stop_t,
    pub config_queue_pair: rte_cryptodev_scheduler_config_queue_pair,
    pub create_private_ctx: rte_cryptodev_scheduler_create_private_ctx,
    pub option_set: rte_cryptodev_scheduler_config_option_set,
    pub option_get: rte_cryptodev_scheduler_config_option_get,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_scheduler_ops() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_scheduler_ops>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_scheduler_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_scheduler_ops>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_scheduler_ops )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                slave_attach as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                slave_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                slave_detach as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                slave_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                scheduler_start as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                scheduler_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                scheduler_stop as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                scheduler_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                config_queue_pair as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                config_queue_pair ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                create_private_ctx as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                create_private_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                option_set as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                option_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler_ops ) ) .
                option_get as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_ops ) , "::" , stringify ! (
                option_get ) ));
}
impl Clone for rte_cryptodev_scheduler_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Crypto scheduler PMD operation modes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_cryptodev_scheduler_mode {
    CDEV_SCHED_MODE_NOT_SET = 0,
    CDEV_SCHED_MODE_USERDEFINED = 1,
    CDEV_SCHED_MODE_ROUNDROBIN = 2,
    CDEV_SCHED_MODE_PKT_SIZE_DISTR = 3,
    CDEV_SCHED_MODE_FAILOVER = 4,
    CDEV_SCHED_MODE_MULTICORE = 5,
    CDEV_SCHED_MODE_COUNT = 6,
}
#[repr(u32)]
/// Crypto scheduler option types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_cryptodev_schedule_option_type {
    CDEV_SCHED_OPTION_NOT_SET = 0,
    CDEV_SCHED_OPTION_THRESHOLD = 1,
    CDEV_SCHED_OPTION_COUNT = 2,
}
/// Threshold option structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_scheduler_threshold_option {
    /// < Threshold for packet-size mode
    pub threshold: u32,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_scheduler_threshold_option() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_scheduler_threshold_option>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_cryptodev_scheduler_threshold_option ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_scheduler_threshold_option>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_cryptodev_scheduler_threshold_option ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_cryptodev_scheduler_threshold_option ) )
                . threshold as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_cryptodev_scheduler_threshold_option ) , "::" , stringify
                ! ( threshold ) ));
}
impl Clone for rte_cryptodev_scheduler_threshold_option {
    fn clone(&self) -> Self { *self }
}
/// The data structure associated with each mode of scheduler.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_cryptodev_scheduler {
    /// < Scheduler name
    pub name: *const ::std::os::raw::c_char,
    /// < Scheduler description
    pub description: *const ::std::os::raw::c_char,
    /// < Scheduling mode
    pub mode: rte_cryptodev_scheduler_mode,
    /// Pointer to scheduler operation structure
    pub ops: *mut rte_cryptodev_scheduler_ops,
}
#[test]
fn bindgen_test_layout_rte_cryptodev_scheduler() {
    assert_eq!(::std::mem::size_of::<rte_cryptodev_scheduler>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_cryptodev_scheduler ) ));
    assert_eq! (::std::mem::align_of::<rte_cryptodev_scheduler>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_cryptodev_scheduler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_scheduler
                ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler ) ) . description
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_scheduler
                ) , "::" , stringify ! ( description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler ) ) . mode as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_scheduler
                ) , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cryptodev_scheduler ) ) . ops as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_cryptodev_scheduler
                ) , "::" , stringify ! ( ops ) ));
}
impl Clone for rte_cryptodev_scheduler {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Load a user defined scheduler
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param scheduler
/// Pointer to the user defined scheduler
///
/// @return
/// - 0 if the scheduler is successfully loaded
/// - -ENOTSUP if the operation is not supported.
/// - -EBUSY if device is started.
/// - -EINVAL if input values are invalid.
    pub fn rte_cryptodev_scheduler_load_user_scheduler(scheduler_id: u8,
                                                       scheduler:
                                                           *mut rte_cryptodev_scheduler)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach a crypto device to the scheduler
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param slave_id
/// Crypto device ID to be attached
///
/// @return
/// - 0 if the slave is attached.
/// - -ENOTSUP if the operation is not supported.
/// - -EBUSY if device is started.
/// - -ENOMEM if the scheduler's slave list is full.
    pub fn rte_cryptodev_scheduler_slave_attach(scheduler_id: u8,
                                                slave_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach a crypto device from the scheduler
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param slave_id
/// Crypto device ID to be detached
///
/// @return
/// - 0 if the slave is detached.
/// - -ENOTSUP if the operation is not supported.
/// - -EBUSY if device is started.
    pub fn rte_cryptodev_scheduler_slave_detach(scheduler_id: u8,
                                                slave_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the scheduling mode
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param mode
/// The scheduling mode
///
/// @return
/// - 0 if the mode is set.
/// - -ENOTSUP if the operation is not supported.
/// - -EBUSY if device is started.
    pub fn rte_cryptodev_scheduler_mode_set(scheduler_id: u8,
                                            mode:
                                                rte_cryptodev_scheduler_mode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current scheduling mode
///
/// @param scheduler_id
/// The target scheduler device ID
///
/// @return mode
/// - non-negative enumerate value: the scheduling mode
/// - -ENOTSUP if the operation is not supported.
    pub fn rte_cryptodev_scheduler_mode_get(scheduler_id: u8)
     -> rte_cryptodev_scheduler_mode;
}
extern "C" {
    /// Set the crypto ops reordering feature on/off
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param enable_reorder
/// Set the crypto op reordering feature
/// - 0: disable reordering
/// - 1: enable reordering
///
/// @return
/// - 0 if the ordering is set.
/// - -ENOTSUP if the operation is not supported.
/// - -EBUSY if device is started.
    pub fn rte_cryptodev_scheduler_ordering_set(scheduler_id: u8,
                                                enable_reorder: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current crypto ops reordering feature
///
/// @param scheduler_id
/// The target scheduler device ID
///
/// @return
/// - 0 if reordering is disabled
/// - 1 if reordering is enabled
/// - -ENOTSUP if the operation is not supported.
    pub fn rte_cryptodev_scheduler_ordering_get(scheduler_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the the attached slaves' count and/or ID
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param slaves
/// If successful, the function will write back all slaves' device IDs to it.
/// This parameter will either be an uint8_t array of
/// RTE_CRYPTODEV_SCHEDULER_MAX_NB_SLAVES elements or NULL.
///
/// @return
/// - non-negative number: the number of slaves attached
/// - -ENOTSUP if the operation is not supported.
    pub fn rte_cryptodev_scheduler_slaves_get(scheduler_id: u8,
                                              slaves: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the mode specific option
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param option_type
/// The option type enumerate
/// @param option
/// The specific mode's option structure
///
/// @return
/// - 0 if successful
/// - negative integer if otherwise.
    pub fn rte_cryptodev_scheduler_option_set(scheduler_id: u8,
                                              option_type:
                                                  rte_cryptodev_schedule_option_type,
                                              option:
                                                  *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the mode specific option
///
/// @param scheduler_id
/// The target scheduler device ID
/// @param option_type
/// The option type enumerate
/// @param option
/// If successful, the function will write back the current
///
/// @return
/// - 0 if successful
/// - negative integer if otherwise.
    pub fn rte_cryptodev_scheduler_option_get(scheduler_id: u8,
                                              option_type:
                                                  rte_cryptodev_schedule_option_type,
                                              option:
                                                  *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type rte_cryptodev_scheduler_burst_enqueue_t =
    ::std::option::Option<unsafe extern "C" fn(qp_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               ops: *mut *mut rte_crypto_op,
                                               nb_ops: u16) -> u16>;
pub type rte_cryptodev_scheduler_burst_dequeue_t =
    ::std::option::Option<unsafe extern "C" fn(qp_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               ops: *mut *mut rte_crypto_op,
                                               nb_ops: u16) -> u16>;
extern "C" {
    #[link_name = "roundrobin_scheduler"]
    pub static mut roundrobin_scheduler: *mut rte_cryptodev_scheduler;
}
extern "C" {
    #[link_name = "pkt_size_based_distr_scheduler"]
    pub static mut pkt_size_based_distr_scheduler:
               *mut rte_cryptodev_scheduler;
}
extern "C" {
    #[link_name = "failover_scheduler"]
    pub static mut failover_scheduler: *mut rte_cryptodev_scheduler;
}
extern "C" {
    #[link_name = "multicore_scheduler"]
    pub static mut multicore_scheduler: *mut rte_cryptodev_scheduler;
}
extern "C" {
    #[link_name = "cryptodev_vdev_valid_params"]
    pub static mut cryptodev_vdev_valid_params:
               [*const ::std::os::raw::c_char; 4usize];
}
/// @internal
/// Initialisation parameters for virtual crypto devices
#[repr(C)]
pub struct rte_crypto_vdev_init_params {
    pub max_nb_queue_pairs: ::std::os::raw::c_uint,
    pub max_nb_sessions: ::std::os::raw::c_uint,
    pub socket_id: u8,
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_crypto_vdev_init_params() {
    assert_eq!(::std::mem::size_of::<rte_crypto_vdev_init_params>() , 76usize
               , concat ! (
               "Size of: " , stringify ! ( rte_crypto_vdev_init_params ) ));
    assert_eq! (::std::mem::align_of::<rte_crypto_vdev_init_params>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_crypto_vdev_init_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_vdev_init_params ) ) .
                max_nb_queue_pairs as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_crypto_vdev_init_params ) , "::" , stringify ! (
                max_nb_queue_pairs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_vdev_init_params ) ) .
                max_nb_sessions as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_vdev_init_params ) , "::" , stringify ! (
                max_nb_sessions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_vdev_init_params ) ) .
                socket_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_vdev_init_params ) , "::" , stringify ! ( socket_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_crypto_vdev_init_params ) ) . name as
                * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_crypto_vdev_init_params ) , "::" , stringify ! ( name )
                ));
}
extern "C" {
    /// @internal
/// Creates a new virtual crypto device and returns the pointer
/// to that device.
///
/// @param	name			PMD type name
/// @param	dev_private_size	Size of crypto PMDs private data
/// @param	socket_id		Socket to allocate resources on.
/// @param	vdev			Pointer to virtual device structure.
///
/// @return
/// - Cryptodev pointer if device is successfully created.
/// - NULL if device cannot be created.
    pub fn rte_cryptodev_vdev_pmd_init(name: *const ::std::os::raw::c_char,
                                       dev_private_size: usize,
                                       socket_id: ::std::os::raw::c_int,
                                       vdev: *mut rte_vdev_device)
     -> *mut rte_cryptodev;
}
extern "C" {
    /// @internal
/// Parse virtual device initialisation parameters input arguments
///
/// @params	params		Initialisation parameters with defaults set.
/// @params	input_args	Command line arguments
///
/// @return
/// 0 on successful parse
/// <0 on failure to parse
    pub fn rte_cryptodev_vdev_parse_init_params(params:
                                                    *mut rte_crypto_vdev_init_params,
                                                input_args:
                                                    *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum timer_source { EAL_TIMER_TSC = 0, EAL_TIMER_HPET = 1, }
extern "C" {
    #[link_name = "eal_timer_source"]
    pub static mut eal_timer_source: timer_source;
}
extern "C" {
    /// Get the measured frequency of the RDTSC counter
///
/// @return
/// The TSC frequency for this lcore
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    #[link_name = "rte_delay_us"]
    pub static mut rte_delay_us:
               ::std::option::Option<unsafe extern "C" fn(us:
                                                              ::std::os::raw::c_uint)>;
}
extern "C" {
    /// Blocking delay function.
///
/// @param us
/// Number of microseconds to wait.
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    /// Replace rte_delay_us with user defined function.
///
/// @param userfunc
/// User function which replaces rte_delay_us. rte_delay_us_block restores
/// buildin block delay function.
    pub fn rte_delay_us_callback_register(userfunc:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             ::std::os::raw::c_uint)>);
}
extern "C" {
    #[link_name = "rte_cycles_vmware_tsc_map"]
    pub static mut rte_cycles_vmware_tsc_map: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_dev_reg_info {
    /// < Buffer for return registers
    pub data: *mut ::std::os::raw::c_void,
    /// < Start register table location for access
    pub offset: u32,
    /// < Number of registers to fetch
    pub length: u32,
    /// < Size of device register
    pub width: u32,
    /// < Device version
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(::std::mem::size_of::<rte_dev_reg_info>() , 24usize , concat !
               ( "Size of: " , stringify ! ( rte_dev_reg_info ) ));
    assert_eq! (::std::mem::align_of::<rte_dev_reg_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_dev_reg_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_reg_info ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . offset as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_reg_info ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . length as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_reg_info ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . width as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_reg_info ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . version as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_reg_info ) ,
                "::" , stringify ! ( version ) ));
}
impl Clone for rte_dev_reg_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_dev_eeprom_info {
    /// < Buffer for return eeprom
    pub data: *mut ::std::os::raw::c_void,
    /// < Start eeprom address for access
    pub offset: u32,
    /// < Length of eeprom region to access
    pub length: u32,
    /// < Device-specific key, such as device-id
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(::std::mem::size_of::<rte_dev_eeprom_info>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( rte_dev_eeprom_info ) ));
    assert_eq! (::std::mem::align_of::<rte_dev_eeprom_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_dev_eeprom_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_eeprom_info ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_eeprom_info ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . length as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_eeprom_info ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . magic as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_dev_eeprom_info ) ,
                "::" , stringify ! ( magic ) ));
}
impl Clone for rte_dev_eeprom_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_distributor_alg_type {
    RTE_DIST_ALG_BURST = 0,
    RTE_DIST_ALG_SINGLE = 1,
    RTE_DIST_NUM_ALG_TYPES = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_distributor {
    _unused: [u8; 0],
}
extern "C" {
    /// Function to create a new distributor instance
///
/// Reserves the memory needed for the distributor operation and
/// initializes the distributor to work with the configured number of workers.
///
/// @param name
/// The name to be given to the distributor instance.
/// @param socket_id
/// The NUMA node on which the memory is to be allocated
/// @param num_workers
/// The maximum number of workers that will request packets from this
/// distributor
/// @param alg_type
/// Call the legacy API, or use the new burst API. legacy uses 32-bit
/// flow ID, and works on a single packet at a time. Latest uses 15-
/// bit flow ID and works on up to 8 packets at a time to worers.
/// @return
/// The newly created distributor instance
    pub fn rte_distributor_create(name: *const ::std::os::raw::c_char,
                                  socket_id: ::std::os::raw::c_uint,
                                  num_workers: ::std::os::raw::c_uint,
                                  alg_type: ::std::os::raw::c_uint)
     -> *mut rte_distributor;
}
extern "C" {
    /// Process a set of packets by distributing them among workers that request
/// packets. The distributor will ensure that no two packets that have the
/// same flow id, or tag, in the mbuf will be processed on different cores at
/// the same time.
///
/// The user is advocated to set tag for each mbuf before calling this function.
/// If user doesn't set the tag, the tag value can be various values depending on
/// driver implementation and configuration.
///
/// This is not multi-thread safe and should only be called on a single lcore.
///
/// @param d
/// The distributor instance to be used
/// @param mbufs
/// The mbufs to be distributed
/// @param num_mbufs
/// The number of mbufs in the mbufs array
/// @return
/// The number of mbufs processed.
    pub fn rte_distributor_process(d: *mut rte_distributor,
                                   mbufs: *mut *mut rte_mbuf,
                                   num_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get a set of mbufs that have been returned to the distributor by workers
///
/// This should only be called on the same lcore as rte_distributor_process()
///
/// @param d
/// The distributor instance to be used
/// @param mbufs
/// The mbufs pointer array to be filled in
/// @param max_mbufs
/// The size of the mbufs array
/// @return
/// The number of mbufs returned in the mbufs array.
    pub fn rte_distributor_returned_pkts(d: *mut rte_distributor,
                                         mbufs: *mut *mut rte_mbuf,
                                         max_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Flush the distributor component, so that there are no in-flight or
/// backlogged packets awaiting processing
///
/// This should only be called on the same lcore as rte_distributor_process()
///
/// @param d
/// The distributor instance to be used
/// @return
/// The number of queued/in-flight packets that were completed by this call.
    pub fn rte_distributor_flush(d: *mut rte_distributor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Clears the array of returned packets used as the source for the
/// rte_distributor_returned_pkts() API call.
///
/// This should only be called on the same lcore as rte_distributor_process()
///
/// @param d
/// The distributor instance to be used
    pub fn rte_distributor_clear_returns(d: *mut rte_distributor);
}
extern "C" {
    /// API called by a worker to get new packets to process. Any previous packets
/// given to the worker is assumed to have completed processing, and may be
/// optionally returned to the distributor via the oldpkt parameter.
///
/// @param d
/// The distributor instance to be used
/// @param worker_id
/// The worker instance number to use - must be less that num_workers passed
/// at distributor creation time.
/// @param pkts
/// The mbufs pointer array to be filled in (up to 8 packets)
/// @param oldpkt
/// The previous packet, if any, being processed by the worker
/// @param retcount
/// The number of packets being returned
///
/// @return
/// The number of packets in the pkts array
    pub fn rte_distributor_get_pkt(d: *mut rte_distributor,
                                   worker_id: ::std::os::raw::c_uint,
                                   pkts: *mut *mut rte_mbuf,
                                   oldpkt: *mut *mut rte_mbuf,
                                   retcount: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// API called by a worker to return a completed packet without requesting a
/// new packet, for example, because a worker thread is shutting down
///
/// @param d
/// The distributor instance to be used
/// @param worker_id
/// The worker instance number to use - must be less that num_workers passed
/// at distributor creation time.
/// @param oldpkt
/// The previous packets being processed by the worker
/// @param num
/// The number of packets in the oldpkt array
    pub fn rte_distributor_return_pkt(d: *mut rte_distributor,
                                      worker_id: ::std::os::raw::c_uint,
                                      oldpkt: *mut *mut rte_mbuf,
                                      num: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// API called by a worker to request a new packet to process.
/// Any previous packet given to the worker is assumed to have completed
/// processing, and may be optionally returned to the distributor via
/// the oldpkt parameter.
/// Unlike rte_distributor_get_pkt_burst(), this function does not wait for a
/// new packet to be provided by the distributor.
///
/// NOTE: after calling this function, rte_distributor_poll_pkt_burst() should
/// be used to poll for the packet requested. The rte_distributor_get_pkt_burst()
/// API should *not* be used to try and retrieve the new packet.
///
/// @param d
/// The distributor instance to be used
/// @param worker_id
/// The worker instance number to use - must be less that num_workers passed
/// at distributor creation time.
/// @param oldpkt
/// The returning packets, if any, processed by the worker
/// @param count
/// The number of returning packets
    pub fn rte_distributor_request_pkt(d: *mut rte_distributor,
                                       worker_id: ::std::os::raw::c_uint,
                                       oldpkt: *mut *mut rte_mbuf,
                                       count: ::std::os::raw::c_uint);
}
extern "C" {
    /// API called by a worker to check for a new packet that was previously
/// requested by a call to rte_distributor_request_pkt(). It does not wait
/// for the new packet to be available, but returns NULL if the request has
/// not yet been fulfilled by the distributor.
///
/// @param d
/// The distributor instance to be used
/// @param worker_id
/// The worker instance number to use - must be less that num_workers passed
/// at distributor creation time.
/// @param mbufs
/// The array of mbufs being given to the worker
///
/// @return
/// The number of packets being given to the worker thread, zero if no
/// packet is yet available.
    pub fn rte_distributor_poll_pkt(d: *mut rte_distributor,
                                    worker_id: ::std::os::raw::c_uint,
                                    mbufs: *mut *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
pub type efd_value_t = u8;
pub type efd_lookuptbl_t = u16;
pub type efd_hashfunc_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_efd_table {
    _unused: [u8; 0],
}
extern "C" {
    /// Creates an EFD table with a single offline region and multiple per-socket
/// internally-managed copies of the online table used for lookups
///
/// @param name
/// EFD table name
/// @param max_num_rules
/// Minimum number of rules the table should be sized to hold.
/// Will be rounded up to the next smallest valid table size
/// @param key_len
/// Length of the key
/// @param online_cpu_socket_bitmask
/// Bitmask specifying which sockets should get a copy of the online table.
/// LSB = socket 0, etc.
/// @param offline_cpu_socket
/// Identifies the socket where the offline table will be allocated
/// (and most efficiently accessed in the case of updates/insertions)
///
/// @return
/// EFD table, or NULL if table allocation failed or the bitmask is invalid
    pub fn rte_efd_create(name: *const ::std::os::raw::c_char,
                          max_num_rules: u32, key_len: u32,
                          online_cpu_socket_bitmask: u8,
                          offline_cpu_socket: u8) -> *mut rte_efd_table;
}
extern "C" {
    /// Releases the resources from an EFD table
///
/// @param table
/// Table to free
    pub fn rte_efd_free(table: *mut rte_efd_table);
}
extern "C" {
    /// Find an existing EFD table object and return a pointer to it.
///
/// @param name
/// Name of the EFD table as passed to rte_efd_create()
/// @return
/// Pointer to EFD table or NULL if object not found
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - value not available for return
    pub fn rte_efd_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_efd_table;
}
extern "C" {
    /// Computes an updated table entry for the supplied key/value pair.
/// The update is then immediately applied to the provided table and
/// all socket-local copies of the chunks are updated.
/// This operation is not multi-thread safe
/// and should only be called one from thread.
///
/// @param table
/// EFD table to reference
/// @param socket_id
/// Socket ID to use to lookup existing value (ideally caller's socket id)
/// @param key
/// EFD table key to modify
/// @param value
/// Value to associate with the key
///
/// @return
/// RTE_EFD_UPDATE_WARN_GROUP_FULL
/// Operation is insert, and the last available space in the
/// key's group was just used
/// Future inserts may fail as groups fill up
/// This operation was still successful, and entry contains a valid update
/// RTE_EFD_UPDATE_FAILED
/// Either the EFD failed to find a suitable perfect hash or the group was full
/// This is a fatal error, and the table is now in an indeterminite state
/// RTE_EFD_UPDATE_NO_CHANGE
/// Operation resulted in no change to the table (same value already exists)
/// 0 - success
    pub fn rte_efd_update(table: *mut rte_efd_table,
                          socket_id: ::std::os::raw::c_uint,
                          key: *const ::std::os::raw::c_void,
                          value: efd_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Removes any value currently associated with the specified key from the table
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param table
/// EFD table to reference
/// @param socket_id
/// Socket ID to use to lookup existing value (ideally caller's socket id)
/// @param key
/// EFD table key to delete
/// @param prev_value
/// If not NULL, will store the previous value here before deleting it
///
/// @return
/// 0 - successfully found and deleted the key
/// nonzero otherwise
    pub fn rte_efd_delete(table: *mut rte_efd_table,
                          socket_id: ::std::os::raw::c_uint,
                          key: *const ::std::os::raw::c_void,
                          prev_value: *mut efd_value_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Looks up the value associated with a key
/// This operation is multi-thread safe.
///
/// NOTE: Lookups will *always* succeed - this is a property of
/// using a perfect hash table.
/// If the specified key was never inserted, a pseudorandom answer will be returned.
/// There is no way to know based on the lookup if the key was ever inserted
/// originally, so this must be tracked elsewhere.
///
/// @param table
/// EFD table to reference
/// @param socket_id
/// Socket ID to use to lookup existing value (ideally caller's socket id)
/// @param key
/// EFD table key to look up
///
/// @return
/// Value associated with the key, or random junk if they key was never inserted
    pub fn rte_efd_lookup(table: *const rte_efd_table,
                          socket_id: ::std::os::raw::c_uint,
                          key: *const ::std::os::raw::c_void) -> efd_value_t;
}
extern "C" {
    /// Looks up the value associated with several keys.
/// This operation is multi-thread safe.
///
/// NOTE: Lookups will *always* succeed - this is a property of
/// using a perfect hash table.
/// If the specified key was never inserted, a pseudorandom answer will be returned.
/// There is no way to know based on the lookup if the key was ever inserted
/// originally, so this must be tracked elsewhere.
///
/// @param table
/// EFD table to reference
/// @param socket_id
/// Socket ID to use to lookup existing value (ideally caller's socket id)
/// @param num_keys
/// Number of keys in the key_list array, must be less than RTE_EFD_BURST_MAX
/// @param key_list
/// Array of num_keys pointers which point to keys to look up
/// @param value_list
/// Array of size num_keys where lookup values will be stored
    pub fn rte_efd_lookup_bulk(table: *const rte_efd_table,
                               socket_id: ::std::os::raw::c_uint,
                               num_keys: ::std::os::raw::c_int,
                               key_list: *mut *const ::std::os::raw::c_void,
                               value_list: *mut efd_value_t);
}
#[repr(u32)]
/// Feature filter types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_type {
    RTE_ETH_FILTER_NONE = 0,
    RTE_ETH_FILTER_MACVLAN = 1,
    RTE_ETH_FILTER_ETHERTYPE = 2,
    RTE_ETH_FILTER_FLEXIBLE = 3,
    RTE_ETH_FILTER_SYN = 4,
    RTE_ETH_FILTER_NTUPLE = 5,
    RTE_ETH_FILTER_TUNNEL = 6,
    RTE_ETH_FILTER_FDIR = 7,
    RTE_ETH_FILTER_HASH = 8,
    RTE_ETH_FILTER_L2_TUNNEL = 9,
    RTE_ETH_FILTER_GENERIC = 10,
    RTE_ETH_FILTER_MAX = 11,
}
#[repr(u32)]
/// Generic operations on filters
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_op {
    RTE_ETH_FILTER_NOP = 0,
    RTE_ETH_FILTER_ADD = 1,
    RTE_ETH_FILTER_UPDATE = 2,
    RTE_ETH_FILTER_DELETE = 3,
    RTE_ETH_FILTER_FLUSH = 4,
    RTE_ETH_FILTER_GET = 5,
    RTE_ETH_FILTER_SET = 6,
    RTE_ETH_FILTER_INFO = 7,
    RTE_ETH_FILTER_STATS = 8,
    RTE_ETH_FILTER_OP_MAX = 9,
}
#[repr(u32)]
/// MAC filter type
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_mac_filter_type {
    RTE_MAC_PERFECT_MATCH = 1,
    RTE_MACVLAN_PERFECT_MATCH = 2,
    RTE_MAC_HASH_MATCH = 3,
    RTE_MACVLAN_HASH_MATCH = 4,
}
/// MAC filter info
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_mac_filter {
    /// < 1 for VF, 0 for port dev
    pub is_vf: u8,
    /// < VF ID, available when is_vf is 1
    pub dst_id: u16,
    /// < MAC filter type
    pub filter_type: rte_mac_filter_type,
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_mac_filter>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_mac_filter ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_mac_filter>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_mac_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . is_vf as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mac_filter ) ,
                "::" , stringify ! ( is_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . dst_id as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mac_filter ) ,
                "::" , stringify ! ( dst_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . filter_type as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mac_filter ) ,
                "::" , stringify ! ( filter_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . mac_addr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mac_filter ) ,
                "::" , stringify ! ( mac_addr ) ));
}
impl Clone for rte_eth_mac_filter {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the ethertype filter entry
/// to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ethertype_filter {
    /// < Mac address to match.
    pub mac_addr: ether_addr,
    /// < Ether type to match
    pub ether_type: u16,
    /// < Flags from RTE_ETHTYPE_FLAGS_*
    pub flags: u16,
    /// < Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_ethertype_filter>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_ethertype_filter ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_ethertype_filter>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_ethertype_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . mac_addr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_ethertype_filter ) , "::" , stringify ! ( mac_addr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . ether_type
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_ethertype_filter ) , "::" , stringify ! ( ether_type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_ethertype_filter ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . queue as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_ethertype_filter ) , "::" , stringify ! ( queue ) ));
}
impl Clone for rte_eth_ethertype_filter {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the flex filter entry
/// to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    /// < flex bytes in big endian.
    pub bytes: [u8; 128usize],
    /// < if mask bit is 1b, do
    /// not compare corresponding byte.
    pub mask: [u8; 16usize],
    pub priority: u8,
    /// < Queue assigned to when match.
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_flex_filter>() , 150usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_flex_filter )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_flex_filter>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_flex_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . len as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_flex_filter ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . bytes as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_flex_filter ) ,
                "::" , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . mask as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_flex_filter ) ,
                "::" , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . priority as *
                const _ as usize } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_flex_filter ) ,
                "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . queue as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_flex_filter ) ,
                "::" , stringify ! ( queue ) ));
}
/// A structure used to define the TCP syn filter entry
/// to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_syn_filter {
    /// < 1 - higher priority than other filters,
    /// 0 - lower priority.
    pub hig_pri: u8,
    /// < Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_syn_filter>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_syn_filter ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_syn_filter>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_syn_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_syn_filter ) ) . hig_pri as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_syn_filter ) ,
                "::" , stringify ! ( hig_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_syn_filter ) ) . queue as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_syn_filter ) ,
                "::" , stringify ! ( queue ) ));
}
impl Clone for rte_eth_syn_filter {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the ntuple filter entry
/// to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ntuple_filter {
    /// < Flags from RTE_NTUPLE_FLAGS_*
    pub flags: u16,
    /// < Destination IP address in big endian.
    pub dst_ip: u32,
    /// < Mask of destination IP address.
    pub dst_ip_mask: u32,
    /// < Source IP address in big endian.
    pub src_ip: u32,
    /// < Mask of destination IP address.
    pub src_ip_mask: u32,
    /// < Destination port in big endian.
    pub dst_port: u16,
    /// < Mask of destination port.
    pub dst_port_mask: u16,
    /// < Source Port in big endian.
    pub src_port: u16,
    /// < Mask of source port.
    pub src_port_mask: u16,
    /// < L4 protocol.
    pub proto: u8,
    /// < Mask of L4 protocol.
    pub proto_mask: u8,
    /// tcp_flags only meaningful when the proto is TCP.
    /// The packet matched above ntuple fields and contain
    /// any set bit in tcp_flags will hit this filter.
    pub tcp_flags: u8,
    /// < seven levels (001b-111b), 111b is highest,
    /// used when more than one filter matches.
    pub priority: u16,
    /// < Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_ntuple_filter>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_ntuple_filter )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_ntuple_filter>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_ntuple_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_ip as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( dst_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_ip_mask
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( dst_ip_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_ip as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( src_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_ip_mask
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( src_ip_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_port as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_port_mask
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( dst_port_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_port as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_port_mask
                as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( src_port_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . proto as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . proto_mask as
                * const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( proto_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . tcp_flags as
                * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( tcp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . priority as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . queue as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ntuple_filter )
                , "::" , stringify ! ( queue ) ));
}
impl Clone for rte_eth_ntuple_filter {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Tunneled type.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_tunnel_type {
    RTE_TUNNEL_TYPE_NONE = 0,
    RTE_TUNNEL_TYPE_VXLAN = 1,
    RTE_TUNNEL_TYPE_GENEVE = 2,
    RTE_TUNNEL_TYPE_TEREDO = 3,
    RTE_TUNNEL_TYPE_NVGRE = 4,
    RTE_TUNNEL_TYPE_IP_IN_GRE = 5,
    RTE_L2_TUNNEL_TYPE_E_TAG = 6,
    RTE_TUNNEL_TYPE_MAX = 7,
}
#[repr(u32)]
/// Select IPv4 or IPv6 for tunnel filters.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tunnel_iptype {
    RTE_TUNNEL_IPTYPE_IPV4 = 0,
    RTE_TUNNEL_IPTYPE_IPV6 = 1,
}
/// Tunneling Packet filter configuration.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_filter_conf {
    /// < Outer MAC address to match.
    pub outer_mac: ether_addr,
    /// < Inner MAC address to match.
    pub inner_mac: ether_addr,
    /// < Inner VLAN to match.
    pub inner_vlan: u16,
    /// < IP address type.
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    /// Flags from ETH_TUNNEL_FILTER_XX - see above.
    pub filter_type: u16,
    /// < Tunnel Type.
    pub tunnel_type: rte_eth_tunnel_type,
    /// < Tenant ID to match. VNI, GRE key...
    pub tenant_id: u32,
    /// < Queue assigned to if match.
    pub queue_id: u16,
}
/// Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP
/// is set in filter_type, or inner destination IP address to match
/// if ETH_TUNNEL_FILTER_IIP is set in filter_type .
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    /// < IPv4 address in big endian.
    pub ipv4_addr: __BindgenUnionField<u32>,
    /// < IPv6 address in big endian.
    pub ipv6_addr: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_eth_tunnel_filter_conf__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_tunnel_filter_conf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_tunnel_filter_conf__bindgen_ty_1 ) )
                . ipv4_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf__bindgen_ty_1 ) , "::" , stringify
                ! ( ipv4_addr ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_tunnel_filter_conf__bindgen_ty_1 ) )
                . ipv6_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf__bindgen_ty_1 ) , "::" , stringify
                ! ( ipv6_addr ) ));
}
impl Clone for rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_filter_conf>() , 52usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_tunnel_filter_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_filter_conf>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_eth_tunnel_filter_conf )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                outer_mac as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( outer_mac
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                inner_mac as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( inner_mac
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                inner_vlan as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( inner_vlan
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . ip_type
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( ip_type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . ip_addr
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( ip_addr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                filter_type as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! (
                filter_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                tunnel_type as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! (
                tunnel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                tenant_id as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( tenant_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . queue_id
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_tunnel_filter_conf ) , "::" , stringify ! ( queue_id )
                ));
}
impl Clone for rte_eth_tunnel_filter_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Global eth device configuration type.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_global_cfg_type {
    RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN = 0,
    RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN = 1,
    RTE_ETH_GLOBAL_CFG_TYPE_MAX = 2,
}
/// Global eth device configuration.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_global_cfg {
    /// < Global config type.
    pub cfg_type: rte_eth_global_cfg_type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_global_cfg__bindgen_ty_1 {
    /// < Valid GRE key length in byte.
    pub gre_key_len: __BindgenUnionField<u8>,
    /// < Reserve space for future use.
    pub reserved: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_global_cfg__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_global_cfg__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg__bindgen_ty_1 ) ) .
                gre_key_len as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_global_cfg__bindgen_ty_1 ) , "::" , stringify ! (
                gre_key_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_global_cfg__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for rte_eth_global_cfg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(::std::mem::size_of::<rte_eth_global_cfg>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_global_cfg ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_global_cfg>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_global_cfg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg ) ) . cfg_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_global_cfg ) ,
                "::" , stringify ! ( cfg_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg ) ) . cfg as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_global_cfg ) ,
                "::" , stringify ! ( cfg ) ));
}
impl Clone for rte_eth_global_cfg {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Input set fields for Flow Director and Hash filters
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_input_set_field {
    RTE_ETH_INPUT_SET_UNKNOWN = 0,
    RTE_ETH_INPUT_SET_L2_SRC_MAC = 1,
    RTE_ETH_INPUT_SET_L2_DST_MAC = 2,
    RTE_ETH_INPUT_SET_L2_OUTER_VLAN = 3,
    RTE_ETH_INPUT_SET_L2_INNER_VLAN = 4,
    RTE_ETH_INPUT_SET_L2_ETHERTYPE = 5,
    RTE_ETH_INPUT_SET_L3_SRC_IP4 = 129,
    RTE_ETH_INPUT_SET_L3_DST_IP4 = 130,
    RTE_ETH_INPUT_SET_L3_SRC_IP6 = 131,
    RTE_ETH_INPUT_SET_L3_DST_IP6 = 132,
    RTE_ETH_INPUT_SET_L3_IP4_TOS = 133,
    RTE_ETH_INPUT_SET_L3_IP4_PROTO = 134,
    RTE_ETH_INPUT_SET_L3_IP6_TC = 135,
    RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER = 136,
    RTE_ETH_INPUT_SET_L3_IP4_TTL = 137,
    RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS = 138,
    RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT = 257,
    RTE_ETH_INPUT_SET_L4_UDP_DST_PORT = 258,
    RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT = 259,
    RTE_ETH_INPUT_SET_L4_TCP_DST_PORT = 260,
    RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT = 261,
    RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT = 262,
    RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG = 263,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC = 385,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC = 386,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN = 387,
    RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY = 388,
    RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY = 389,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD = 641,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD = 642,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD = 643,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD = 644,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD = 645,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD = 646,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD = 647,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD = 648,
    RTE_ETH_INPUT_SET_DEFAULT = 65533,
    RTE_ETH_INPUT_SET_NONE = 65534,
    RTE_ETH_INPUT_SET_MAX = 65535,
}
#[repr(u32)]
/// Filters input set operations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_input_set_op {
    RTE_ETH_INPUT_SET_OP_UNKNOWN = 0,
    RTE_ETH_INPUT_SET_SELECT = 1,
    RTE_ETH_INPUT_SET_ADD = 2,
    RTE_ETH_INPUT_SET_OP_MAX = 3,
}
/// A structure used to define the input set configuration for
/// flow director and hash filters
#[repr(C)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_input_set_conf>() , 520usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_input_set_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_input_set_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_input_set_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . flow_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_input_set_conf
                ) , "::" , stringify ! ( flow_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . inset_size
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_input_set_conf
                ) , "::" , stringify ! ( inset_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . field as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_input_set_conf
                ) , "::" , stringify ! ( field ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . op as *
                const _ as usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_input_set_conf
                ) , "::" , stringify ! ( op ) ));
}
/// A structure used to define the input for L2 flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_l2_flow {
    /// < Ether type in big endian
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_l2_flow>() , 2usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_l2_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_l2_flow>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_l2_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_flow ) ) . ether_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_flow ) ,
                "::" , stringify ! ( ether_type ) ));
}
impl Clone for rte_eth_l2_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV4 flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ipv4_flow {
    /// < IPv4 source address in big endian.
    pub src_ip: u32,
    /// < IPv4 destination address in big endian.
    pub dst_ip: u32,
    /// < Type of service to match.
    pub tos: u8,
    /// < Time to live to match.
    pub ttl: u8,
    /// < Protocol, next header in big endian.
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_ipv4_flow>() , 12usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_ipv4_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_ipv4_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_ipv4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . src_ip as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv4_flow ) ,
                "::" , stringify ! ( src_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . dst_ip as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv4_flow ) ,
                "::" , stringify ! ( dst_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . tos as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv4_flow ) ,
                "::" , stringify ! ( tos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . ttl as * const _
                as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv4_flow ) ,
                "::" , stringify ! ( ttl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . proto as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv4_flow ) ,
                "::" , stringify ! ( proto ) ));
}
impl Clone for rte_eth_ipv4_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV4 UDP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udpv4_flow {
    /// < IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    /// < UDP source port in big endian.
    pub src_port: u16,
    /// < UDP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_udpv4_flow>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_udpv4_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_udpv4_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_udpv4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv4_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv4_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv4_flow ) ,
                "::" , stringify ! ( dst_port ) ));
}
impl Clone for rte_eth_udpv4_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV4 TCP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tcpv4_flow {
    /// < IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    /// < TCP source port in big endian.
    pub src_port: u16,
    /// < TCP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tcpv4_flow>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_tcpv4_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_tcpv4_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_tcpv4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv4_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv4_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv4_flow ) ,
                "::" , stringify ! ( dst_port ) ));
}
impl Clone for rte_eth_tcpv4_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV4 SCTP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_sctpv4_flow {
    /// < IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    /// < SCTP source port in big endian.
    pub src_port: u16,
    /// < SCTP destination port in big endian.
    pub dst_port: u16,
    /// < Verify tag in big endian
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_sctpv4_flow>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_sctpv4_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_sctpv4_flow>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_sctpv4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv4_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv4_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv4_flow ) ,
                "::" , stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . verify_tag as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv4_flow ) ,
                "::" , stringify ! ( verify_tag ) ));
}
impl Clone for rte_eth_sctpv4_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV6 flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ipv6_flow {
    /// < IPv6 source address in big endian.
    pub src_ip: [u32; 4usize],
    /// < IPv6 destination address in big endian.
    pub dst_ip: [u32; 4usize],
    /// < Traffic class to match.
    pub tc: u8,
    /// < Protocol, next header to match.
    pub proto: u8,
    /// < Hop limits to match.
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_ipv6_flow>() , 36usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_ipv6_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_ipv6_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_ipv6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . src_ip as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv6_flow ) ,
                "::" , stringify ! ( src_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . dst_ip as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv6_flow ) ,
                "::" , stringify ! ( dst_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . tc as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv6_flow ) ,
                "::" , stringify ! ( tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . proto as * const
                _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv6_flow ) ,
                "::" , stringify ! ( proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . hop_limits as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_ipv6_flow ) ,
                "::" , stringify ! ( hop_limits ) ));
}
impl Clone for rte_eth_ipv6_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV6 UDP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udpv6_flow {
    /// < IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    /// < UDP source port in big endian.
    pub src_port: u16,
    /// < UDP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_udpv6_flow>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_udpv6_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_udpv6_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_udpv6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv6_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv6_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udpv6_flow ) ,
                "::" , stringify ! ( dst_port ) ));
}
impl Clone for rte_eth_udpv6_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV6 TCP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tcpv6_flow {
    /// < IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    /// < TCP source port to in big endian.
    pub src_port: u16,
    /// < TCP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tcpv6_flow>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_tcpv6_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_tcpv6_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_tcpv6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv6_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv6_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tcpv6_flow ) ,
                "::" , stringify ! ( dst_port ) ));
}
impl Clone for rte_eth_tcpv6_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for IPV6 SCTP flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_sctpv6_flow {
    /// < IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    /// < SCTP source port in big endian.
    pub src_port: u16,
    /// < SCTP destination port in big endian.
    pub dst_port: u16,
    /// < Verify tag in big endian.
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_sctpv6_flow>() , 44usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_sctpv6_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_sctpv6_flow>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_sctpv6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv6_flow ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv6_flow ) ,
                "::" , stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv6_flow ) ,
                "::" , stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . verify_tag as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_sctpv6_flow ) ,
                "::" , stringify ! ( verify_tag ) ));
}
impl Clone for rte_eth_sctpv6_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for MAC VLAN flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_mac_vlan_flow {
    /// < Mac address to match.
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_mac_vlan_flow>() , 6usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_mac_vlan_flow )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_mac_vlan_flow>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_mac_vlan_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_vlan_flow ) ) . mac_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mac_vlan_flow )
                , "::" , stringify ! ( mac_addr ) ));
}
impl Clone for rte_eth_mac_vlan_flow {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Tunnel type for flow director.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_tunnel_type {
    RTE_FDIR_TUNNEL_TYPE_UNKNOWN = 0,
    RTE_FDIR_TUNNEL_TYPE_NVGRE = 1,
    RTE_FDIR_TUNNEL_TYPE_VXLAN = 2,
}
/// A structure used to define the input for tunnel flow, now it's VxLAN or
/// NVGRE
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_flow {
    /// < Tunnel type to match.
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    /// Tunnel ID to match. TNI, VNI... in big endian.
    pub tunnel_id: u32,
    /// < Mac address to match.
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_flow>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_tunnel_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_flow>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_tunnel_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . tunnel_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tunnel_flow ) ,
                "::" , stringify ! ( tunnel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . tunnel_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tunnel_flow ) ,
                "::" , stringify ! ( tunnel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . mac_addr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_tunnel_flow ) ,
                "::" , stringify ! ( mac_addr ) ));
}
impl Clone for rte_eth_tunnel_flow {
    fn clone(&self) -> Self { *self }
}
/// An union contains the inputs for all types of flow
/// Items in flows need to be in big endian
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flow {
    pub l2_flow: __BindgenUnionField<rte_eth_l2_flow>,
    pub udp4_flow: __BindgenUnionField<rte_eth_udpv4_flow>,
    pub tcp4_flow: __BindgenUnionField<rte_eth_tcpv4_flow>,
    pub sctp4_flow: __BindgenUnionField<rte_eth_sctpv4_flow>,
    pub ip4_flow: __BindgenUnionField<rte_eth_ipv4_flow>,
    pub udp6_flow: __BindgenUnionField<rte_eth_udpv6_flow>,
    pub tcp6_flow: __BindgenUnionField<rte_eth_tcpv6_flow>,
    pub sctp6_flow: __BindgenUnionField<rte_eth_sctpv6_flow>,
    pub ipv6_flow: __BindgenUnionField<rte_eth_ipv6_flow>,
    pub mac_vlan_flow: __BindgenUnionField<rte_eth_mac_vlan_flow>,
    pub tunnel_flow: __BindgenUnionField<rte_eth_tunnel_flow>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flow>() , 44usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_fdir_flow ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flow>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_fdir_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . l2_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( l2_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . udp4_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( udp4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tcp4_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( tcp4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . sctp4_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( sctp4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . ip4_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( ip4_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . udp6_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( udp6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tcp6_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( tcp6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . sctp6_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( sctp6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . ipv6_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( ipv6_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . mac_vlan_flow as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( mac_vlan_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tunnel_flow as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow ) ,
                "::" , stringify ! ( tunnel_flow ) ));
}
impl Clone for rte_eth_fdir_flow {
    fn clone(&self) -> Self { *self }
}
/// A structure used to contain extend input of flow
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    /// < 1 for VF, 0 for port dev
    pub is_vf: u8,
    /// < VF ID, available when is_vf is 1
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flow_ext>() , 22usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_fdir_flow_ext )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flow_ext>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_flow_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . vlan_tci as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow_ext )
                , "::" , stringify ! ( vlan_tci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . flexbytes as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow_ext )
                , "::" , stringify ! ( flexbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . is_vf as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow_ext )
                , "::" , stringify ! ( is_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . dst_id as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flow_ext )
                , "::" , stringify ! ( dst_id ) ));
}
impl Clone for rte_eth_fdir_flow_ext {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the input for a flow director filter entry
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_input>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_input ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_input>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_fdir_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_input ) ,
                "::" , stringify ! ( flow_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_input ) ,
                "::" , stringify ! ( flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow_ext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_input ) ,
                "::" , stringify ! ( flow_ext ) ));
}
impl Clone for rte_eth_fdir_input {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Behavior will be taken if FDIR match
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_behavior {
    RTE_ETH_FDIR_ACCEPT = 0,
    RTE_ETH_FDIR_REJECT = 1,
    RTE_ETH_FDIR_PASSTHRU = 2,
}
#[repr(u32)]
/// Flow director report status
/// It defines what will be reported if FDIR entry is matched.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_status {
    RTE_ETH_FDIR_NO_REPORT_STATUS = 0,
    RTE_ETH_FDIR_REPORT_ID = 1,
    RTE_ETH_FDIR_REPORT_ID_FLEX_4 = 2,
    RTE_ETH_FDIR_REPORT_FLEX_8 = 3,
}
/// A structure used to define an action when match FDIR packet filter.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_action {
    /// < Queue assigned to if FDIR match.
    pub rx_queue: u16,
    /// < Behavior will be taken
    pub behavior: rte_eth_fdir_behavior,
    /// < Status report option
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_action>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_action ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_action>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . rx_queue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_action ) ,
                "::" , stringify ! ( rx_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . behavior as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_action ) ,
                "::" , stringify ! ( behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . report_status
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_action ) ,
                "::" , stringify ! ( report_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . flex_off as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_action ) ,
                "::" , stringify ! ( flex_off ) ));
}
impl Clone for rte_eth_fdir_action {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the flow director filter entry by filter_ctrl API
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and
/// RTE_ETH_FILTER_DELETE operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    /// < Input set
    pub input: rte_eth_fdir_input,
    /// < Action taken when match
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter>() , 92usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_filter ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . soft_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_filter ) ,
                "::" , stringify ! ( soft_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . input as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_filter ) ,
                "::" , stringify ! ( input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . action as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_filter ) ,
                "::" , stringify ! ( action ) ));
}
impl Clone for rte_eth_fdir_filter {
    fn clone(&self) -> Self { *self }
}
/// A structure used to configure FDIR masks that are used by the device
/// to match the various fields of RX packet headers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_masks {
    /// < Bit mask for vlan_tci in big endian
    pub vlan_tci_mask: u16,
    /// Bit mask for ipv4 flow in big endian.
    pub ipv4_mask: rte_eth_ipv4_flow,
    /// Bit maks for ipv6 flow in big endian.
    pub ipv6_mask: rte_eth_ipv6_flow,
    /// Bit mask for L4 source port in big endian.
    pub src_port_mask: u16,
    /// Bit mask for L4 destination port in big endian.
    pub dst_port_mask: u16,
    /// 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the
    /// first byte on the wire
    pub mac_addr_byte_mask: u8,
    /// Bit mask for tunnel ID in big endian.
    pub tunnel_id_mask: u32,
    /// < 1 - Match tunnel type,
    /// 0 - Ignore tunnel type.
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_masks>() , 68usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_masks ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_masks>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_fdir_masks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . vlan_tci_mask as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( vlan_tci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . ipv4_mask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( ipv4_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . ipv6_mask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( ipv6_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . src_port_mask as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( src_port_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . dst_port_mask as
                * const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( dst_port_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) .
                mac_addr_byte_mask as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( mac_addr_byte_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . tunnel_id_mask
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( tunnel_id_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . tunnel_type_mask
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_masks ) ,
                "::" , stringify ! ( tunnel_type_mask ) ));
}
impl Clone for rte_eth_fdir_masks {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Payload type
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_payload_type {
    RTE_ETH_PAYLOAD_UNKNOWN = 0,
    RTE_ETH_RAW_PAYLOAD = 1,
    RTE_ETH_L2_PAYLOAD = 2,
    RTE_ETH_L3_PAYLOAD = 3,
    RTE_ETH_L4_PAYLOAD = 4,
    RTE_ETH_PAYLOAD_MAX = 8,
}
/// A structure used to select bytes extracted from the protocol layers to
/// flexible payload for filter
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_flex_payload_cfg {
    /// < Payload type
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(::std::mem::size_of::<rte_eth_flex_payload_cfg>() , 36usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_flex_payload_cfg ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_flex_payload_cfg>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_flex_payload_cfg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_payload_cfg ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_flex_payload_cfg ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_payload_cfg ) ) . src_offset
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_flex_payload_cfg ) , "::" , stringify ! ( src_offset )
                ));
}
impl Clone for rte_eth_flex_payload_cfg {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define FDIR masks for flexible payload
/// for each flow type
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flex_mask>() , 18usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_fdir_flex_mask )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flex_mask>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_flex_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_mask ) ) . flow_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_mask
                ) , "::" , stringify ! ( flow_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_mask ) ) . mask as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_mask
                ) , "::" , stringify ! ( mask ) ));
}
impl Clone for rte_eth_fdir_flex_mask {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define all flexible payload related setting
/// include flex payload and flex mask
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flex_conf {
    /// < The number of following payload cfg
    pub nb_payloads: u16,
    /// < The number of following mask
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 22usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flex_conf>() , 688usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_fdir_flex_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flex_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_flex_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . nb_payloads
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_conf
                ) , "::" , stringify ! ( nb_payloads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . nb_flexmasks
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_conf
                ) , "::" , stringify ! ( nb_flexmasks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . flex_set as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_conf
                ) , "::" , stringify ! ( flex_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . flex_mask as
                * const _ as usize } , 292usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_flex_conf
                ) , "::" , stringify ! ( flex_mask ) ));
}
impl Clone for rte_eth_fdir_flex_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Flow Director setting modes: none, signature or perfect.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_mode {
    RTE_FDIR_MODE_NONE = 0,
    RTE_FDIR_MODE_SIGNATURE = 1,
    RTE_FDIR_MODE_PERFECT = 2,
    RTE_FDIR_MODE_PERFECT_MAC_VLAN = 3,
    RTE_FDIR_MODE_PERFECT_TUNNEL = 4,
}
/// A structure used to get the information of flow director filter.
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation.
/// It includes the mode, flexible payload configuration information,
/// capabilities and supported flow types, flexible payload characters.
/// It can be gotten to help taking specific configurations per device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_info {
    /// < Flow director mode
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    /// Flex payload configuration information
    pub flex_conf: rte_eth_fdir_flex_conf,
    /// < Guaranteed spaces.
    pub guarant_spc: u32,
    /// < Best effort spaces.
    pub best_spc: u32,
    /// Bit mask for every supported flow type.
    pub flow_types_mask: [u32; 1usize],
    /// < Total flex payload in bytes.
    pub max_flexpayload: u32,
    /// Flexible payload unit in bytes. Size and alignments of all flex
    /// payload segments should be multiplies of this value.
    pub flex_payload_unit: u32,
    /// Max number of flexible payload continuous segments.
    /// Each segment should be a multiple of flex_payload_unit.
    pub max_flex_payload_segment_num: u32,
    /// Maximum src_offset in bytes allowed. It indicates that
    /// src_offset[i] in struct rte_eth_flex_payload_cfg should be less
    /// than this value.
    pub flex_payload_limit: u16,
    /// Flex bitmask unit in bytes. Size of flex bitmasks should be a
    /// multiply of this value.
    pub flex_bitmask_unit: u32,
    /// Max supported size of flex bitmasks in flex_bitmask_unit
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_info>() , 796usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_info ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_info>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_fdir_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . mode as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . mask as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_conf as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( flex_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . guarant_spc as *
                const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( guarant_spc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . best_spc as *
                const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( best_spc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flow_types_mask
                as * const _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( flow_types_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . max_flexpayload
                as * const _ as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( max_flexpayload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_payload_unit
                as * const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( flex_payload_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                max_flex_payload_segment_num as * const _ as usize } ,
                780usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( max_flex_payload_segment_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                flex_payload_limit as * const _ as usize } , 784usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( flex_payload_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_bitmask_unit
                as * const _ as usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( flex_bitmask_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                max_flex_bitmask_num as * const _ as usize } , 792usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_info ) ,
                "::" , stringify ! ( max_flex_bitmask_num ) ));
}
impl Clone for rte_eth_fdir_info {
    fn clone(&self) -> Self { *self }
}
/// A structure used to define the statistics of flow director.
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_stats {
    /// < Number of filters with collision.
    pub collision: u32,
    /// < Number of free filters.
    pub free: u32,
    pub maxhash: u32,
    /// < Longest linked list of filters.
    pub maxlen: u32,
    /// < Number of added filters.
    pub add: u64,
    /// < Number of removed filters.
    pub remove: u64,
    /// < Number of failed added filters.
    pub f_add: u64,
    /// < Number of failed removed filters.
    pub f_remove: u64,
    /// < Number of filters in guaranteed spaces.
    pub guarant_cnt: u32,
    /// < Number of filters in best effort spaces.
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_stats>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_fdir_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_fdir_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . collision as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( collision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . free as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . maxhash as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( maxhash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . maxlen as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . add as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . remove as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( remove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . f_add as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( f_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . f_remove as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( f_remove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . guarant_cnt as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( guarant_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . best_cnt as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fdir_stats ) ,
                "::" , stringify ! ( best_cnt ) ));
}
impl Clone for rte_eth_fdir_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Flow Director filter information types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_filter_info_type {
    RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN = 0,
    RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT = 1,
    RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX = 2,
}
/// A structure used to set FDIR filter information, to support filter type
/// of 'RTE_ETH_FILTER_FDIR' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation.
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_fdir_filter_info {
    /// < Information type
    pub info_type: rte_eth_fdir_filter_info_type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
/// Details of fdir filter information
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_fdir_filter_info__bindgen_ty_1 {
    /// Flow Director input set configuration per port
    pub input_set_conf: __BindgenUnionField<rte_eth_input_set_conf>,
    pub bindgen_union_field: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>()
               , 520usize , concat ! (
               "Size of: " , stringify ! (
               rte_eth_fdir_filter_info__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_fdir_filter_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info__bindgen_ty_1 )
                ) . input_set_conf as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_eth_fdir_filter_info__bindgen_ty_1 ) , "::" , stringify !
                ( input_set_conf ) ));
}
impl Clone for rte_eth_fdir_filter_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter_info>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_fdir_filter_info ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_fdir_filter_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info ) ) . info_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_fdir_filter_info ) , "::" , stringify ! ( info_type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info ) ) . info as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_fdir_filter_info ) , "::" , stringify ! ( info ) ));
}
impl Clone for rte_eth_fdir_filter_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Hash filter information types.
/// - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the
/// information/configuration of 'symmetric hash enable' per port.
/// - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global
/// configurations of hash filters. Those global configurations are valid
/// for all ports of the same NIC.
/// - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global
/// hash input set fields
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_hash_filter_info_type {
    RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN = 0,
    RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT = 1,
    RTE_ETH_HASH_FILTER_GLOBAL_CONFIG = 2,
    RTE_ETH_HASH_FILTER_INPUT_SET_SELECT = 3,
    RTE_ETH_HASH_FILTER_INFO_TYPE_MAX = 4,
}
#[repr(u32)]
/// Hash function types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_hash_function {
    RTE_ETH_HASH_FUNCTION_DEFAULT = 0,
    RTE_ETH_HASH_FUNCTION_TOEPLITZ = 1,
    RTE_ETH_HASH_FUNCTION_SIMPLE_XOR = 2,
    RTE_ETH_HASH_FUNCTION_MAX = 3,
}
/// A structure used to set or get global hash function configurations which
/// include symmetric hash enable per flow type and hash function type.
/// Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the
/// corresponding flow type is enabled or not.
/// Each bit in valid_bit_mask[] indicates if the corresponding bit in
/// sym_hash_enable_mask[] is valid or not. For the configurations gotten, it
/// also means if the flow type is supported by hardware or not.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_hash_global_conf {
    /// < Hash function type
    pub hash_func: rte_eth_hash_function,
    /// Bit mask for symmetric hash enable per flow type
    pub sym_hash_enable_mask: [u32; 1usize],
    /// Bit mask indicates if the corresponding bit is valid
    pub valid_bit_mask: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_global_conf>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_hash_global_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_hash_global_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_hash_global_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) . hash_func
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_global_conf ) , "::" , stringify ! ( hash_func )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) .
                sym_hash_enable_mask as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_global_conf ) , "::" , stringify ! (
                sym_hash_enable_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) .
                valid_bit_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_global_conf ) , "::" , stringify ! (
                valid_bit_mask ) ));
}
impl Clone for rte_eth_hash_global_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to set or get hash filter information, to support filter
/// type of 'RTE_ETH_FILTER_HASH' and its operations.
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_hash_filter_info {
    /// < Information type
    pub info_type: rte_eth_hash_filter_info_type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
/// Details of hash filter information
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_hash_filter_info__bindgen_ty_1 {
    /// For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT
    pub enable: __BindgenUnionField<u8>,
    /// Global configurations of hash filter
    pub global_conf: __BindgenUnionField<rte_eth_hash_global_conf>,
    /// Global configurations of hash filter input set
    pub input_set_conf: __BindgenUnionField<rte_eth_input_set_conf>,
    pub bindgen_union_field: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>()
               , 520usize , concat ! (
               "Size of: " , stringify ! (
               rte_eth_hash_filter_info__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_hash_filter_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . enable as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_filter_info__bindgen_ty_1 ) , "::" , stringify !
                ( enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . global_conf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_filter_info__bindgen_ty_1 ) , "::" , stringify !
                ( global_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . input_set_conf as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_filter_info__bindgen_ty_1 ) , "::" , stringify !
                ( input_set_conf ) ));
}
impl Clone for rte_eth_hash_filter_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_filter_info>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_hash_filter_info ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_hash_filter_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_hash_filter_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info ) ) . info_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_filter_info ) , "::" , stringify ! ( info_type )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info ) ) . info as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_hash_filter_info ) , "::" , stringify ! ( info ) ));
}
impl Clone for rte_eth_hash_filter_info {
    fn clone(&self) -> Self { *self }
}
/// l2 tunnel configuration.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_l2_tunnel_conf>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_l2_tunnel_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_l2_tunnel_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_l2_tunnel_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) .
                l2_tunnel_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_tunnel_conf
                ) , "::" , stringify ! ( l2_tunnel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . ether_type
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_tunnel_conf
                ) , "::" , stringify ! ( ether_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . tunnel_id as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_tunnel_conf
                ) , "::" , stringify ! ( tunnel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . vf_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_tunnel_conf
                ) , "::" , stringify ! ( vf_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . pool as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_l2_tunnel_conf
                ) , "::" , stringify ! ( pool ) ));
}
impl Clone for rte_eth_l2_tunnel_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to retrieve statistics for an Ethernet port.
/// Not all statistics fields in struct rte_eth_stats are supported
/// by any type of network interface card (NIC). If any statistics
/// field is not supported, its value is 0.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_stats {
    /// < Total number of successfully received packets.
    pub ipackets: u64,
    /// < Total number of successfully transmitted packets.
    pub opackets: u64,
    /// < Total number of successfully received bytes.
    pub ibytes: u64,
    /// < Total number of successfully transmitted bytes.
    pub obytes: u64,
    pub imissed: u64,
    /// < Total number of erroneous received packets.
    pub ierrors: u64,
    /// < Total number of failed transmitted packets.
    pub oerrors: u64,
    /// < Total number of RX mbuf allocation failures.
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(::std::mem::size_of::<rte_eth_stats>() , 704usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_stats>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ipackets as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . opackets as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ibytes as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . obytes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . imissed as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( imissed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ierrors as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( ierrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . oerrors as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( oerrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . rx_nombuf as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( rx_nombuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_ipackets as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( q_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_opackets as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( q_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_ibytes as * const _
                as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( q_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_obytes as * const _
                as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( q_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_errors as * const _
                as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_stats ) , "::"
                , stringify ! ( q_errors ) ));
}
impl Clone for rte_eth_stats {
    fn clone(&self) -> Self { *self }
}
/// A structure used to retrieve link-level information of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_link {
    /// < ETH_SPEED_NUM_
    pub link_speed: u32,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(::std::mem::size_of::<rte_eth_link>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_link ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_link>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_link ) ) . link_speed as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_link ) , "::" ,
                stringify ! ( link_speed ) ));
}
impl Clone for rte_eth_link {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        let mask = 1u64 as u8;
        let val = val as u16 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        let mask = 2u64 as u8;
        let val = val as u16 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        let mask = 4u64 as u8;
        let val = val as u16 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(link_duplex: u16, link_autoneg: u16,
                          link_status: u16) -> u8 {
        ({
             ({
                  ({ 0 } |
                       ((link_duplex as u16 as u8) << 0usize) & (1u64 as u8))
              } | ((link_autoneg as u16 as u8) << 1usize) & (2u64 as u8))
         } | ((link_status as u16 as u8) << 2usize) & (4u64 as u8))
    }
}
/// A structure used to configure the ring threshold registers of an RX/TX
/// queue for an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_thresh {
    /// < Ring prefetch threshold.
    pub pthresh: u8,
    /// < Ring host threshold.
    pub hthresh: u8,
    /// < Ring writeback threshold.
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(::std::mem::size_of::<rte_eth_thresh>() , 3usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_thresh ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_thresh>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . pthresh as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_thresh ) , "::"
                , stringify ! ( pthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . hthresh as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_thresh ) , "::"
                , stringify ! ( hthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . wthresh as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_thresh ) , "::"
                , stringify ! ( wthresh ) ));
}
impl Clone for rte_eth_thresh {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// A set of values to identify what method is to be used to route
/// packets to multiple queues.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_rx_mq_mode {
    ETH_MQ_RX_NONE = 0,
    ETH_MQ_RX_RSS = 1,
    ETH_MQ_RX_DCB = 2,
    ETH_MQ_RX_DCB_RSS = 3,
    ETH_MQ_RX_VMDQ_ONLY = 4,
    ETH_MQ_RX_VMDQ_RSS = 5,
    ETH_MQ_RX_VMDQ_DCB = 6,
    ETH_MQ_RX_VMDQ_DCB_RSS = 7,
}
#[repr(u32)]
/// A set of values to identify what method is to be used to transmit
/// packets using multi-TCs.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_tx_mq_mode {
    ETH_MQ_TX_NONE = 0,
    ETH_MQ_TX_DCB = 1,
    ETH_MQ_TX_VMDQ_DCB = 2,
    ETH_MQ_TX_VMDQ_ONLY = 3,
}
/// A structure used to configure the RX features of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxmode {
    /// The multi-queue packet distribution mode to be used, e.g. RSS.
    pub mq_mode: rte_eth_rx_mq_mode,
    /// < Only used if jumbo_frame enabled.
    pub max_rx_pkt_len: u32,
    /// < hdr buf size (header_split enabled).
    pub split_hdr_size: u16,
    pub _bitfield_1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxmode>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_rxmode ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_rxmode>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_rxmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . mq_mode as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxmode ) , "::"
                , stringify ! ( mq_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . max_rx_pkt_len as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxmode ) , "::"
                , stringify ! ( max_rx_pkt_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . split_hdr_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxmode ) , "::"
                , stringify ! ( split_hdr_size ) ));
}
impl Clone for rte_eth_rxmode {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_rxmode {
    #[inline]
    pub fn header_split(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_header_split(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn hw_ip_checksum(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_hw_ip_checksum(&mut self, val: u16) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn hw_vlan_filter(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_filter(&mut self, val: u16) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u16) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn hw_vlan_extend(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_extend(&mut self, val: u16) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn jumbo_frame(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_jumbo_frame(&mut self, val: u16) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn hw_strip_crc(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_hw_strip_crc(&mut self, val: u16) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn enable_scatter(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_enable_scatter(&mut self, val: u16) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn enable_lro(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_enable_lro(&mut self, val: u16) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(header_split: u16, hw_ip_checksum: u16,
                          hw_vlan_filter: u16, hw_vlan_strip: u16,
                          hw_vlan_extend: u16, jumbo_frame: u16,
                          hw_strip_crc: u16, enable_scatter: u16,
                          enable_lro: u16) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((header_split as u16 as
                                                           u16) << 0usize) &
                                                         (1u64 as u16))
                                            } |
                                                ((hw_ip_checksum as u16 as
                                                      u16) << 1usize) &
                                                    (2u64 as u16))
                                       } |
                                           ((hw_vlan_filter as u16 as u16) <<
                                                2usize) & (4u64 as u16))
                                  } |
                                      ((hw_vlan_strip as u16 as u16) <<
                                           3usize) & (8u64 as u16))
                             } |
                                 ((hw_vlan_extend as u16 as u16) << 4usize) &
                                     (16u64 as u16))
                        } |
                            ((jumbo_frame as u16 as u16) << 5usize) &
                                (32u64 as u16))
                   } |
                       ((hw_strip_crc as u16 as u16) << 6usize) &
                           (64u64 as u16))
              } |
                  ((enable_scatter as u16 as u16) << 7usize) &
                      (128u64 as u16))
         } | ((enable_lro as u16 as u16) << 8usize) & (256u64 as u16))
    }
}
#[repr(u32)]
/// VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.
/// Note that single VLAN is treated the same as inner VLAN.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_vlan_type {
    ETH_VLAN_TYPE_UNKNOWN = 0,
    ETH_VLAN_TYPE_INNER = 1,
    ETH_VLAN_TYPE_OUTER = 2,
    ETH_VLAN_TYPE_MAX = 3,
}
/// A structure used to describe a vlan filter.
/// If the bit corresponding to a VID is set, such VID is on.
#[repr(C)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(::std::mem::size_of::<rte_vlan_filter_conf>() , 512usize ,
               concat ! ( "Size of: " , stringify ! ( rte_vlan_filter_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_vlan_filter_conf>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_vlan_filter_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vlan_filter_conf ) ) . ids as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vlan_filter_conf )
                , "::" , stringify ! ( ids ) ));
}
/// A structure used to configure the Receive Side Scaling (RSS) feature
/// of an Ethernet port.
/// If not NULL, the *rss_key* pointer of the *rss_conf* structure points
/// to an array holding the RSS key to use for hashing specific header
/// fields of received packets. The length of this array should be indicated
/// by *rss_key_len* below. Otherwise, a default random hash key is used by
/// the device driver.
///
/// The *rss_key_len* field of the *rss_conf* structure indicates the length
/// in bytes of the array pointed by *rss_key*. To be compatible, this length
/// will be checked in i40e only. Others assume 40 bytes to be used as before.
///
/// The *rss_hf* field of the *rss_conf* structure indicates the different
/// types of IPv4/IPv6 packets to which the RSS hashing must be applied.
/// Supplying an *rss_hf* equal to zero disables the RSS feature.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rss_conf {
    /// < If not NULL, 40-byte hash key.
    pub rss_key: *mut u8,
    /// < hash key length in bytes.
    pub rss_key_len: u8,
    /// < Hash functions to apply - see below.
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_rss_conf>() , 24usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_rss_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_rss_conf>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_rss_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rss_conf ) ,
                "::" , stringify ! ( rss_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_key_len as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rss_conf ) ,
                "::" , stringify ! ( rss_key_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_hf as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rss_conf ) ,
                "::" , stringify ! ( rss_hf ) ));
}
impl Clone for rte_eth_rss_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to configure VLAN traffic mirror of an Ethernet port.
#[repr(C)]
pub struct rte_eth_vlan_mirror {
    /// < mask for valid VLAN ID.
    pub vlan_mask: u64,
    /// VLAN ID list for vlan mirroring.
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(::std::mem::size_of::<rte_eth_vlan_mirror>() , 136usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_vlan_mirror )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_vlan_mirror>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vlan_mirror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vlan_mirror ) ) . vlan_mask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vlan_mirror ) ,
                "::" , stringify ! ( vlan_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vlan_mirror ) ) . vlan_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vlan_mirror ) ,
                "::" , stringify ! ( vlan_id ) ));
}
/// A structure used to configure traffic mirror of an Ethernet port.
#[repr(C)]
pub struct rte_eth_mirror_conf {
    /// < Mirroring rule type
    pub rule_type: u8,
    /// < Destination pool for this mirror rule.
    pub dst_pool: u8,
    /// < Bitmap of pool for pool mirroring
    pub pool_mask: u64,
    /// VLAN ID setting for VLAN mirroring.
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_mirror_conf>() , 152usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_mirror_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_mirror_conf>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_mirror_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . rule_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mirror_conf ) ,
                "::" , stringify ! ( rule_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . dst_pool as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mirror_conf ) ,
                "::" , stringify ! ( dst_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . pool_mask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mirror_conf ) ,
                "::" , stringify ! ( pool_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . vlan as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_mirror_conf ) ,
                "::" , stringify ! ( vlan ) ));
}
/// A structure used to configure 64 entries of Redirection Table of the
/// Receive Side Scaling (RSS) feature of an Ethernet port. To configure
/// more than 64 entries supported by hardware, an array of this structure
/// is needed.
#[repr(C)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(::std::mem::size_of::<rte_eth_rss_reta_entry64>() , 136usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_rss_reta_entry64 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_rss_reta_entry64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_rss_reta_entry64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_reta_entry64 ) ) . mask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_rss_reta_entry64 ) , "::" , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_reta_entry64 ) ) . reta as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_rss_reta_entry64 ) , "::" , stringify ! ( reta ) ));
}
#[repr(u32)]
/// This enum indicates the possible number of traffic classes
/// in DCB configurations
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_nb_tcs { ETH_4_TCS = 4, ETH_8_TCS = 8, }
#[repr(u32)]
/// This enum indicates the possible number of queue pools
/// in VMDQ configurations.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_nb_pools {
    ETH_8_POOLS = 8,
    ETH_16_POOLS = 16,
    ETH_32_POOLS = 32,
    ETH_64_POOLS = 64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_rx_conf {
    /// < Possible DCB TCs, 4 or 8 TCs
    pub nb_tcs: rte_eth_nb_tcs,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_rx_conf>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_dcb_rx_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_rx_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_dcb_rx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_rx_conf ) ) . nb_tcs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_rx_conf ) ,
                "::" , stringify ! ( nb_tcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_rx_conf ) ) . dcb_tc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_rx_conf ) ,
                "::" , stringify ! ( dcb_tc ) ));
}
impl Clone for rte_eth_dcb_rx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    /// < With DCB, 16 or 32 pools.
    pub nb_queue_pools: rte_eth_nb_pools,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_vmdq_dcb_tx_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vmdq_dcb_tx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_tx_conf ) ) .
                nb_queue_pools as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_dcb_tx_conf ) , "::" , stringify ! (
                nb_queue_pools ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_tx_conf ) ) . dcb_tc as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_dcb_tx_conf ) , "::" , stringify ! ( dcb_tc ) ));
}
impl Clone for rte_eth_vmdq_dcb_tx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tx_conf {
    /// < Possible DCB TCs, 4 or 8 TCs.
    pub nb_tcs: rte_eth_nb_tcs,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tx_conf>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_dcb_tx_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tx_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_dcb_tx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tx_conf ) ) . nb_tcs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_tx_conf ) ,
                "::" , stringify ! ( nb_tcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tx_conf ) ) . dcb_tc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_tx_conf ) ,
                "::" , stringify ! ( dcb_tc ) ));
}
impl Clone for rte_eth_dcb_tx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_tx_conf {
    /// < VMDq mode, 64 pools.
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_tx_conf>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_vmdq_tx_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_tx_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vmdq_tx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_tx_conf ) ) . nb_queue_pools
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_tx_conf )
                , "::" , stringify ! ( nb_queue_pools ) ));
}
impl Clone for rte_eth_vmdq_tx_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to configure the VMDQ+DCB feature
/// of an Ethernet port.
///
/// Using this feature, packets are routed to a pool of queues, based
/// on the vlan id in the vlan tag, and then to a specific queue within
/// that pool, using the user priority vlan tag field.
///
/// A default pool may be used, if desired, to route all traffic which
/// does not match the vlan filter rules.
#[repr(C)]
pub struct rte_eth_vmdq_dcb_conf {
    /// < With DCB, 16 or 32 pools
    pub nb_queue_pools: rte_eth_nb_pools,
    /// < If non-zero, use a default pool
    pub enable_default_pool: u8,
    /// < The default pool, if applicable
    pub default_pool: u8,
    /// < We can have up to 64 filters/mappings
    pub nb_pool_maps: u8,
    /// < VMDq vlan pool maps.
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    /// < The vlan id of the received frame
    pub vlan_id: u16,
    /// < Bitmask of pools for packet rx
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_vmdq_dcb_conf__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) ) .
                vlan_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) , "::" , stringify ! (
                vlan_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) ) .
                pools as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) , "::" , stringify ! (
                pools ) ));
}
impl Clone for rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_conf>() , 1040usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_vmdq_dcb_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_conf>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vmdq_dcb_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) .
                nb_queue_pools as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( nb_queue_pools ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) .
                enable_default_pool as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( enable_default_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . default_pool
                as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( default_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . nb_pool_maps
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( nb_pool_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . pool_map as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( pool_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . dcb_tc as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_dcb_conf )
                , "::" , stringify ! ( dcb_tc ) ));
}
/// A structure used to configure the VMDQ feature of an Ethernet port when
/// not combined with the DCB feature.
///
/// Using this feature, packets are routed to a pool of queues. By default,
/// the pool selection is based on the MAC address, the vlan id in the
/// vlan tag as specified in the pool_map array.
/// Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool
/// selection using only the MAC address. MAC address to pool mapping is done
/// using the rte_eth_dev_mac_addr_add function, with the pool parameter
/// corresponding to the pool id.
///
/// Queue selection within the selected pool will be done using RSS when
/// it is enabled or revert to the first queue of the pool if not.
///
/// A default pool may be used, if desired, to route all traffic which
/// does not match the vlan filter rules or any pool MAC address.
#[repr(C)]
pub struct rte_eth_vmdq_rx_conf {
    /// < VMDq only mode, 8 or 64 pools
    pub nb_queue_pools: rte_eth_nb_pools,
    /// < If non-zero, use a default pool
    pub enable_default_pool: u8,
    /// < The default pool, if applicable
    pub default_pool: u8,
    /// < Enable VT loop back
    pub enable_loop_back: u8,
    /// < We can have up to 64 filters/mappings
    pub nb_pool_maps: u8,
    /// < Flags from ETH_VMDQ_ACCEPT_*
    pub rx_mode: u32,
    /// < VMDq vlan pool maps.
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    /// < The vlan id of the received frame
    pub vlan_id: u16,
    /// < Bitmask of pools for packet rx
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_vmdq_rx_conf__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_vmdq_rx_conf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf__bindgen_ty_1 ) ) .
                vlan_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_rx_conf__bindgen_ty_1 ) , "::" , stringify ! (
                vlan_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf__bindgen_ty_1 ) ) .
                pools as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vmdq_rx_conf__bindgen_ty_1 ) , "::" , stringify ! (
                pools ) ));
}
impl Clone for rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_rx_conf>() , 1040usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_vmdq_rx_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_rx_conf>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vmdq_rx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . nb_queue_pools
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( nb_queue_pools ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) .
                enable_default_pool as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( enable_default_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . default_pool
                as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( default_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) .
                enable_loop_back as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( enable_loop_back ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . nb_pool_maps
                as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( nb_pool_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . rx_mode as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( rx_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . pool_map as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_vmdq_rx_conf )
                , "::" , stringify ! ( pool_map ) ));
}
/// A structure used to configure the TX features of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_txmode {
    /// < TX multi-queues mode.
    pub mq_mode: rte_eth_tx_mq_mode,
    pub pvid: u16,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(::std::mem::size_of::<rte_eth_txmode>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_txmode ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_txmode>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_txmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txmode ) ) . mq_mode as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txmode ) , "::"
                , stringify ! ( mq_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txmode ) ) . pvid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txmode ) , "::"
                , stringify ! ( pvid ) ));
}
impl Clone for rte_eth_txmode {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(hw_vlan_reject_tagged: u8,
                          hw_vlan_reject_untagged: u8,
                          hw_vlan_insert_pvid: u8) -> u8 {
        ({
             ({
                  ({ 0 } |
                       ((hw_vlan_reject_tagged as u8 as u8) << 0usize) &
                           (1u64 as u8))
              } |
                  ((hw_vlan_reject_untagged as u8 as u8) << 1usize) &
                      (2u64 as u8))
         } | ((hw_vlan_insert_pvid as u8 as u8) << 2usize) & (4u64 as u8))
    }
}
/// A structure used to configure an RX ring of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxconf {
    /// < RX ring threshold registers.
    pub rx_thresh: rte_eth_thresh,
    /// < Drives the freeing of RX descriptors.
    pub rx_free_thresh: u16,
    /// < Drop packets if no descriptors are available.
    pub rx_drop_en: u8,
    /// < Do not start queue with rte_eth_dev_start().
    pub rx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxconf>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_rxconf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_rxconf>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_rxconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_thresh as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxconf ) , "::"
                , stringify ! ( rx_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_free_thresh as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxconf ) , "::"
                , stringify ! ( rx_free_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_drop_en as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxconf ) , "::"
                , stringify ! ( rx_drop_en ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_deferred_start as
                * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxconf ) , "::"
                , stringify ! ( rx_deferred_start ) ));
}
impl Clone for rte_eth_rxconf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to configure a TX ring of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_txconf {
    /// < TX ring threshold registers.
    pub tx_thresh: rte_eth_thresh,
    /// < Drives the setting of RS bit on TXDs.
    pub tx_rs_thresh: u16,
    /// < Start freeing TX buffers if there are
    /// less free descriptors than this value.
    pub tx_free_thresh: u16,
    /// < Set flags for the Tx queue
    pub txq_flags: u32,
    /// < Do not start queue with rte_eth_dev_start().
    pub tx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(::std::mem::size_of::<rte_eth_txconf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_txconf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_txconf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_txconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_thresh as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txconf ) , "::"
                , stringify ! ( tx_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_rs_thresh as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txconf ) , "::"
                , stringify ! ( tx_rs_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_free_thresh as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txconf ) , "::"
                , stringify ! ( tx_free_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . txq_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txconf ) , "::"
                , stringify ! ( txq_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_deferred_start as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txconf ) , "::"
                , stringify ! ( tx_deferred_start ) ));
}
impl Clone for rte_eth_txconf {
    fn clone(&self) -> Self { *self }
}
/// A structure contains information about HW descriptor ring limitations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_desc_lim {
    /// < Max allowed number of descriptors.
    pub nb_max: u16,
    /// < Min allowed number of descriptors.
    pub nb_min: u16,
    /// < Number of descriptors should be aligned to.
    pub nb_align: u16,
    /// Max allowed number of segments per whole packet.
    ///
    /// - For TSO packet this is the total number of data descriptors allowed
    /// by device.
    ///
    /// @see nb_mtu_seg_max
    pub nb_seg_max: u16,
    /// Max number of segments per one MTU.
    ///
    /// - For non-TSO packet, this is the maximum allowed number of segments
    /// in a single transmit packet.
    ///
    /// - For TSO packet each segment within the TSO may span up to this
    /// value.
    ///
    /// @see nb_seg_max
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(::std::mem::size_of::<rte_eth_desc_lim>() , 10usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_desc_lim ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_desc_lim>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_desc_lim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_max as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_desc_lim ) ,
                "::" , stringify ! ( nb_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_min as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_desc_lim ) ,
                "::" , stringify ! ( nb_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_align as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_desc_lim ) ,
                "::" , stringify ! ( nb_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_seg_max as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_desc_lim ) ,
                "::" , stringify ! ( nb_seg_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_mtu_seg_max as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_desc_lim ) ,
                "::" , stringify ! ( nb_mtu_seg_max ) ));
}
impl Clone for rte_eth_desc_lim {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// This enum indicates the flow control mode
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fc_mode {
    RTE_FC_NONE = 0,
    RTE_FC_RX_PAUSE = 1,
    RTE_FC_TX_PAUSE = 2,
    RTE_FC_FULL = 3,
}
/// A structure used to configure Ethernet flow control parameter.
/// These parameters will be configured into the register of the NIC.
/// Please refer to the corresponding data sheet for proper value.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fc_conf {
    /// < High threshold value to trigger XOFF
    pub high_water: u32,
    /// < Low threshold value to trigger XON
    pub low_water: u32,
    /// < Pause quota in the Pause frame
    pub pause_time: u16,
    /// < Is XON frame need be sent
    pub send_xon: u16,
    /// < Link flow control mode
    pub mode: rte_eth_fc_mode,
    /// < Forward MAC control frames
    pub mac_ctrl_frame_fwd: u8,
    /// < Use Pause autoneg
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_fc_conf>() , 20usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_fc_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_fc_conf>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_fc_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . high_water as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( high_water ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . low_water as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( low_water ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . pause_time as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( pause_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . send_xon as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( send_xon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . mode as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . mac_ctrl_frame_fwd
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( mac_ctrl_frame_fwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . autoneg as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_fc_conf ) ,
                "::" , stringify ! ( autoneg ) ));
}
impl Clone for rte_eth_fc_conf {
    fn clone(&self) -> Self { *self }
}
/// A structure used to configure Ethernet priority flow control parameter.
/// These parameters will be configured into the register of the NIC.
/// Please refer to the corresponding data sheet for proper value.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_pfc_conf {
    /// < General flow control parameter.
    pub fc: rte_eth_fc_conf,
    /// < VLAN User Priority.
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_pfc_conf>() , 24usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_pfc_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_pfc_conf>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_pfc_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_pfc_conf ) ) . fc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_pfc_conf ) ,
                "::" , stringify ! ( fc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_pfc_conf ) ) . priority as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_pfc_conf ) ,
                "::" , stringify ! ( priority ) ));
}
impl Clone for rte_eth_pfc_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Memory space that can be configured to store Flow Director filters
/// in the board memory.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_pballoc_type {
    RTE_FDIR_PBALLOC_64K = 0,
    RTE_FDIR_PBALLOC_128K = 1,
    RTE_FDIR_PBALLOC_256K = 2,
}
#[repr(u32)]
/// Select report mode of FDIR hash information in RX descriptors.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_status_mode {
    RTE_FDIR_NO_REPORT_STATUS = 0,
    RTE_FDIR_REPORT_STATUS = 1,
    RTE_FDIR_REPORT_STATUS_ALWAYS = 2,
}
/// A structure used to configure the Flow Director (FDIR) feature
/// of an Ethernet port.
///
/// If mode is RTE_FDIR_DISABLE, the pballoc value is ignored.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fdir_conf {
    /// < Flow Director mode.
    pub mode: rte_fdir_mode,
    /// < Space for FDIR filters.
    pub pballoc: rte_fdir_pballoc_type,
    /// < How to report FDIR hash.
    pub status: rte_fdir_status_mode,
    /// RX queue of packets matching a "drop" filter in perfect mode.
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(::std::mem::size_of::<rte_fdir_conf>() , 772usize , concat ! (
               "Size of: " , stringify ! ( rte_fdir_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_fdir_conf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_fdir_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . mode as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . pballoc as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( pballoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . status as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . drop_queue as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( drop_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . flex_conf as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fdir_conf ) , "::"
                , stringify ! ( flex_conf ) ));
}
impl Clone for rte_fdir_conf {
    fn clone(&self) -> Self { *self }
}
/// UDP tunneling configuration.
/// Used to config the UDP port for a type of tunnel.
/// NICs need the UDP port to identify the tunnel type.
/// Normally a type of tunnel has a default UDP port, this structure can be used
/// in case if the users want to change or support more UDP port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udp_tunnel {
    /// < UDP port used for the tunnel.
    pub udp_port: u16,
    /// < Tunnel type. Defined in rte_eth_tunnel_type.
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(::std::mem::size_of::<rte_eth_udp_tunnel>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_udp_tunnel ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_udp_tunnel>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_udp_tunnel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udp_tunnel ) ) . udp_port as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udp_tunnel ) ,
                "::" , stringify ! ( udp_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udp_tunnel ) ) . prot_type as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_udp_tunnel ) ,
                "::" , stringify ! ( prot_type ) ));
}
impl Clone for rte_eth_udp_tunnel {
    fn clone(&self) -> Self { *self }
}
/// A structure used to enable/disable specific device interrupts.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_conf {
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(::std::mem::size_of::<rte_intr_conf>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_intr_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_intr_conf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_intr_conf ) ));
}
impl Clone for rte_intr_conf {
    fn clone(&self) -> Self { *self }
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> u8 {
        ({
             ({ ({ 0 } | ((lsc as u32 as u8) << 0usize) & (1u64 as u8)) } |
                  ((rxq as u32 as u8) << 1usize) & (2u64 as u8))
         } | ((rmv as u32 as u8) << 2usize) & (4u64 as u8))
    }
}
/// A structure used to configure an Ethernet port.
/// Depending upon the RX multi-queue mode, extra advanced
/// configuration settings may be needed.
#[repr(C)]
pub struct rte_eth_conf {
    /// < bitmap of ETH_LINK_SPEED_XXX of speeds to be
    /// used. ETH_LINK_SPEED_FIXED disables link
    /// autonegotiation, and a unique speed shall be
    /// set. Otherwise, the bitmap defines the set of
    /// speeds to be advertised. If the special value
    /// ETH_LINK_SPEED_AUTONEG (0) is used, all speeds
    /// supported are advertised.
    pub link_speeds: u32,
    /// < Port RX configuration.
    pub rxmode: rte_eth_rxmode,
    /// < Port TX configuration.
    pub txmode: rte_eth_txmode,
    /// < Loopback operation mode. By default the value
    /// is 0, meaning the loopback mode is disabled.
    /// Read the datasheet of given ethernet controller
    /// for details. The possible values of this field
    /// are defined in implementation of each driver.
    pub lpbk_mode: u32,
    /// < Port RX filtering configuration (union).
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    /// < Port TX DCB configuration (union).
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    /// Currently,Priority Flow Control(PFC) are supported,if DCB with PFC
    /// is needed,and the variable must be set ETH_DCB_PFC_SUPPORT.
    pub dcb_capability_en: u32,
    /// < FDIR configuration.
    pub fdir_conf: rte_fdir_conf,
    /// < Interrupt mode configuration.
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
pub struct rte_eth_conf__bindgen_ty_1 {
    /// < Port RSS configuration
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>() , 2120usize
               , concat ! (
               "Size of: " , stringify ! ( rte_eth_conf__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_eth_conf__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) . rss_conf
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_1 ) , "::" , stringify ! ( rss_conf )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                vmdq_dcb_conf as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_1 ) , "::" , stringify ! (
                vmdq_dcb_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                dcb_rx_conf as * const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_1 ) , "::" , stringify ! (
                dcb_rx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                vmdq_rx_conf as * const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_1 ) , "::" , stringify ! (
                vmdq_rx_conf ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: __BindgenUnionField<rte_eth_vmdq_dcb_tx_conf>,
    pub dcb_tx_conf: __BindgenUnionField<rte_eth_dcb_tx_conf>,
    pub vmdq_tx_conf: __BindgenUnionField<rte_eth_vmdq_tx_conf>,
    pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_conf__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_eth_conf__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                vmdq_dcb_tx_conf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_2 ) , "::" , stringify ! (
                vmdq_dcb_tx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                dcb_tx_conf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_2 ) , "::" , stringify ! (
                dcb_tx_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                vmdq_tx_conf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_conf__bindgen_ty_2 ) , "::" , stringify ! (
                vmdq_tx_conf ) ));
}
impl Clone for rte_eth_conf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf>() , 2944usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_conf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . link_speeds as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( link_speeds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . rxmode as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( rxmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . txmode as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( txmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . lpbk_mode as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( lpbk_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . rx_adv_conf as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( rx_adv_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . tx_adv_conf as * const
                _ as usize } , 2152usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( tx_adv_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . dcb_capability_en as *
                const _ as usize } , 2164usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( dcb_capability_en ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . fdir_conf as * const _
                as usize } , 2168usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( fdir_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . intr_conf as * const _
                as usize } , 2940usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_conf ) , "::" ,
                stringify ! ( intr_conf ) ));
}
/// Ethernet device information
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_info {
    /// < Device PCI information.
    pub pci_dev: *mut rte_pci_device,
    /// < Device Driver name.
    pub driver_name: *const ::std::os::raw::c_char,
    /// < Index to bound host interface, or 0 if none.
    /// Use if_indextoname() to translate into an interface name.
    pub if_index: ::std::os::raw::c_uint,
    /// < Minimum size of RX buffer.
    pub min_rx_bufsize: u32,
    /// < Maximum configurable length of RX pkt.
    pub max_rx_pktlen: u32,
    /// < Maximum number of RX queues.
    pub max_rx_queues: u16,
    /// < Maximum number of TX queues.
    pub max_tx_queues: u16,
    /// < Maximum number of MAC addresses.
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    /// < Maximum number of VFs.
    pub max_vfs: u16,
    /// < Maximum number of VMDq pools.
    pub max_vmdq_pools: u16,
    /// < Device RX offload capabilities.
    pub rx_offload_capa: u32,
    /// < Device TX offload capabilities.
    pub tx_offload_capa: u32,
    pub reta_size: u16,
    /// < Hash key size in bytes
    pub hash_key_size: u8,
    /// Bit mask of RSS offloads, the bit offset also means flow type
    pub flow_type_rss_offloads: u64,
    /// < Default RX configuration
    pub default_rxconf: rte_eth_rxconf,
    /// < Default TX configuration
    pub default_txconf: rte_eth_txconf,
    /// < First queue ID for VMDQ pools.
    pub vmdq_queue_base: u16,
    /// < Queue number for VMDQ pools.
    pub vmdq_queue_num: u16,
    /// < First ID of VMDQ pools.
    pub vmdq_pool_base: u16,
    /// < RX descriptors limits
    pub rx_desc_lim: rte_eth_desc_lim,
    /// < TX descriptors limits
    pub tx_desc_lim: rte_eth_desc_lim,
    /// < Supported speeds bitmap (ETH_LINK_SPEED_).
    pub speed_capa: u32,
    /// < Number of RX queues.
    pub nb_rx_queues: u16,
    /// < Number of TX queues.
    pub nb_tx_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_info>() , 128usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_dev_info ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dev_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_dev_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . pci_dev as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( pci_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . driver_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( driver_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . if_index as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( if_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . min_rx_bufsize as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( min_rx_bufsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_rx_pktlen as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_rx_pktlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_rx_queues as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_tx_queues as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_mac_addrs as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_mac_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_hash_mac_addrs
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_hash_mac_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_vfs as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_vfs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_vmdq_pools as
                * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( max_vmdq_pools ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . rx_offload_capa as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( rx_offload_capa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . tx_offload_capa as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( tx_offload_capa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . reta_size as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( reta_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . hash_key_size as *
                const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( hash_key_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) .
                flow_type_rss_offloads as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( flow_type_rss_offloads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . default_rxconf as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( default_rxconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . default_txconf as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( default_txconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_queue_base as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( vmdq_queue_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_queue_num as
                * const _ as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( vmdq_queue_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_pool_base as
                * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( vmdq_pool_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . rx_desc_lim as *
                const _ as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( rx_desc_lim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . tx_desc_lim as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( tx_desc_lim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . speed_capa as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( speed_capa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . nb_rx_queues as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( nb_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . nb_tx_queues as *
                const _ as usize } , 122usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_info ) ,
                "::" , stringify ! ( nb_tx_queues ) ));
}
impl Clone for rte_eth_dev_info {
    fn clone(&self) -> Self { *self }
}
/// Ethernet device RX queue information structure.
/// Used to retieve information about configured queue.
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_rxq_info {
    /// < mempool used by that queue.
    pub mp: *mut rte_mempool,
    /// < queue config parameters.
    pub conf: rte_eth_rxconf,
    /// < scattered packets RX supported.
    pub scattered_rx: u8,
    /// < configured number of RXDs.
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxq_info>() , 64usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_rxq_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . mp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxq_info ) ,
                "::" , stringify ! ( mp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . conf as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxq_info ) ,
                "::" , stringify ! ( conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . scattered_rx as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxq_info ) ,
                "::" , stringify ! ( scattered_rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . nb_desc as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxq_info ) ,
                "::" , stringify ! ( nb_desc ) ));
}
impl Clone for rte_eth_rxq_info {
    fn clone(&self) -> Self { *self }
}
/// Ethernet device TX queue information structure.
/// Used to retieve information about configured queue.
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_txq_info {
    /// < queue config parameters.
    pub conf: rte_eth_txconf,
    /// < configured number of TXDs.
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u16; 23usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_txq_info>() , 64usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_txq_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txq_info ) ) . conf as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txq_info ) ,
                "::" , stringify ! ( conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txq_info ) ) . nb_desc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_txq_info ) ,
                "::" , stringify ! ( nb_desc ) ));
}
impl Clone for rte_eth_txq_info {
    fn clone(&self) -> Self { *self }
}
/// An Ethernet device extended statistic structure
///
/// This structure is used by rte_eth_xstats_get() to provide
/// statistics that are not provided in the generic *rte_eth_stats*
/// structure.
/// It maps a name id, corresponding to an index in the array returned
/// by rte_eth_xstats_get_names(), to a statistic value.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_xstat {
    /// < The index in xstats name array.
    pub id: u64,
    /// < The statistic counter value.
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(::std::mem::size_of::<rte_eth_xstat>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_xstat ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_xstat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_xstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_xstat ) , "::"
                , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_xstat ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for rte_eth_xstat {
    fn clone(&self) -> Self { *self }
}
/// A name element for extended statistics.
///
/// An array of this structure is returned by rte_eth_xstats_get_names().
/// It lists the names of extended statistics for a PMD. The *rte_eth_xstat*
/// structure references these names by their array index.
#[repr(C)]
pub struct rte_eth_xstat_name {
    /// < The statistic name.
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(::std::mem::size_of::<rte_eth_xstat_name>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_xstat_name ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_xstat_name>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_xstat_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat_name ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_xstat_name ) ,
                "::" , stringify ! ( name ) ));
}
/// A structure used to get the information of queue and
/// TC mapping on both TX and RX paths.
#[repr(C)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
/// rx queues assigned to tc per Pool
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>()
               , 2usize , concat ! (
               "Size of: " , stringify ! (
               rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 )
                ) . base as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 )
                ) . nb_queue as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 ) , "::" ,
                stringify ! ( nb_queue ) ));
}
impl Clone for rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/// rx queues assigned to tc per Pool
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>()
               , 2usize , concat ! (
               "Size of: " , stringify ! (
               rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 )
                ) . base as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 )
                ) . nb_queue as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 ) , "::" ,
                stringify ! ( nb_queue ) ));
}
impl Clone for rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>() ,
               2048usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_dcb_tc_queue_mapping ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( rte_eth_dcb_tc_queue_mapping )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tc_queue_mapping ) ) . tc_rxq
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping ) , "::" , stringify ! ( tc_rxq )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tc_queue_mapping ) ) . tc_txq
                as * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_dcb_tc_queue_mapping ) , "::" , stringify ! ( tc_txq )
                ));
}
/// A structure used to get the information of DCB.
/// It includes TC UP mapping and queue TC mapping.
#[repr(C)]
pub struct rte_eth_dcb_info {
    /// < number of TCs
    pub nb_tcs: u8,
    /// < Priority to tc
    pub prio_tc: [u8; 8usize],
    /// < TX BW percentage for each TC
    pub tc_bws: [u8; 8usize],
    /// rx queues assigned to tc
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_info>() , 2065usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_dcb_info ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_info>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_dcb_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . nb_tcs as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_info ) ,
                "::" , stringify ! ( nb_tcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . prio_tc as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_info ) ,
                "::" , stringify ! ( prio_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . tc_bws as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_info ) ,
                "::" , stringify ! ( tc_bws ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . tc_queue as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dcb_info ) ,
                "::" , stringify ! ( tc_queue ) ));
}
/// @internal
/// The generic data structure associated with each ethernet device.
///
/// Pointers to burst-oriented packet receive and transmit functions are
/// located at the beginning of the structure, along with the pointer to
/// where all the data elements for the particular device are stored in shared
/// memory. This split allows the function pointer and driver data to be per-
/// process, while the actual configuration data for the device is shared.
#[repr(C)]
pub struct rte_eth_dev {
    /// < Pointer to PMD receive function.
    pub rx_pkt_burst: eth_rx_burst_t,
    /// < Pointer to PMD transmit function.
    pub tx_pkt_burst: eth_tx_burst_t,
    /// < Pointer to PMD transmit prepare function.
    pub tx_pkt_prepare: eth_tx_prep_t,
    /// < Pointer to device data
    pub data: *mut rte_eth_dev_data,
    /// < Functions exported by PMD
    pub dev_ops: *const eth_dev_ops,
    /// < Backing device
    pub device: *mut rte_device,
    /// < Device interrupt handle
    pub intr_handle: *mut rte_intr_handle,
    /// User application callbacks for NIC interrupts
    pub link_intr_cbs: rte_eth_dev_cb_list,
    /// User-supplied functions called from rx_burst to post-process
    /// received packets before passing them to the user
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    /// User-supplied functions called from tx_burst to pre-process
    /// received packets before passing them to the driver for transmission.
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    /// < Flag indicating the port state
    pub state: rte_eth_dev_state,
    pub __bindgen_padding_0: [u32; 13usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev>() , 16512usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . rx_pkt_burst as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( rx_pkt_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . tx_pkt_burst as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( tx_pkt_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . tx_pkt_prepare as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( tx_pkt_prepare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . dev_ops as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( dev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . device as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . intr_handle as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( intr_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . link_intr_cbs as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( link_intr_cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . post_rx_burst_cbs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( post_rx_burst_cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . pre_tx_burst_cbs as *
                const _ as usize } , 8264usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( pre_tx_burst_cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . state as * const _ as
                usize } , 16456usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev ) , "::" ,
                stringify ! ( state ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
/// @internal Structure to keep track of registered callbacks
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_cb_list>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_dev_cb_list ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dev_cb_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_dev_cb_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_cb_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_cb_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_cb_list ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_cb_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for rte_eth_dev_cb_list {
    fn clone(&self) -> Self { *self }
}
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_link_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               wait_to_complete:
                                                   ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type eth_stats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               igb_stats:
                                                   *mut rte_eth_stats)>;
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               stats: *mut rte_eth_xstat,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_xstats_get_by_id_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               ids: *const u64,
                                               values: *mut u64,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_names_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               xstats_names:
                                                   *mut rte_eth_xstat_name,
                                               size: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_xstats_get_names_by_id_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               xstats_names:
                                                   *mut rte_eth_xstat_name,
                                               ids: *const u64,
                                               size: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_stats_mapping_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16, stat_idx: u8,
                                               is_rx: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_infos_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               dev_info:
                                                   *mut rte_eth_dev_info)>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> *const u32>;
pub type eth_queue_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_queue_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               nb_rx_desc: u16,
                                               socket_id:
                                                   ::std::os::raw::c_uint,
                                               rx_conf: *const rte_eth_rxconf,
                                               mb_pool: *mut rte_mempool)
                              -> ::std::os::raw::c_int>;
pub type eth_tx_queue_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tx_queue_id: u16,
                                               nb_tx_desc: u16,
                                               socket_id:
                                                   ::std::os::raw::c_uint,
                                               tx_conf: *const rte_eth_txconf)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_enable_intr_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_disable_intr_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue:
                                                   *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t =
    ::std::option::Option<unsafe extern "C" fn(rxq:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_descriptor_status_t =
    ::std::option::Option<unsafe extern "C" fn(rxq:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_tx_descriptor_status_t =
    ::std::option::Option<unsafe extern "C" fn(txq:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_fw_version_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               fw_version:
                                                   *mut ::std::os::raw::c_char,
                                               fw_size: usize)
                              -> ::std::os::raw::c_int>;
pub type eth_tx_done_cleanup_t =
    ::std::option::Option<unsafe extern "C" fn(txq:
                                                   *mut ::std::os::raw::c_void,
                                               free_cnt: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_rxq_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               qinfo: *mut rte_eth_rxq_info)>;
pub type eth_txq_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tx_queue_id: u16,
                                               qinfo: *mut rte_eth_txq_info)>;
pub type mtu_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mtu: u16)
                              -> ::std::os::raw::c_int>;
pub type vlan_filter_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               vlan_id: u16,
                                               on: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type vlan_tpid_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               type_: rte_vlan_type,
                                               tpid: u16)
                              -> ::std::os::raw::c_int>;
pub type vlan_offload_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mask: ::std::os::raw::c_int)>;
pub type vlan_pvid_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               vlan_id: u16,
                                               on: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type vlan_strip_queue_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               on: ::std::os::raw::c_int)>;
pub type eth_rx_burst_t =
    ::std::option::Option<unsafe extern "C" fn(rxq:
                                                   *mut ::std::os::raw::c_void,
                                               rx_pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16) -> u16>;
pub type eth_tx_burst_t =
    ::std::option::Option<unsafe extern "C" fn(txq:
                                                   *mut ::std::os::raw::c_void,
                                               tx_pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16) -> u16>;
pub type eth_tx_prep_t =
    ::std::option::Option<unsafe extern "C" fn(txq:
                                                   *mut ::std::os::raw::c_void,
                                               tx_pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16) -> u16>;
pub type flow_ctrl_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               fc_conf: *mut rte_eth_fc_conf)
                              -> ::std::os::raw::c_int>;
pub type flow_ctrl_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               fc_conf: *mut rte_eth_fc_conf)
                              -> ::std::os::raw::c_int>;
pub type priority_flow_ctrl_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               pfc_conf:
                                                   *mut rte_eth_pfc_conf)
                              -> ::std::os::raw::c_int>;
pub type reta_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               reta_conf:
                                                   *mut rte_eth_rss_reta_entry64,
                                               reta_size: u16)
                              -> ::std::os::raw::c_int>;
pub type reta_query_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               reta_conf:
                                                   *mut rte_eth_rss_reta_entry64,
                                               reta_size: u16)
                              -> ::std::os::raw::c_int>;
pub type rss_hash_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rss_conf:
                                                   *mut rte_eth_rss_conf)
                              -> ::std::os::raw::c_int>;
pub type rss_hash_conf_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rss_conf:
                                                   *mut rte_eth_rss_conf)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               index: u32)>;
pub type eth_mac_addr_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr,
                                               index: u32, vmdq: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_mac_addr_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr)>;
pub type eth_uc_hash_table_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr,
                                               on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_uc_all_hash_table_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_queue_rate_limit_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_idx: u16, tx_rate: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_mirror_rule_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mirror_conf:
                                                   *mut rte_eth_mirror_conf,
                                               rule_id: u8, on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_mirror_rule_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rule_id: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_udp_tunnel_port_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tunnel_udp:
                                                   *mut rte_eth_udp_tunnel)
                              -> ::std::os::raw::c_int>;
pub type eth_udp_tunnel_port_del_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tunnel_udp:
                                                   *mut rte_eth_udp_tunnel)
                              -> ::std::os::raw::c_int>;
pub type eth_set_mc_addr_list_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mc_addr_set: *mut ether_addr,
                                               nb_mc_addr: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec,
                                               flags: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_tx_timestamp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_adjust_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               arg1: i64)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_write_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *const timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_get_reg_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_reg_info)
                              -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_eeprom_info)
                              -> ::std::os::raw::c_int>;
pub type eth_set_eeprom_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_eeprom_info)
                              -> ::std::os::raw::c_int>;
pub type eth_l2_tunnel_eth_type_conf_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf)
                              -> ::std::os::raw::c_int>;
pub type eth_l2_tunnel_offload_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf,
                                               mask: u32, en: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_filter_ctrl_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               filter_type: rte_filter_type,
                                               filter_op: rte_filter_op,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type eth_tm_ops_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               ops:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type eth_get_dcb_info =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               dcb_info:
                                                   *mut rte_eth_dcb_info)
                              -> ::std::os::raw::c_int>;
/// @internal A structure containing the functions exported by an Ethernet driver.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eth_dev_ops {
    /// < Configure device.
    pub dev_configure: eth_dev_configure_t,
    /// < Start device.
    pub dev_start: eth_dev_start_t,
    /// < Stop device.
    pub dev_stop: eth_dev_stop_t,
    /// < Device link up.
    pub dev_set_link_up: eth_dev_set_link_up_t,
    /// < Device link down.
    pub dev_set_link_down: eth_dev_set_link_down_t,
    /// < Close device.
    pub dev_close: eth_dev_close_t,
    /// < Get device link state.
    pub link_update: eth_link_update_t,
    /// < Promiscuous ON.
    pub promiscuous_enable: eth_promiscuous_enable_t,
    /// < Promiscuous OFF.
    pub promiscuous_disable: eth_promiscuous_disable_t,
    /// < RX multicast ON.
    pub allmulticast_enable: eth_allmulticast_enable_t,
    /// < RX multicast OFF.
    pub allmulticast_disable: eth_allmulticast_disable_t,
    /// < Remove MAC address.
    pub mac_addr_remove: eth_mac_addr_remove_t,
    /// < Add a MAC address.
    pub mac_addr_add: eth_mac_addr_add_t,
    /// < Set a MAC address.
    pub mac_addr_set: eth_mac_addr_set_t,
    /// < set list of mcast addrs.
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    /// < Set MTU.
    pub mtu_set: mtu_set_t,
    /// < Get generic device statistics.
    pub stats_get: eth_stats_get_t,
    /// < Reset generic device statistics.
    pub stats_reset: eth_stats_reset_t,
    /// < Get extended device statistics.
    pub xstats_get: eth_xstats_get_t,
    /// < Reset extended device statistics.
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    /// < Get device info.
    pub dev_infos_get: eth_dev_infos_get_t,
    /// < retrieve RX queue information.
    pub rxq_info_get: eth_rxq_info_get_t,
    /// < retrieve TX queue information.
    pub txq_info_get: eth_txq_info_get_t,
    /// < Get firmware version.
    pub fw_version_get: eth_fw_version_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    /// < Filter VLAN Setup.
    pub vlan_filter_set: vlan_filter_set_t,
    /// < Outer/Inner VLAN TPID Setup.
    pub vlan_tpid_set: vlan_tpid_set_t,
    /// < VLAN Stripping on queue.
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    /// < Set VLAN Offload.
    pub vlan_offload_set: vlan_offload_set_t,
    /// < Set port based TX VLAN insertion.
    pub vlan_pvid_set: vlan_pvid_set_t,
    /// < Start RX for a queue.
    pub rx_queue_start: eth_queue_start_t,
    /// < Stop RX for a queue.
    pub rx_queue_stop: eth_queue_stop_t,
    /// < Start TX for a queue.
    pub tx_queue_start: eth_queue_start_t,
    /// < Stop TX for a queue.
    pub tx_queue_stop: eth_queue_stop_t,
    /// < Set up device RX queue.
    pub rx_queue_setup: eth_rx_queue_setup_t,
    /// < Release RX queue.
    pub rx_queue_release: eth_queue_release_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    /// < Check rxd DD bit.
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    /// < Enable Rx queue interrupt.
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    /// < Disable Rx queue interrupt.
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    /// < Set up device TX queue.
    pub tx_queue_setup: eth_tx_queue_setup_t,
    /// < Release TX queue.
    pub tx_queue_release: eth_queue_release_t,
    /// < Free tx ring mbufs
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    /// < Turn on LED.
    pub dev_led_on: eth_dev_led_on_t,
    /// < Turn off LED.
    pub dev_led_off: eth_dev_led_off_t,
    /// < Get flow control.
    pub flow_ctrl_get: flow_ctrl_get_t,
    /// < Setup flow control.
    pub flow_ctrl_set: flow_ctrl_set_t,
    /// < Setup priority flow control.
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    /// < Set Unicast Table Array.
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    /// < Set Unicast hash bitmap.
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    /// < Add a traffic mirror rule.
    pub mirror_rule_set: eth_mirror_rule_set_t,
    /// < reset a traffic mirror rule.
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    /// Add UDP tunnel port.
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    /// Del UDP tunnel port.
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    /// Config ether type of l2 tunnel.
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
    /// < Set queue rate limit.
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    pub rss_hash_update: rss_hash_update_t,
    /// Configure RSS hash protocols.
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    /// Get current RSS hash configuration.
    pub reta_update: reta_update_t,
    /// Update redirection table.
    pub reta_query: reta_query_t,
    /// < Get registers.
    pub get_reg: eth_get_reg_t,
    /// < Get eeprom length.
    pub get_eeprom_length: eth_get_eeprom_length_t,
    /// < Get eeprom data.
    pub get_eeprom: eth_get_eeprom_t,
    /// < Set eeprom.
    pub set_eeprom: eth_set_eeprom_t,
    /// < common filter control.
    pub filter_ctrl: eth_filter_ctrl_t,
    pub get_dcb_info: eth_get_dcb_info,
    /// Get DCB information.
    pub timesync_enable: eth_timesync_enable_t,
    /// Turn IEEE1588/802.1AS timestamping on.
    pub timesync_disable: eth_timesync_disable_t,
    /// Turn IEEE1588/802.1AS timestamping off.
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    /// Read the IEEE1588/802.1AS RX timestamp.
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    /// Read the IEEE1588/802.1AS TX timestamp.
    pub timesync_adjust_time: eth_timesync_adjust_time,
    /// Adjust the device clock.
    pub timesync_read_time: eth_timesync_read_time,
    /// Get the device clock time.
    pub timesync_write_time: eth_timesync_write_time,
    /// Set the device clock time.
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub tm_ops_get: eth_tm_ops_get_t,
}
#[test]
fn bindgen_test_layout_eth_dev_ops() {
    assert_eq!(::std::mem::size_of::<eth_dev_ops>() , 648usize , concat ! (
               "Size of: " , stringify ! ( eth_dev_ops ) ));
    assert_eq! (::std::mem::align_of::<eth_dev_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( eth_dev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_configure as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_start as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_stop as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_set_link_up as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_set_link_up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_set_link_down as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_set_link_down ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_close as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . link_update as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( link_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . promiscuous_enable as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( promiscuous_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . promiscuous_disable as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( promiscuous_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . allmulticast_enable as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( allmulticast_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . allmulticast_disable as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( allmulticast_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_remove as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mac_addr_remove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_add as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mac_addr_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_set as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mac_addr_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_mc_addr_list as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( set_mc_addr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mtu_set as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mtu_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . stats_get as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( stats_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . stats_reset as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( stats_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( xstats_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_reset as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( xstats_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get_names as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( xstats_get_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . queue_stats_mapping_set
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( queue_stats_mapping_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_infos_get as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_infos_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rxq_info_get as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rxq_info_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . txq_info_get as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( txq_info_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . fw_version_get as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( fw_version_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                dev_supported_ptypes_get as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_supported_ptypes_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_filter_set as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( vlan_filter_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_tpid_set as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( vlan_tpid_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_strip_queue_set as
                * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( vlan_strip_queue_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_offload_set as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( vlan_offload_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_pvid_set as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( vlan_pvid_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_start as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_stop as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_start as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_queue_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_stop as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_queue_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_setup as *
                const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_release as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_count as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_descriptor_done as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_descriptor_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_descriptor_status as
                * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_descriptor_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_descriptor_status as
                * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_descriptor_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_intr_enable as
                * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_intr_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_intr_disable
                as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rx_queue_intr_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_setup as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_queue_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_release as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_queue_release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_done_cleanup as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tx_done_cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_led_on as * const _
                as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_led_on ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_led_off as * const
                _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( dev_led_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . flow_ctrl_get as *
                const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( flow_ctrl_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . flow_ctrl_set as *
                const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( flow_ctrl_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . priority_flow_ctrl_set
                as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( priority_flow_ctrl_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . uc_hash_table_set as *
                const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( uc_hash_table_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . uc_all_hash_table_set
                as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( uc_all_hash_table_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mirror_rule_set as *
                const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mirror_rule_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mirror_rule_reset as *
                const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( mirror_rule_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . udp_tunnel_port_add as
                * const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( udp_tunnel_port_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . udp_tunnel_port_del as
                * const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( udp_tunnel_port_del ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . l2_tunnel_eth_type_conf
                as * const _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( l2_tunnel_eth_type_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . l2_tunnel_offload_set
                as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( l2_tunnel_offload_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_queue_rate_limit as
                * const _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( set_queue_rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rss_hash_update as *
                const _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rss_hash_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rss_hash_conf_get as *
                const _ as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( rss_hash_conf_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . reta_update as * const
                _ as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( reta_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . reta_query as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( reta_query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_reg as * const _ as
                usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( get_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_eeprom_length as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( get_eeprom_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_eeprom as * const _
                as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( get_eeprom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_eeprom as * const _
                as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( set_eeprom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . filter_ctrl as * const
                _ as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( filter_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_dcb_info as * const
                _ as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( get_dcb_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_enable as *
                const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_disable as *
                const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                timesync_read_rx_timestamp as * const _ as usize } , 584usize
                , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_read_rx_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                timesync_read_tx_timestamp as * const _ as usize } , 592usize
                , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_read_tx_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_adjust_time as
                * const _ as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_adjust_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_read_time as *
                const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_read_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_write_time as
                * const _ as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( timesync_write_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get_by_id as *
                const _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( xstats_get_by_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get_names_by_id
                as * const _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( xstats_get_names_by_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tm_ops_get as * const _
                as usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( eth_dev_ops ) , "::" ,
                stringify ! ( tm_ops_get ) ));
}
impl Clone for eth_dev_ops {
    fn clone(&self) -> Self { *self }
}
/// Function type used for RX packet processing packet callbacks.
///
/// The callback function is called on RX with a burst of packets that have
/// been received on the given port and queue.
///
/// @param port
/// The Ethernet port on which RX is being performed.
/// @param queue
/// The queue on the Ethernet port which is being used to receive the packets.
/// @param pkts
/// The burst of packets that have just been received.
/// @param nb_pkts
/// The number of packets in the burst pointed to by "pkts".
/// @param max_pkts
/// The max number of packets that can be stored in the "pkts" array.
/// @param user_param
/// The arbitrary user parameter passed in by the application when the callback
/// was originally configured.
/// @return
/// The number of packets returned to the user.
pub type rte_rx_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(port: u8, queue: u16,
                                               pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16, max_pkts: u16,
                                               user_param:
                                                   *mut ::std::os::raw::c_void)
                              -> u16>;
/// Function type used for TX packet processing packet callbacks.
///
/// The callback function is called on TX with a burst of packets immediately
/// before the packets are put onto the hardware queue for transmission.
///
/// @param port
/// The Ethernet port on which TX is being performed.
/// @param queue
/// The queue on the Ethernet port which is being used to transmit the packets.
/// @param pkts
/// The burst of packets that are about to be transmitted.
/// @param nb_pkts
/// The number of packets in the burst pointed to by "pkts".
/// @param user_param
/// The arbitrary user parameter passed in by the application when the callback
/// was originally configured.
/// @return
/// The number of packets to be written to the NIC.
pub type rte_tx_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(port: u8, queue: u16,
                                               pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16,
                                               user_param:
                                                   *mut ::std::os::raw::c_void)
                              -> u16>;
/// @internal
/// Structure used to hold information about the callbacks to be called for a
/// queue on RX and TX.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: __BindgenUnionField<rte_rx_callback_fn>,
    pub tx: __BindgenUnionField<rte_tx_callback_fn>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_eth_rxtx_callback__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_eth_rxtx_callback__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback__bindgen_ty_1 ) ) .
                rx as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_rxtx_callback__bindgen_ty_1 ) , "::" , stringify ! (
                rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback__bindgen_ty_1 ) ) .
                tx as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_rxtx_callback__bindgen_ty_1 ) , "::" , stringify ! (
                tx ) ));
}
impl Clone for rte_eth_rxtx_callback__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxtx_callback>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_rxtx_callback )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_rxtx_callback>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_rxtx_callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxtx_callback )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . fn_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxtx_callback )
                , "::" , stringify ! ( fn_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . param as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_rxtx_callback )
                , "::" , stringify ! ( param ) ));
}
impl Clone for rte_eth_rxtx_callback {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// A set of values to describe the possible states of an eth device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_dev_state {
    RTE_ETH_DEV_UNUSED = 0,
    RTE_ETH_DEV_ATTACHED = 1,
    RTE_ETH_DEV_DEFERRED = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_sriov {
    /// < SRIOV is active with 16, 32 or 64 pools
    pub active: u8,
    /// < rx queue number per pool
    pub nb_q_per_pool: u8,
    /// < Default pool num used for PF
    pub def_vmdq_idx: u16,
    /// < Default pool queue start reg index
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_sriov>() , 6usize , concat !
               ( "Size of: " , stringify ! ( rte_eth_dev_sriov ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dev_sriov>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_eth_dev_sriov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . active as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_sriov ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . nb_q_per_pool as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_sriov ) ,
                "::" , stringify ! ( nb_q_per_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . def_vmdq_idx as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_sriov ) ,
                "::" , stringify ! ( def_vmdq_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . def_pool_q_idx as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_sriov ) ,
                "::" , stringify ! ( def_pool_q_idx ) ));
}
impl Clone for rte_eth_dev_sriov {
    fn clone(&self) -> Self { *self }
}
/// @internal
/// The data part, with no function pointers, associated with each ethernet device.
///
/// This structure is safe to place in shared memory to be common among different
/// processes in a multi-process configuration.
#[repr(C)]
pub struct rte_eth_dev_data {
    /// < Unique identifier name
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Array of pointers to RX queues.
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    /// < Array of pointers to TX queues.
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    /// < Number of RX queues.
    pub nb_rx_queues: u16,
    /// < Number of TX queues.
    pub nb_tx_queues: u16,
    /// < SRIOV data
    pub sriov: rte_eth_dev_sriov,
    /// < PMD-specific private data
    pub dev_private: *mut ::std::os::raw::c_void,
    pub dev_link: rte_eth_link,
    /// < Configuration applied to device.
    pub dev_conf: rte_eth_conf,
    /// < Maximum Transmission Unit.
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    /// < RX ring mbuf allocation failures.
    pub rx_mbuf_alloc_failed: u64,
    /// < Device Ethernet Link address.
    pub mac_addrs: *mut ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    /// bitmap array of associating Ethernet MAC addresses to pools
    pub hash_mac_addrs: *mut ether_addr,
    /// < Device [external] port identifier.
    pub port_id: u8,
    pub _bitfield_1: u8,
    pub rx_queue_state: [u8; 1024usize],
    /// Queues state: STARTED(1) / STOPPED(0)
    pub tx_queue_state: [u8; 1024usize],
    /// < Capabilities
    pub dev_flags: u32,
    /// < Kernel driver passthrough
    pub kdrv: rte_kernel_driver,
    /// < NUMA node connection
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_data() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_data>() , 6656usize , concat
               ! ( "Size of: " , stringify ! ( rte_eth_dev_data ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_dev_data>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_eth_dev_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . rx_queues as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . tx_queues as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . nb_rx_queues as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( nb_rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . nb_tx_queues as *
                const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( nb_tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . sriov as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( sriov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . dev_private as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( dev_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . dev_link as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( dev_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . dev_conf as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( dev_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . mtu as * const _
                as usize } , 3024usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . min_rx_buf_size as
                * const _ as usize } , 3028usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( min_rx_buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) .
                rx_mbuf_alloc_failed as * const _ as usize } , 3032usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( rx_mbuf_alloc_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . mac_addrs as *
                const _ as usize } , 3040usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( mac_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . mac_pool_sel as *
                const _ as usize } , 3048usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( mac_pool_sel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . hash_mac_addrs as
                * const _ as usize } , 4072usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( hash_mac_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . port_id as * const
                _ as usize } , 4080usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( port_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . rx_queue_state as
                * const _ as usize } , 4082usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( rx_queue_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . tx_queue_state as
                * const _ as usize } , 5106usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( tx_queue_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . dev_flags as *
                const _ as usize } , 6132usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( dev_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . kdrv as * const _
                as usize } , 6136usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( kdrv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . numa_node as *
                const _ as usize } , 6140usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( numa_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_data ) ) . vlan_filter_conf
                as * const _ as usize } , 6144usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eth_dev_data ) ,
                "::" , stringify ! ( vlan_filter_conf ) ));
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(promiscuous: u8, scattered_rx: u8,
                          all_multicast: u8, dev_started: u8, lro: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((promiscuous as u8 as u8) << 0usize) &
                                     (1u64 as u8))
                        } |
                            ((scattered_rx as u8 as u8) << 1usize) &
                                (2u64 as u8))
                   } | ((all_multicast as u8 as u8) << 2usize) & (4u64 as u8))
              } | ((dev_started as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((lro as u8 as u8) << 4usize) & (16u64 as u8))
    }
}
extern "C" {
    #[link_name = "rte_eth_devices"]
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
extern "C" {
    /// Iterates over valid ethdev ports.
///
/// @param port_id
/// The id of the next possible valid port.
/// @return
/// Next valid port id, RTE_MAX_ETHPORTS if there is none.
    pub fn rte_eth_find_next(port_id: u8) -> u8;
}
extern "C" {
    /// Get the total number of Ethernet devices that have been successfully
/// initialized by the matching Ethernet driver during the PCI probing phase
/// and that are available for applications to use. These devices must be
/// accessed by using the ``RTE_ETH_FOREACH_DEV()`` macro to deal with
/// non-contiguous ranges of devices.
/// These non-contiguous ranges can be created by calls to hotplug functions or
/// by some PMDs.
///
/// @return
/// - The total number of usable Ethernet devices.
    pub fn rte_eth_dev_count() -> u8;
}
extern "C" {
    /// @internal
/// Returns a ethdev slot specified by the unique identifier name.
///
/// @param	name
/// The pointer to the Unique identifier name for each Ethernet device
/// @return
/// - The pointer to the ethdev slot, on success. NULL on error
    pub fn rte_eth_dev_allocated(name: *const ::std::os::raw::c_char)
     -> *mut rte_eth_dev;
}
extern "C" {
    /// @internal
/// Allocates a new ethdev slot for an ethernet device and returns the pointer
/// to that slot for the driver to use.
///
/// @param	name	Unique identifier name for each Ethernet device
/// @param	type	Device type of this Ethernet device
/// @return
/// - Slot in the rte_dev_devices array for a new device;
    pub fn rte_eth_dev_allocate(name: *const ::std::os::raw::c_char)
     -> *mut rte_eth_dev;
}
extern "C" {
    /// @internal
/// Attach to the ethdev already initialized by the primary
/// process.
///
/// @param       name    Ethernet device's name.
/// @return
/// - Success: Slot in the rte_dev_devices array for attached
/// device.
/// - Error: Null pointer.
    pub fn rte_eth_dev_attach_secondary(name: *const ::std::os::raw::c_char)
     -> *mut rte_eth_dev;
}
extern "C" {
    /// @internal
/// Release the specified ethdev port.
///
/// @param eth_dev
/// The *eth_dev* pointer is the address of the *rte_eth_dev* structure.
/// @return
/// - 0 on success, negative on error
    pub fn rte_eth_dev_release_port(eth_dev: *mut rte_eth_dev)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach a new Ethernet device specified by arguments.
///
/// @param devargs
/// A pointer to a strings array describing the new device
/// to be attached. The strings should be a pci address like
/// '0000:01:00.0' or virtual device name like 'net_pcap0'.
/// @param port_id
/// A pointer to a port identifier actually attached.
/// @return
/// 0 on success and port_id is filled, negative on error
    pub fn rte_eth_dev_attach(devargs: *const ::std::os::raw::c_char,
                              port_id: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach a Ethernet device specified by port identifier.
/// This function must be called when the device is in the
/// closed state.
///
/// @param port_id
/// The port identifier of the device to detach.
/// @param devname
/// A pointer to a buffer that will be filled with the device name.
/// This buffer must be at least RTE_DEV_NAME_MAX_LEN long.
/// @return
/// 0 on success and devname is filled, negative on error
    pub fn rte_eth_dev_detach(port_id: u8,
                              devname: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convert a numerical speed in Mbps to a bitmap flag that can be used in
/// the bitmap link_speeds of the struct rte_eth_conf
///
/// @param speed
/// Numerical speed value in Mbps
/// @param duplex
/// ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)
/// @return
/// 0 if the speed cannot be mapped
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int)
     -> u32;
}
extern "C" {
    /// Configure an Ethernet device.
/// This function must be invoked first before any other function in the
/// Ethernet API. This function can also be re-invoked when a device is in the
/// stopped state.
///
/// @param port_id
/// The port identifier of the Ethernet device to configure.
/// @param nb_rx_queue
/// The number of receive queues to set up for the Ethernet device.
/// @param nb_tx_queue
/// The number of transmit queues to set up for the Ethernet device.
/// @param eth_conf
/// The pointer to the configuration data to be used for the Ethernet device.
/// The *rte_eth_conf* structure includes:
/// -  the hardware offload features to activate, with dedicated fields for
/// each statically configurable offload hardware feature provided by
/// Ethernet devices, such as IP checksum or VLAN tag stripping for
/// example.
/// - the Receive Side Scaling (RSS) configuration when using multiple RX
/// queues per port.
///
/// Embedding all configuration information in a single data structure
/// is the more flexible method that allows the addition of new features
/// without changing the syntax of the API.
/// @return
/// - 0: Success, device configured.
/// - <0: Error code returned by the driver configuration function.
    pub fn rte_eth_dev_configure(port_id: u8, nb_rx_queue: u16,
                                 nb_tx_queue: u16,
                                 eth_conf: *const rte_eth_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal
/// Release device queues and clear its configuration to force the user
/// application to reconfigure it. It is for internal use only.
///
/// @param dev
/// Pointer to struct rte_eth_dev.
///
/// @return
/// void
    pub fn _rte_eth_dev_reset(dev: *mut rte_eth_dev);
}
extern "C" {
    /// Allocate and set up a receive queue for an Ethernet device.
///
/// The function allocates a contiguous block of memory for *nb_rx_desc*
/// receive descriptors from a memory zone associated with *socket_id*
/// and initializes each receive descriptor with a network buffer allocated
/// from the memory pool *mb_pool*.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rx_queue_id
/// The index of the receive queue to set up.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param nb_rx_desc
/// The number of receive descriptors to allocate for the receive ring.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in case of NUMA.
/// The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
/// the DMA memory allocated for the receive descriptors of the ring.
/// @param rx_conf
/// The pointer to the configuration data to be used for the receive queue.
/// NULL value is allowed, in which case default RX configuration
/// will be used.
/// The *rx_conf* structure contains an *rx_thresh* structure with the values
/// of the Prefetch, Host, and Write-Back threshold registers of the receive
/// ring.
/// @param mb_pool
/// The pointer to the memory pool from which to allocate *rte_mbuf* network
/// memory buffers to populate each descriptor of the receive ring.
/// @return
/// - 0: Success, receive queue correctly set up.
/// - -EINVAL: The size of network buffers which can be allocated from the
/// memory pool does not fit the various buffer sizes allowed by the
/// device controller.
/// - -ENOMEM: Unable to allocate the receive ring descriptors or to
/// allocate network memory buffers from the memory pool when
/// initializing receive descriptors.
    pub fn rte_eth_rx_queue_setup(port_id: u8, rx_queue_id: u16,
                                  nb_rx_desc: u16,
                                  socket_id: ::std::os::raw::c_uint,
                                  rx_conf: *const rte_eth_rxconf,
                                  mb_pool: *mut rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up a transmit queue for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param tx_queue_id
/// The index of the transmit queue to set up.
/// The value must be in the range [0, nb_tx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param nb_tx_desc
/// The number of transmit descriptors to allocate for the transmit ring.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in case of NUMA.
/// Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
/// the DMA memory allocated for the transmit descriptors of the ring.
/// @param tx_conf
/// The pointer to the configuration data to be used for the transmit queue.
/// NULL value is allowed, in which case default RX configuration
/// will be used.
/// The *tx_conf* structure contains the following data:
/// - The *tx_thresh* structure with the values of the Prefetch, Host, and
/// Write-Back threshold registers of the transmit ring.
/// When setting Write-Back threshold to the value greater then zero,
/// *tx_rs_thresh* value should be explicitly set to one.
/// - The *tx_free_thresh* value indicates the [minimum] number of network
/// buffers that must be pending in the transmit ring to trigger their
/// [implicit] freeing by the driver transmit function.
/// - The *tx_rs_thresh* value indicates the [minimum] number of transmit
/// descriptors that must be pending in the transmit ring before setting the
/// RS bit on a descriptor by the driver transmit function.
/// The *tx_rs_thresh* value should be less or equal then
/// *tx_free_thresh* value, and both of them should be less then
/// *nb_tx_desc* - 3.
/// - The *txq_flags* member contains flags to pass to the TX queue setup
/// function to configure the behavior of the TX queue. This should be set
/// to 0 if no special configuration is required.
///
/// Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces
/// the transmit function to use default values.
/// @return
/// - 0: Success, the transmit queue is correctly set up.
/// - -ENOMEM: Unable to allocate the transmit ring descriptors.
    pub fn rte_eth_tx_queue_setup(port_id: u8, tx_queue_id: u16,
                                  nb_tx_desc: u16,
                                  socket_id: ::std::os::raw::c_uint,
                                  tx_conf: *const rte_eth_txconf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the NUMA socket to which an Ethernet device is connected
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @return
/// The NUMA socket id to which the Ethernet device is connected or
/// a default of zero if the socket could not be determined.
/// -1 is returned is the port_id value is out of range.
    pub fn rte_eth_dev_socket_id(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if port_id of device is attached
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @return
/// - 0 if port is out of range or not attached
/// - 1 if device is attached
    pub fn rte_eth_dev_is_valid_port(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start specified RX queue of a port. It is used when rx_deferred_start
/// flag of the specified queue is true.
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @param rx_queue_id
/// The index of the rx queue to update the ring.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - 0: Success, the receive queue is started.
/// - -EINVAL: The port_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_rx_queue_start(port_id: u8, rx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop specified RX queue of a port
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @param rx_queue_id
/// The index of the rx queue to update the ring.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - 0: Success, the receive queue is stopped.
/// - -EINVAL: The port_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_rx_queue_stop(port_id: u8, rx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start TX for specified queue of a port. It is used when tx_deferred_start
/// flag of the specified queue is true.
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @param tx_queue_id
/// The index of the tx queue to update the ring.
/// The value must be in the range [0, nb_tx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - 0: Success, the transmit queue is started.
/// - -EINVAL: The port_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_tx_queue_start(port_id: u8, tx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop specified TX queue of a port
///
/// @param port_id
/// The port identifier of the Ethernet device
/// @param tx_queue_id
/// The index of the tx queue to update the ring.
/// The value must be in the range [0, nb_tx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - 0: Success, the transmit queue is stopped.
/// - -EINVAL: The port_id or the queue_id out of range.
/// - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_tx_queue_stop(port_id: u8, tx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start an Ethernet device.
///
/// The device start step is the last one and consists of setting the configured
/// offload features and in starting the transmit and the receive units of the
/// device.
/// On success, all basic functions exported by the Ethernet API (link status,
/// receive/transmit, and so on) can be invoked.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - 0: Success, Ethernet device started.
/// - <0: Error code of the driver device start function.
    pub fn rte_eth_dev_start(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop an Ethernet device. The device can be restarted with a call to
/// rte_eth_dev_start()
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_dev_stop(port_id: u8);
}
extern "C" {
    /// Link up an Ethernet device.
///
/// Set device link up will re-enable the device rx/tx
/// functionality after it is previously set device linked down.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - 0: Success, Ethernet device linked up.
/// - <0: Error code of the driver device link up function.
    pub fn rte_eth_dev_set_link_up(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Link down an Ethernet device.
/// The device rx/tx functionality will be disabled if success,
/// and it can be re-enabled with a call to
/// rte_eth_dev_set_link_up()
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_dev_set_link_down(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close a stopped Ethernet device. The device cannot be restarted!
/// The function frees all resources except for needed by the
/// closed state. To free these resources, call rte_eth_dev_detach().
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_dev_close(port_id: u8);
}
extern "C" {
    /// Enable receipt in promiscuous mode for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_promiscuous_enable(port_id: u8);
}
extern "C" {
    /// Disable receipt in promiscuous mode for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_promiscuous_disable(port_id: u8);
}
extern "C" {
    /// Return the value of promiscuous mode for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (1) if promiscuous is enabled
/// - (0) if promiscuous is disabled.
/// - (-1) on error
    pub fn rte_eth_promiscuous_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable the receipt of any multicast frame by an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_allmulticast_enable(port_id: u8);
}
extern "C" {
    /// Disable the receipt of all multicast frames by an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_allmulticast_disable(port_id: u8);
}
extern "C" {
    /// Return the value of allmulticast mode for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (1) if allmulticast is enabled
/// - (0) if allmulticast is disabled.
/// - (-1) on error
    pub fn rte_eth_allmulticast_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
/// or FULL-DUPLEX) of the physical link of an Ethernet device. It might need
/// to wait up to 9 seconds in it.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param link
/// A pointer to an *rte_eth_link* structure to be filled with
/// the status, the speed and the mode of the Ethernet device link.
    pub fn rte_eth_link_get(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    /// Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
/// or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait
/// version of rte_eth_link_get().
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param link
/// A pointer to an *rte_eth_link* structure to be filled with
/// the status, the speed and the mode of the Ethernet device link.
    pub fn rte_eth_link_get_nowait(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    /// Retrieve the general I/O statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param stats
/// A pointer to a structure of type *rte_eth_stats* to be filled with
/// the values of device counters for the following set of statistics:
/// - *ipackets* with the total of successfully received packets.
/// - *opackets* with the total of successfully transmitted packets.
/// - *ibytes*   with the total of successfully received bytes.
/// - *obytes*   with the total of successfully transmitted bytes.
/// - *ierrors*  with the total of erroneous received packets.
/// - *oerrors*  with the total of failed transmitted packets.
/// @return
/// Zero if successful. Non-zero otherwise.
    pub fn rte_eth_stats_get(port_id: u8, stats: *mut rte_eth_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset the general I/O statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_stats_reset(port_id: u8);
}
extern "C" {
    /// Retrieve names of extended statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param xstats_names
/// An rte_eth_xstat_name array of at least *size* elements to
/// be filled. If set to NULL, the function returns the required number
/// of elements.
/// @param size
/// The size of the xstats_names array (number of elements).
/// @return
/// - A positive value lower or equal to size: success. The return value
/// is the number of entries filled in the stats table.
/// - A positive value higher than size: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_names(port_id: u8,
                                    xstats_names: *mut rte_eth_xstat_name,
                                    size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve extended statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param xstats
/// A pointer to a table of structure of type *rte_eth_xstat*
/// to be filled with device statistics ids and values: id is the
/// index of the name string in xstats_names (see rte_eth_xstats_get_names()),
/// and value is the statistic counter.
/// This parameter can be set to NULL if n is 0.
/// @param n
/// The size of the xstats array (number of elements).
/// @return
/// - A positive value lower or equal to n: success. The return value
/// is the number of entries filled in the stats table.
/// - A positive value higher than n: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get(port_id: u8, xstats: *mut rte_eth_xstat,
                              n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve names of extended statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param xstats_names
/// An rte_eth_xstat_name array of at least *size* elements to
/// be filled. If set to NULL, the function returns the required number
/// of elements.
/// @param ids
/// IDs array given by app to retrieve specific statistics
/// @param size
/// The size of the xstats_names array (number of elements).
/// @return
/// - A positive value lower or equal to size: success. The return value
/// is the number of entries filled in the stats table.
/// - A positive value higher than size: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_names_by_id(port_id: u8,
                                          xstats_names:
                                              *mut rte_eth_xstat_name,
                                          size: ::std::os::raw::c_uint,
                                          ids: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve extended statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param ids
/// A pointer to an ids array passed by application. This tells which
/// statistics values function should retrieve. This parameter
/// can be set to NULL if n is 0. In this case function will retrieve
/// all avalible statistics.
/// @param values
/// A pointer to a table to be filled with device statistics values.
/// @param n
/// The size of the ids array (number of elements).
/// @return
/// - A positive value lower or equal to n: success. The return value
/// is the number of entries filled in the stats table.
/// - A positive value higher than n: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_by_id(port_id: u8, ids: *const u64,
                                    values: *mut u64,
                                    n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the ID of a statistic from its name.
///
/// This function searches for the statistics using string compares, and
/// as such should not be used on the fast-path. For fast-path retrieval of
/// specific statistics, store the ID as provided in *id* from this function,
/// and pass the ID to rte_eth_xstats_get()
///
/// @param port_id The port to look up statistics from
/// @param xstat_name The name of the statistic to return
/// @param[out] id A pointer to an app-supplied uint64_t which should be
/// set to the ID of the stat if the stat exists.
/// @return
/// 0 on success
/// -ENODEV for invalid port_id,
/// -EINVAL if the xstat_name doesn't exist in port_id
    pub fn rte_eth_xstats_get_id_by_name(port_id: u8,
                                         xstat_name:
                                             *const ::std::os::raw::c_char,
                                         id: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset extended statistics of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
    pub fn rte_eth_xstats_reset(port_id: u8);
}
extern "C" {
    /// Set a mapping for the specified transmit queue to the specified per-queue
/// statistics counter.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param tx_queue_id
/// The index of the transmit queue for which a queue stats mapping is required.
/// The value must be in the range [0, nb_tx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param stat_idx
/// The per-queue packet statistics functionality number that the transmit
/// queue is to be assigned.
/// The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1].
/// @return
/// Zero if successful. Non-zero otherwise.
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(port_id: u8,
                                                  tx_queue_id: u16,
                                                  stat_idx: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a mapping for the specified receive queue to the specified per-queue
/// statistics counter.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rx_queue_id
/// The index of the receive queue for which a queue stats mapping is required.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param stat_idx
/// The per-queue packet statistics functionality number that the receive
/// queue is to be assigned.
/// The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1].
/// @return
/// Zero if successful. Non-zero otherwise.
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(port_id: u8,
                                                  rx_queue_id: u16,
                                                  stat_idx: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the Ethernet address of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param mac_addr
/// A pointer to a structure of type *ether_addr* to be filled with
/// the Ethernet address of the Ethernet device.
    pub fn rte_eth_macaddr_get(port_id: u8, mac_addr: *mut ether_addr);
}
extern "C" {
    /// Retrieve the contextual information of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param dev_info
/// A pointer to a structure of type *rte_eth_dev_info* to be filled with
/// the contextual information of the Ethernet device.
    pub fn rte_eth_dev_info_get(port_id: u8, dev_info: *mut rte_eth_dev_info);
}
extern "C" {
    /// Retrieve the firmware version of a device.
///
/// @param port_id
/// The port identifier of the device.
/// @param fw_version
/// A pointer to a string array storing the firmware version of a device,
/// the string includes terminating null. This pointer is allocated by caller.
/// @param fw_size
/// The size of the string array pointed by fw_version, which should be
/// large enough to store firmware version of the device.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if operation is not supported.
/// - (-ENODEV) if *port_id* invalid.
/// - (>0) if *fw_size* is not enough to store firmware version, return
/// the size of the non truncated string.
    pub fn rte_eth_dev_fw_version_get(port_id: u8,
                                      fw_version: *mut ::std::os::raw::c_char,
                                      fw_size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the supported packet types of an Ethernet device.
///
/// When a packet type is announced as supported, it *must* be recognized by
/// the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN
/// and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following
/// packet types for these packets:
/// - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4
/// - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4
/// - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER
/// - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN
///
/// When a packet is received by a PMD, the most precise type must be
/// returned among the ones supported. However a PMD is allowed to set
/// packet type that is not in the supported list, at the condition that it
/// is more precise. Therefore, a PMD announcing no supported packet types
/// can still set a matching packet type in a received packet.
///
/// @note
/// Better to invoke this API after the device is already started or rx burst
/// function is decided, to obtain correct supported ptypes.
/// @note
/// if a given PMD does not report what ptypes it supports, then the supported
/// ptype count is reported as 0.
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param ptype_mask
/// A hint of what kind of packet type which the caller is interested in.
/// @param ptypes
/// An array pointer to store adequate packet types, allocated by caller.
/// @param num
/// Size of the array pointed by param ptypes.
/// @return
/// - (>=0) Number of supported ptypes. If the number of types exceeds num,
/// only num entries will be filled into the ptypes array, but the full
/// count of supported ptypes will be returned.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_supported_ptypes(port_id: u8, ptype_mask: u32,
                                            ptypes: *mut u32,
                                            num: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the MTU of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param mtu
/// A pointer to a uint16_t where the retrieved MTU is to be stored.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_mtu(port_id: u8, mtu: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Change the MTU of an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param mtu
/// A uint16_t for the MTU to be applied.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if operation is not supported.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if *mtu* invalid.
/// - (-EBUSY) if operation is not allowed when the port is running
    pub fn rte_eth_dev_set_mtu(port_id: u8, mtu: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware filtering by an Ethernet device of received
/// VLAN packets tagged with a given VLAN Tag Identifier.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param vlan_id
/// The VLAN Tag Identifier whose filtering must be enabled or disabled.
/// @param on
/// If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*.
/// Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*.
/// @return
/// - (0) if successful.
/// - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
/// - (-ENODEV) if *port_id* invalid.
/// - (-ENOSYS) if VLAN filtering on *port_id* disabled.
/// - (-EINVAL) if *vlan_id* > 4095.
    pub fn rte_eth_dev_vlan_filter(port_id: u8, vlan_id: u16,
                                   on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device.
/// 82599/X540/X550 can support VLAN stripping at the rx queue level
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rx_queue_id
/// The index of the receive queue for which a queue stats mapping is required.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param on
/// If 1, Enable VLAN Stripping of the receive queue of the Ethernet port.
/// If 0, Disable VLAN Stripping of the receive queue of the Ethernet port.
/// @return
/// - (0) if successful.
/// - (-ENOSUP) if hardware-assisted VLAN stripping not configured.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if *rx_queue_id* invalid.
    pub fn rte_eth_dev_set_vlan_strip_on_queue(port_id: u8, rx_queue_id: u16,
                                               on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to
/// the VLAN Header. This is a register setup available on some Intel NIC, not
/// but all, please check the data sheet for availability.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param vlan_type
/// The vlan type.
/// @param tag_type
/// The Tag Protocol ID
/// @return
/// - (0) if successful.
/// - (-ENOSUP) if hardware-assisted VLAN TPID setup is not supported.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_set_vlan_ether_type(port_id: u8,
                                           vlan_type: rte_vlan_type,
                                           tag_type: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set VLAN offload configuration on an Ethernet device
/// Enable/Disable Extended VLAN by an Ethernet device, This is a register setup
/// available on some Intel NIC, not but all, please check the data sheet for
/// availability.
/// Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here
/// the configuration is applied on the port level.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param offload_mask
/// The VLAN Offload bit mask can be mixed use with "OR"
/// ETH_VLAN_STRIP_OFFLOAD
/// ETH_VLAN_FILTER_OFFLOAD
/// ETH_VLAN_EXTEND_OFFLOAD
/// @return
/// - (0) if successful.
/// - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_set_vlan_offload(port_id: u8,
                                        offload_mask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read VLAN Offload configuration from an Ethernet device
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (>0) if successful. Bit mask to indicate
/// ETH_VLAN_STRIP_OFFLOAD
/// ETH_VLAN_FILTER_OFFLOAD
/// ETH_VLAN_EXTEND_OFFLOAD
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_vlan_offload(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set port based TX VLAN insertion on or off.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param pvid
/// Port based TX VLAN identifier together with user priority.
/// @param on
/// Turn on or off the port based TX VLAN insertion.
///
/// @return
/// - (0) if successful.
/// - negative if failed.
    pub fn rte_eth_dev_set_vlan_pvid(port_id: u8, pvid: u16,
                                     on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn =
    ::std::option::Option<unsafe extern "C" fn(unsent: *mut *mut rte_mbuf,
                                               count: u16,
                                               userdata:
                                                   *mut ::std::os::raw::c_void)>;
/// Structure used to buffer packets for future TX
/// Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    /// < Size of buffer for buffered tx
    pub size: u16,
    /// < Number of packets in the array
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_tx_buffer>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_eth_dev_tx_buffer )
               ));
    assert_eq! (::std::mem::align_of::<rte_eth_dev_tx_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_dev_tx_buffer ) ));
}
impl Clone for rte_eth_dev_tx_buffer {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Initialize default values for buffered transmitting
///
/// @param buffer
/// Tx buffer to be initialized.
/// @param size
/// Buffer size
/// @return
/// 0 if no error
    pub fn rte_eth_tx_buffer_init(buffer: *mut rte_eth_dev_tx_buffer,
                                  size: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure a callback for buffered packets which cannot be sent
///
/// Register a specific callback to be called when an attempt is made to send
/// all packets buffered on an ethernet port, but not all packets can
/// successfully be sent. The callback registered here will be called only
/// from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs.
/// The default callback configured for each queue by default just frees the
/// packets back to the calling mempool. If additional behaviour is required,
/// for example, to count dropped packets, or to retry transmission of packets
/// which cannot be sent, this function should be used to register a suitable
/// callback function to implement the desired behaviour.
/// The example callback "rte_eth_count_unsent_packet_callback()" is also
/// provided as reference.
///
/// @param buffer
/// The port identifier of the Ethernet device.
/// @param callback
/// The function to be used as the callback.
/// @param userdata
/// Arbitrary parameter to be passed to the callback function
/// @return
/// 0 on success, or -1 on error with rte_errno set appropriately
    pub fn rte_eth_tx_buffer_set_err_callback(buffer:
                                                  *mut rte_eth_dev_tx_buffer,
                                              callback: buffer_tx_error_fn,
                                              userdata:
                                                  *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Callback function for silently dropping unsent buffered packets.
///
/// This function can be passed to rte_eth_tx_buffer_set_err_callback() to
/// adjust the default behavior when buffered packets cannot be sent. This
/// function drops any unsent packets silently and is used by tx buffered
/// operations as default behavior.
///
/// NOTE: this function should not be called directly, instead it should be used
/// as a callback for packet buffering.
///
/// NOTE: when configuring this function as a callback with
/// rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
/// should point to an uint64_t value.
///
/// @param pkts
/// The previously buffered packets which could not be sent
/// @param unsent
/// The number of unsent packets in the pkts array
/// @param userdata
/// Not used
    pub fn rte_eth_tx_buffer_drop_callback(pkts: *mut *mut rte_mbuf,
                                           unsent: u16,
                                           userdata:
                                               *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Callback function for tracking unsent buffered packets.
///
/// This function can be passed to rte_eth_tx_buffer_set_err_callback() to
/// adjust the default behavior when buffered packets cannot be sent. This
/// function drops any unsent packets, but also updates a user-supplied counter
/// to track the overall number of packets dropped. The counter should be an
/// uint64_t variable.
///
/// NOTE: this function should not be called directly, instead it should be used
/// as a callback for packet buffering.
///
/// NOTE: when configuring this function as a callback with
/// rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
/// should point to an uint64_t value.
///
/// @param pkts
/// The previously buffered packets which could not be sent
/// @param unsent
/// The number of unsent packets in the pkts array
/// @param userdata
/// Pointer to an uint64_t value, which will be incremented by unsent
    pub fn rte_eth_tx_buffer_count_callback(pkts: *mut *mut rte_mbuf,
                                            unsent: u16,
                                            userdata:
                                                *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Request the driver to free mbufs currently cached by the driver. The
/// driver will only free the mbuf if it is no longer in use. It is the
/// application's responsibity to ensure rte_eth_tx_buffer_flush(..) is
/// called if needed.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The index of the transmit queue through which output packets must be
/// sent.
/// The value must be in the range [0, nb_tx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param free_cnt
/// Maximum number of packets to free. Use 0 to indicate all possible packets
/// should be freed. Note that a packet may be using multiple mbufs.
/// @return
/// Failure: < 0
/// -ENODEV: Invalid interface
/// -ENOTSUP: Driver does not support function
/// Success: >= 0
/// 0-n: Number of packets freed. More packets may still remain in ring that
/// are in use.
    pub fn rte_eth_tx_done_cleanup(port_id: u8, queue_id: u16, free_cnt: u32)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// The eth device event type for interrupt, and maybe others in the future.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_event_type {
    RTE_ETH_EVENT_UNKNOWN = 0,
    RTE_ETH_EVENT_INTR_LSC = 1,
    RTE_ETH_EVENT_QUEUE_STATE = 2,
    RTE_ETH_EVENT_INTR_RESET = 3,
    RTE_ETH_EVENT_VF_MBOX = 4,
    RTE_ETH_EVENT_MACSEC = 5,
    RTE_ETH_EVENT_INTR_RMV = 6,
    RTE_ETH_EVENT_MAX = 7,
}
pub type rte_eth_dev_cb_fn =
    ::std::option::Option<unsafe extern "C" fn(port_id: u8,
                                               event: rte_eth_event_type,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void,
                                               ret_param:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Register a callback function for specific port id.
///
/// @param port_id
/// Port id.
/// @param event
/// Event interested.
/// @param cb_fn
/// User supplied callback function to be called.
/// @param cb_arg
/// Pointer to the parameters for the registered callback.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_eth_dev_callback_register(port_id: u8,
                                         event: rte_eth_event_type,
                                         cb_fn: rte_eth_dev_cb_fn,
                                         cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unregister a callback function for specific port id.
///
/// @param port_id
/// Port id.
/// @param event
/// Event interested.
/// @param cb_fn
/// User supplied callback function to be called.
/// @param cb_arg
/// Pointer to the parameters for the registered callback. -1 means to
/// remove all for the same callback address and same event.
///
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_eth_dev_callback_unregister(port_id: u8,
                                           event: rte_eth_event_type,
                                           cb_fn: rte_eth_dev_cb_fn,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal Executes all the user application registered callbacks for
/// the specific device. It is for DPDK internal user only. User
/// application should not call it directly.
///
/// @param dev
/// Pointer to struct rte_eth_dev.
/// @param event
/// Eth device interrupt event type.
/// @param cb_arg
/// callback parameter.
/// @param ret_param
/// To pass data back to user application.
/// This allows the user application to decide if a particular function
/// is permitted or not.
///
/// @return
/// int
    pub fn _rte_eth_dev_callback_process(dev: *mut rte_eth_dev,
                                         event: rte_eth_event_type,
                                         cb_arg: *mut ::std::os::raw::c_void,
                                         ret_param:
                                             *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// When there is no rx packet coming in Rx Queue for a long time, we can
/// sleep lcore related to RX Queue for power saving, and enable rx interrupt
/// to be triggered when Rx packet arrives.
///
/// The rte_eth_dev_rx_intr_enable() function enables rx queue
/// interrupt on specific rx queue of a port.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The index of the receive queue from which to retrieve input packets.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if underlying hardware OR driver doesn't support
/// that operation.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_rx_intr_enable(port_id: u8, queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// When lcore wakes up from rx interrupt indicating packet coming, disable rx
/// interrupt and returns to polling mode.
///
/// The rte_eth_dev_rx_intr_disable() function disables rx queue
/// interrupt on specific rx queue of a port.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The index of the receive queue from which to retrieve input packets.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if underlying hardware OR driver doesn't support
/// that operation.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_rx_intr_disable(port_id: u8, queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// RX Interrupt control per port.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param epfd
/// Epoll instance fd which the intr vector associated to.
/// Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
/// @param op
/// The operation be performed for the vector.
/// Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
/// @param data
/// User raw data.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_eth_dev_rx_intr_ctl(port_id: u8, epfd: ::std::os::raw::c_int,
                                   op: ::std::os::raw::c_int,
                                   data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// RX Interrupt control per queue.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The index of the receive queue from which to retrieve input packets.
/// The value must be in the range [0, nb_rx_queue - 1] previously supplied
/// to rte_eth_dev_configure().
/// @param epfd
/// Epoll instance fd which the intr vector associated to.
/// Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
/// @param op
/// The operation be performed for the vector.
/// Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
/// @param data
/// User raw data.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_eth_dev_rx_intr_ctl_q(port_id: u8, queue_id: u16,
                                     epfd: ::std::os::raw::c_int,
                                     op: ::std::os::raw::c_int,
                                     data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Turn on the LED on the Ethernet device.
/// This function turns on the LED on the Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if underlying hardware OR driver doesn't support
/// that operation.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_led_on(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Turn off the LED on the Ethernet device.
/// This function turns off the LED on the Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if underlying hardware OR driver doesn't support
/// that operation.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_led_off(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get current status of the Ethernet link flow control for Ethernet device
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param fc_conf
/// The pointer to the structure where to store the flow control parameters.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support flow control.
/// - (-ENODEV)  if *port_id* invalid.
    pub fn rte_eth_dev_flow_ctrl_get(port_id: u8,
                                     fc_conf: *mut rte_eth_fc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure the Ethernet link flow control for Ethernet device
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param fc_conf
/// The pointer to the structure of the flow control parameters.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support flow control mode.
/// - (-ENODEV)  if *port_id* invalid.
/// - (-EINVAL)  if bad parameter
/// - (-EIO)     if flow control setup failure
    pub fn rte_eth_dev_flow_ctrl_set(port_id: u8,
                                     fc_conf: *mut rte_eth_fc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure the Ethernet priority flow control under DCB environment
/// for Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param pfc_conf
/// The pointer to the structure of the priority flow control parameters.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support priority flow control mode.
/// - (-ENODEV)  if *port_id* invalid.
/// - (-EINVAL)  if bad parameter
/// - (-EIO)     if flow control setup failure
    pub fn rte_eth_dev_priority_flow_ctrl_set(port_id: u8,
                                              pfc_conf: *mut rte_eth_pfc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a MAC address to an internal array of addresses used to enable whitelist
/// filtering to accept packets only if the destination MAC address matches.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac_addr
/// The MAC address to add.
/// @param pool
/// VMDq pool index to associate address with (if VMDq is enabled). If VMDq is
/// not enabled, this should be set to 0.
/// @return
/// - (0) if successfully added or *mac_addr" was already added.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port* is invalid.
/// - (-ENOSPC) if no more MAC addresses can be added.
/// - (-EINVAL) if MAC address is invalid.
    pub fn rte_eth_dev_mac_addr_add(port: u8, mac_addr: *mut ether_addr,
                                    pool: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a MAC address from the internal array of addresses.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac_addr
/// MAC address to remove.
/// @return
/// - (0) if successful, or *mac_addr* didn't exist.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port* invalid.
/// - (-EADDRINUSE) if attempting to remove the default MAC address
    pub fn rte_eth_dev_mac_addr_remove(port: u8, mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the default MAC address.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac_addr
/// New default MAC address.
/// @return
/// - (0) if successful, or *mac_addr* didn't exist.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if MAC address is invalid.
    pub fn rte_eth_dev_default_mac_addr_set(port: u8,
                                            mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param reta_conf
/// RETA to update.
/// @param reta_size
/// Redirection table size. The table size can be queried by
/// rte_eth_dev_info_get().
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_rss_reta_update(port: u8,
                                       reta_conf:
                                           *mut rte_eth_rss_reta_entry64,
                                       reta_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param reta_conf
/// RETA to query.
/// @param reta_size
/// Redirection table size. The table size can be queried by
/// rte_eth_dev_info_get().
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_rss_reta_query(port: u8,
                                      reta_conf:
                                          *mut rte_eth_rss_reta_entry64,
                                      reta_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates unicast hash table for receiving packet with the given destination
/// MAC address, and the packet is routed to all VFs for which the RX mode is
/// accept packets that match the unicast hash table.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param addr
/// Unicast MAC address.
/// @param on
/// 1 - Set an unicast hash bit for receiving packets with the MAC address.
/// 0 - Clear an unicast hash bit.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_uc_hash_table_set(port: u8, addr: *mut ether_addr,
                                         on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates all unicast hash bitmaps for receiving packet with any Unicast
/// Ethernet MAC addresses,the packet is routed to all VFs for which the RX
/// mode is accept packets that match the unicast hash table.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - Set all unicast hash bitmaps for receiving all the Ethernet
/// MAC addresses
/// 0 - Clear all unicast hash bitmaps
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_uc_all_hash_table_set(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a traffic mirroring rule on an Ethernet device
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param mirror_conf
/// The pointer to the traffic mirroring structure describing the mirroring rule.
/// The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,
/// destination pool and the value of rule if enable vlan or pool mirroring.
///
/// @param rule_id
/// The index of traffic mirroring rule, we support four separated rules.
/// @param on
/// 1 - Enable a mirroring rule.
/// 0 - Disable a mirroring rule.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if the mr_conf information is not correct.
    pub fn rte_eth_mirror_rule_set(port_id: u8,
                                   mirror_conf: *mut rte_eth_mirror_conf,
                                   rule_id: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset a traffic mirroring rule on an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rule_id
/// The index of traffic mirroring rule, we support four separated rules.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_mirror_rule_reset(port_id: u8, rule_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the rate limitation for a queue on an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_idx
/// The queue id.
/// @param tx_rate
/// The tx rate in Mbps. Allocated from the total port link speed.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_set_queue_rate_limit(port_id: u8, queue_idx: u16,
                                        tx_rate: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configuration of Receive Side Scaling hash computation of Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rss_conf
/// The new configuration to use for RSS hash computation on the port.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_rss_hash_update(port_id: u8,
                                       rss_conf: *mut rte_eth_rss_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve current configuration of Receive Side Scaling hash computation
/// of Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param rss_conf
/// Where to store the current RSS hash configuration of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support RSS.
    pub fn rte_eth_dev_rss_hash_conf_get(port_id: u8,
                                         rss_conf: *mut rte_eth_rss_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add UDP tunneling port for a specific type of tunnel.
/// The packets with this UDP port will be identified as this type of tunnel.
/// Before enabling any offloading function for a tunnel, users can call this API
/// to change or add more UDP port for the tunnel. So the offloading function
/// can take effect on the packets with the specific UDP port.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param tunnel_udp
/// UDP tunneling configuration.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_udp_tunnel_port_add(port_id: u8,
                                           tunnel_udp:
                                               *mut rte_eth_udp_tunnel)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete UDP tunneling port a specific type of tunnel.
/// The packets with this UDP port will not be identified as this type of tunnel
/// any more.
/// Before enabling any offloading function for a tunnel, users can call this API
/// to delete a UDP port for the tunnel. So the offloading function will not take
/// effect on the packets with the specific UDP port.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param tunnel_udp
/// UDP tunneling configuration.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_udp_tunnel_port_delete(port_id: u8,
                                              tunnel_udp:
                                                  *mut rte_eth_udp_tunnel)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check whether the filter type is supported on an Ethernet device.
/// All the supported filter types are defined in 'rte_eth_ctrl.h'.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param filter_type
/// Filter type.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this filter type.
/// - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_filter_supported(port_id: u8,
                                        filter_type: rte_filter_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Take operations to assigned filter type on an Ethernet device.
/// All the supported operations and filter types are defined in 'rte_eth_ctrl.h'.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param filter_type
/// Filter type.
/// @param filter_op
/// Type of operation.
/// @param arg
/// A pointer to arguments defined specifically for the operation.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - others depends on the specific operations implementation.
    pub fn rte_eth_dev_filter_ctrl(port_id: u8, filter_type: rte_filter_type,
                                   filter_op: rte_filter_op,
                                   arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get DCB information on an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param dcb_info
/// dcb information.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support.
    pub fn rte_eth_dev_get_dcb_info(port_id: u8,
                                    dcb_info: *mut rte_eth_dcb_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a callback to be called on packet RX on a given port and queue.
///
/// This API configures a function to be called for each burst of
/// packets received on a given NIC port queue. The return value is a pointer
/// that can be used to later remove the callback using
/// rte_eth_remove_rx_callback().
///
/// Multiple functions are called in the order that they are added.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The queue on the Ethernet device on which the callback is to be added.
/// @param fn
/// The callback function
/// @param user_param
/// A generic pointer parameter which will be passed to each invocation of the
/// callback function on this port and queue.
///
/// @return
/// NULL on error.
/// On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_rx_callback(port_id: u8, queue_id: u16,
                                   fn_: rte_rx_callback_fn,
                                   user_param: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Add a callback that must be called first on packet RX on a given port
/// and queue.
///
/// This API configures a first function to be called for each burst of
/// packets received on a given NIC port queue. The return value is a pointer
/// that can be used to later remove the callback using
/// rte_eth_remove_rx_callback().
///
/// Multiple functions are called in the order that they are added.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The queue on the Ethernet device on which the callback is to be added.
/// @param fn
/// The callback function
/// @param user_param
/// A generic pointer parameter which will be passed to each invocation of the
/// callback function on this port and queue.
///
/// @return
/// NULL on error.
/// On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_first_rx_callback(port_id: u8, queue_id: u16,
                                         fn_: rte_rx_callback_fn,
                                         user_param:
                                             *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Add a callback to be called on packet TX on a given port and queue.
///
/// This API configures a function to be called for each burst of
/// packets sent on a given NIC port queue. The return value is a pointer
/// that can be used to later remove the callback using
/// rte_eth_remove_tx_callback().
///
/// Multiple functions are called in the order that they are added.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The queue on the Ethernet device on which the callback is to be added.
/// @param fn
/// The callback function
/// @param user_param
/// A generic pointer parameter which will be passed to each invocation of the
/// callback function on this port and queue.
///
/// @return
/// NULL on error.
/// On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_tx_callback(port_id: u8, queue_id: u16,
                                   fn_: rte_tx_callback_fn,
                                   user_param: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Remove an RX packet callback from a given port and queue.
///
/// This function is used to removed callbacks that were added to a NIC port
/// queue using rte_eth_add_rx_callback().
///
/// Note: the callback is removed from the callback list but it isn't freed
/// since the it may still be in use. The memory for the callback can be
/// subsequently freed back by the application by calling rte_free():
///
/// - Immediately - if the port is stopped, or the user knows that no
/// callbacks are in flight e.g. if called from the thread doing RX/TX
/// on that queue.
///
/// - After a short delay - where the delay is sufficient to allow any
/// in-flight callbacks to complete.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The queue on the Ethernet device from which the callback is to be removed.
/// @param user_cb
/// User supplied callback created via rte_eth_add_rx_callback().
///
/// @return
/// - 0: Success. Callback was removed.
/// - -ENOTSUP: Callback support is not available.
/// - -EINVAL:  The port_id or the queue_id is out of range, or the callback
/// is NULL or not found for the port/queue.
    pub fn rte_eth_remove_rx_callback(port_id: u8, queue_id: u16,
                                      user_cb: *mut rte_eth_rxtx_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a TX packet callback from a given port and queue.
///
/// This function is used to removed callbacks that were added to a NIC port
/// queue using rte_eth_add_tx_callback().
///
/// Note: the callback is removed from the callback list but it isn't freed
/// since the it may still be in use. The memory for the callback can be
/// subsequently freed back by the application by calling rte_free():
///
/// - Immediately - if the port is stopped, or the user knows that no
/// callbacks are in flight e.g. if called from the thread doing RX/TX
/// on that queue.
///
/// - After a short delay - where the delay is sufficient to allow any
/// in-flight callbacks to complete.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The queue on the Ethernet device from which the callback is to be removed.
/// @param user_cb
/// User supplied callback created via rte_eth_add_tx_callback().
///
/// @return
/// - 0: Success. Callback was removed.
/// - -ENOTSUP: Callback support is not available.
/// - -EINVAL:  The port_id or the queue_id is out of range, or the callback
/// is NULL or not found for the port/queue.
    pub fn rte_eth_remove_tx_callback(port_id: u8, queue_id: u16,
                                      user_cb: *mut rte_eth_rxtx_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve information about given port's RX queue.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The RX queue on the Ethernet device for which information
/// will be retrieved.
/// @param qinfo
/// A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with
/// the information of the Ethernet device.
///
/// @return
/// - 0: Success
/// - -ENOTSUP: routine is not supported by the device PMD.
/// - -EINVAL:  The port_id or the queue_id is out of range.
    pub fn rte_eth_rx_queue_info_get(port_id: u8, queue_id: u16,
                                     qinfo: *mut rte_eth_rxq_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve information about given port's TX queue.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param queue_id
/// The TX queue on the Ethernet device for which information
/// will be retrieved.
/// @param qinfo
/// A pointer to a structure of type *rte_eth_txq_info_info* to be filled with
/// the information of the Ethernet device.
///
/// @return
/// - 0: Success
/// - -ENOTSUP: routine is not supported by the device PMD.
/// - -EINVAL:  The port_id or the queue_id is out of range.
    pub fn rte_eth_tx_queue_info_get(port_id: u8, queue_id: u16,
                                     qinfo: *mut rte_eth_txq_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve device registers and register attributes (number of registers and
/// register size)
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param info
/// Pointer to rte_dev_reg_info structure to fill in. If info->data is
/// NULL the function fills in the width and length fields. If non-NULL
/// the registers are put into the buffer pointed at by the data field.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_reg_info(port_id: u8, info: *mut rte_dev_reg_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve size of device EEPROM
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @return
/// - (>=0) EEPROM size if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_eeprom_length(port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve EEPROM and EEPROM attribute
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param info
/// The template includes buffer for return EEPROM data and
/// EEPROM attributes to be filled.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_eeprom(port_id: u8, info: *mut rte_dev_eeprom_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Program EEPROM with provided data
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param info
/// The template includes EEPROM data for programming and
/// EEPROM attributes to be filled
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - others depends on the specific operations implementation.
    pub fn rte_eth_dev_set_eeprom(port_id: u8, info: *mut rte_dev_eeprom_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the list of multicast addresses to filter on an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param mc_addr_set
/// The array of multicast addresses to set. Equal to NULL when the function
/// is invoked to flush the set of filtered addresses.
/// @param nb_mc_addr
/// The number of multicast addresses in the *mc_addr_set* array. Equal to 0
/// when the function is invoked to flush the set of filtered addresses.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port_id* invalid.
/// - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering.
/// - (-ENOSPC) if *port_id* has not enough multicast filtering resources.
    pub fn rte_eth_dev_set_mc_addr_list(port_id: u8,
                                        mc_addr_set: *mut ether_addr,
                                        nb_mc_addr: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable IEEE1588/802.1AS timestamping for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
///
/// @return
/// - 0: Success.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_enable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disable IEEE1588/802.1AS timestamping for an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
///
/// @return
/// - 0: Success.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_disable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read an IEEE1588/802.1AS RX timestamp from an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param timestamp
/// Pointer to the timestamp struct.
/// @param flags
/// Device specific flags. Used to pass the RX timesync register index to
/// i40e. Unused in igb/ixgbe, pass 0 instead.
///
/// @return
/// - 0: Success.
/// - -EINVAL: No timestamp is available.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_read_rx_timestamp(port_id: u8,
                                              timestamp: *mut timespec,
                                              flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read an IEEE1588/802.1AS TX timestamp from an Ethernet device.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param timestamp
/// Pointer to the timestamp struct.
///
/// @return
/// - 0: Success.
/// - -EINVAL: No timestamp is available.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_read_tx_timestamp(port_id: u8,
                                              timestamp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Adjust the timesync clock on an Ethernet device.
///
/// This is usually used in conjunction with other Ethdev timesync functions to
/// synchronize the device time using the IEEE1588/802.1AS protocol.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param delta
/// The adjustment in nanoseconds.
///
/// @return
/// - 0: Success.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_adjust_time(port_id: u8, delta: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read the time from the timesync clock on an Ethernet device.
///
/// This is usually used in conjunction with other Ethdev timesync functions to
/// synchronize the device time using the IEEE1588/802.1AS protocol.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param time
/// Pointer to the timespec struct that holds the time.
///
/// @return
/// - 0: Success.
    pub fn rte_eth_timesync_read_time(port_id: u8, time: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the time of the timesync clock on an Ethernet device.
///
/// This is usually used in conjunction with other Ethdev timesync functions to
/// synchronize the device time using the IEEE1588/802.1AS protocol.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param time
/// Pointer to the timespec struct that holds the time.
///
/// @return
/// - 0: Success.
/// - -EINVAL: No timestamp is available.
/// - -ENODEV: The port ID is invalid.
/// - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_write_time(port_id: u8, time: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create memzone for HW rings.
/// malloc can't be used as the physical address is needed.
/// If the memzone is already created, then this function returns a ptr
/// to the old one.
///
/// @param eth_dev
/// The *eth_dev* pointer is the address of the *rte_eth_dev* structure
/// @param name
/// The name of the memory zone
/// @param queue_id
/// The index of the queue to add to name
/// @param size
/// The sizeof of the memory area
/// @param align
/// Alignment for resulting memzone. Must be a power of 2.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in case of NUMA.
    pub fn rte_eth_dma_zone_reserve(eth_dev: *const rte_eth_dev,
                                    name: *const ::std::os::raw::c_char,
                                    queue_id: u16, size: usize,
                                    align: ::std::os::raw::c_uint,
                                    socket_id: ::std::os::raw::c_int)
     -> *const rte_memzone;
}
extern "C" {
    /// Config l2 tunnel ether type of an Ethernet device for filtering specific
/// tunnel packets by ether type.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param l2_tunnel
/// l2 tunnel configuration.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(port_id: u8,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/disable l2 tunnel offload functions. Include,
/// 1, The ability of parsing a type of l2 tunnel of an Ethernet device.
/// Filtering, forwarding and offloading this type of tunnel packets depend on
/// this ability.
/// 2, Stripping the l2 tunnel tag.
/// 3, Insertion of the l2 tunnel tag.
/// 4, Forwarding the packets based on the l2 tunnel tag.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param l2_tunnel
/// l2 tunnel parameters.
/// @param mask
/// Indicate the offload function.
/// @param en
/// Enable or disable this function.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if port identifier is invalid.
/// - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_l2_tunnel_offload_set(port_id: u8,
                                             l2_tunnel:
                                                 *mut rte_eth_l2_tunnel_conf,
                                             mask: u32, en: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the port id from pci address or device name
/// Ex: 0000:2:00.0 or vdev name net_pcap0
///
/// @param name
/// pci address or name of the device
/// @param port_id
/// pointer to port identifier of the device
/// @return
/// - (0) if successful and port_id is filled.
/// - (-ENODEV or -EINVAL) on failure.
    pub fn rte_eth_dev_get_port_by_name(name: *const ::std::os::raw::c_char,
                                        port_id: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the device name from port id
///
/// @param port_id
/// pointer to port identifier of the device
/// @param name
/// pci address or name of the device
/// @return
/// - (0) if successful.
/// - (-EINVAL) on failure.
    pub fn rte_eth_dev_get_name_by_port(port_id: u8,
                                        name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check that numbers of Rx and Tx descriptors satisfy descriptors limits from
/// the ethernet device information, otherwise adjust them to boundaries.
///
/// @param port_id
/// The port identifier of the Ethernet device.
/// @param nb_rx_desc
/// A pointer to a uint16_t where the number of receive
/// descriptors stored.
/// @param nb_tx_desc
/// A pointer to a uint16_t where the number of transmit
/// descriptors stored.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP, -ENODEV or -EINVAL) on failure.
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(port_id: u8, nb_rx_desc: *mut u16,
                                            nb_tx_desc: *mut u16)
     -> ::std::os::raw::c_int;
}
pub type eth_dev_pci_callback_t =
    ::std::option::Option<unsafe extern "C" fn(eth_dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Create a new ethdev port from a set of rings
///
/// @param name
/// name to be given to the new ethdev port
/// @param rx_queues
/// pointer to array of rte_rings to be used as RX queues
/// @param nb_rx_queues
/// number of elements in the rx_queues array
/// @param tx_queues
/// pointer to array of rte_rings to be used as TX queues
/// @param nb_tx_queues
/// number of elements in the tx_queues array
/// @param numa_node
/// the numa node on which the memory for this port is to be allocated
/// @return
/// the port number of the newly created the ethdev or -1 on error.
    pub fn rte_eth_from_rings(name: *const ::std::os::raw::c_char,
                              rx_queues: *const *const rte_ring,
                              nb_rx_queues: ::std::os::raw::c_uint,
                              tx_queues: *const *const rte_ring,
                              nb_tx_queues: ::std::os::raw::c_uint,
                              numa_node: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a new ethdev port from a ring
///
/// This function is a shortcut call for rte_eth_from_rings for the
/// case where one wants to take a single rte_ring and use it as though
/// it were an ethdev
///
/// @param ring
/// the ring to be used as an ethdev
/// @return
/// the port number of the newly created ethdev, or -1 on error
    pub fn rte_eth_from_ring(r: *mut rte_ring) -> ::std::os::raw::c_int;
}
pub const EFD_SEMAPHORE: _bindgen_ty_23 = _bindgen_ty_23::EFD_SEMAPHORE;
pub const EFD_CLOEXEC: _bindgen_ty_23 = _bindgen_ty_23::EFD_CLOEXEC;
pub const EFD_NONBLOCK: _bindgen_ty_23 = _bindgen_ty_23::EFD_NONBLOCK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    EFD_SEMAPHORE = 1,
    EFD_CLOEXEC = 524288,
    EFD_NONBLOCK = 2048,
}
pub type eventfd_t = u64;
extern "C" {
    pub fn eventfd(__count: ::std::os::raw::c_uint,
                   __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eventfd_read(__fd: ::std::os::raw::c_int, __value: *mut eventfd_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eventfd_write(__fd: ::std::os::raw::c_int, __value: eventfd_t)
     -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __virtio16 = __u16;
pub type __virtio32 = __u32;
pub type __virtio64 = __u64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vring_desc {
    pub addr: __virtio64,
    pub len: __virtio32,
    pub flags: __virtio16,
    pub next: __virtio16,
}
#[test]
fn bindgen_test_layout_vring_desc() {
    assert_eq!(::std::mem::size_of::<vring_desc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( vring_desc ) ));
    assert_eq! (::std::mem::align_of::<vring_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vring_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_desc ) ) . addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_desc ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_desc ) ) . len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_desc ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_desc ) ) . flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_desc ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_desc ) ) . next as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_desc ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for vring_desc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vring_avail {
    pub flags: __virtio16,
    pub idx: __virtio16,
    pub ring: __IncompleteArrayField<__virtio16>,
}
#[test]
fn bindgen_test_layout_vring_avail() {
    assert_eq!(::std::mem::size_of::<vring_avail>() , 4usize , concat ! (
               "Size of: " , stringify ! ( vring_avail ) ));
    assert_eq! (::std::mem::align_of::<vring_avail>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( vring_avail ) ));
}
impl Clone for vring_avail {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vring_used_elem {
    pub id: __virtio32,
    pub len: __virtio32,
}
#[test]
fn bindgen_test_layout_vring_used_elem() {
    assert_eq!(::std::mem::size_of::<vring_used_elem>() , 8usize , concat ! (
               "Size of: " , stringify ! ( vring_used_elem ) ));
    assert_eq! (::std::mem::align_of::<vring_used_elem>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( vring_used_elem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_used_elem ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_used_elem ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring_used_elem ) ) . len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vring_used_elem ) ,
                "::" , stringify ! ( len ) ));
}
impl Clone for vring_used_elem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vring_used {
    pub flags: __virtio16,
    pub idx: __virtio16,
    pub ring: __IncompleteArrayField<vring_used_elem>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_vring_used() {
    assert_eq!(::std::mem::size_of::<vring_used>() , 4usize , concat ! (
               "Size of: " , stringify ! ( vring_used ) ));
    assert_eq! (::std::mem::align_of::<vring_used>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( vring_used ) ));
}
impl Clone for vring_used {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vring {
    pub num: ::std::os::raw::c_uint,
    pub desc: *mut vring_desc,
    pub avail: *mut vring_avail,
    pub used: *mut vring_used,
}
#[test]
fn bindgen_test_layout_vring() {
    assert_eq!(::std::mem::size_of::<vring>() , 32usize , concat ! (
               "Size of: " , stringify ! ( vring ) ));
    assert_eq! (::std::mem::align_of::<vring>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring ) ) . num as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( vring ) , "::" ,
                stringify ! ( num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring ) ) . desc as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vring ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring ) ) . avail as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vring ) , "::" ,
                stringify ! ( avail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vring ) ) . used as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vring ) , "::" ,
                stringify ! ( used ) ));
}
impl Clone for vring {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_vring_state {
    pub index: ::std::os::raw::c_uint,
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vhost_vring_state() {
    assert_eq!(::std::mem::size_of::<vhost_vring_state>() , 8usize , concat !
               ( "Size of: " , stringify ! ( vhost_vring_state ) ));
    assert_eq! (::std::mem::align_of::<vhost_vring_state>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( vhost_vring_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_state ) ) . index as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_state ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_state ) ) . num as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_state ) ,
                "::" , stringify ! ( num ) ));
}
impl Clone for vhost_vring_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_vring_file {
    pub index: ::std::os::raw::c_uint,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vhost_vring_file() {
    assert_eq!(::std::mem::size_of::<vhost_vring_file>() , 8usize , concat ! (
               "Size of: " , stringify ! ( vhost_vring_file ) ));
    assert_eq! (::std::mem::align_of::<vhost_vring_file>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( vhost_vring_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_file ) ) . index as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_file ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_file ) ) . fd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_file ) ,
                "::" , stringify ! ( fd ) ));
}
impl Clone for vhost_vring_file {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_vring_addr {
    pub index: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub desc_user_addr: __u64,
    pub used_user_addr: __u64,
    pub avail_user_addr: __u64,
    pub log_guest_addr: __u64,
}
#[test]
fn bindgen_test_layout_vhost_vring_addr() {
    assert_eq!(::std::mem::size_of::<vhost_vring_addr>() , 40usize , concat !
               ( "Size of: " , stringify ! ( vhost_vring_addr ) ));
    assert_eq! (::std::mem::align_of::<vhost_vring_addr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( vhost_vring_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . index as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . desc_user_addr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( desc_user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . used_user_addr as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( used_user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . avail_user_addr as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( avail_user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_vring_addr ) ) . log_guest_addr as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_vring_addr ) ,
                "::" , stringify ! ( log_guest_addr ) ));
}
impl Clone for vhost_vring_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_memory_region {
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
    pub userspace_addr: __u64,
    pub flags_padding: __u64,
}
#[test]
fn bindgen_test_layout_vhost_memory_region() {
    assert_eq!(::std::mem::size_of::<vhost_memory_region>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( vhost_memory_region ) ));
    assert_eq! (::std::mem::align_of::<vhost_memory_region>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( vhost_memory_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory_region ) ) . guest_phys_addr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory_region ) ,
                "::" , stringify ! ( guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory_region ) ) . memory_size as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory_region ) ,
                "::" , stringify ! ( memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory_region ) ) . userspace_addr
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory_region ) ,
                "::" , stringify ! ( userspace_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory_region ) ) . flags_padding
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory_region ) ,
                "::" , stringify ! ( flags_padding ) ));
}
impl Clone for vhost_memory_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_memory {
    pub nregions: __u32,
    pub padding: __u32,
    pub regions: __IncompleteArrayField<vhost_memory_region>,
}
#[test]
fn bindgen_test_layout_vhost_memory() {
    assert_eq!(::std::mem::size_of::<vhost_memory>() , 8usize , concat ! (
               "Size of: " , stringify ! ( vhost_memory ) ));
    assert_eq! (::std::mem::align_of::<vhost_memory>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vhost_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory ) ) . nregions as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory ) , "::" ,
                stringify ! ( nregions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory ) ) . padding as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory ) , "::" ,
                stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_memory ) ) . regions as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_memory ) , "::" ,
                stringify ! ( regions ) ));
}
impl Clone for vhost_memory {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct vhost_scsi_target {
    pub abi_version: ::std::os::raw::c_int,
    pub vhost_wwpn: [::std::os::raw::c_char; 224usize],
    pub vhost_tpgt: ::std::os::raw::c_ushort,
    pub reserved: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_vhost_scsi_target() {
    assert_eq!(::std::mem::size_of::<vhost_scsi_target>() , 232usize , concat
               ! ( "Size of: " , stringify ! ( vhost_scsi_target ) ));
    assert_eq! (::std::mem::align_of::<vhost_scsi_target>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( vhost_scsi_target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_scsi_target ) ) . abi_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_scsi_target ) ,
                "::" , stringify ! ( abi_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_scsi_target ) ) . vhost_wwpn as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_scsi_target ) ,
                "::" , stringify ! ( vhost_wwpn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_scsi_target ) ) . vhost_tpgt as *
                const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_scsi_target ) ,
                "::" , stringify ! ( vhost_tpgt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_scsi_target ) ) . reserved as *
                const _ as usize } , 230usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_scsi_target ) ,
                "::" , stringify ! ( reserved ) ));
}
/// Information relating to memory regions including offsets to
/// addresses in QEMUs memory file.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vhost_mem_region {
    pub guest_phys_addr: u64,
    pub guest_user_addr: u64,
    pub host_user_addr: u64,
    pub size: u64,
    pub mmap_addr: *mut ::std::os::raw::c_void,
    pub mmap_size: u64,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_vhost_mem_region() {
    assert_eq!(::std::mem::size_of::<rte_vhost_mem_region>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( rte_vhost_mem_region )
               ));
    assert_eq! (::std::mem::align_of::<rte_vhost_mem_region>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_vhost_mem_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) .
                guest_phys_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) .
                guest_user_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( guest_user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) . host_user_addr
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( host_user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) . size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) . mmap_addr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( mmap_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) . mmap_size as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( mmap_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_mem_region ) ) . fd as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_mem_region )
                , "::" , stringify ! ( fd ) ));
}
impl Clone for rte_vhost_mem_region {
    fn clone(&self) -> Self { *self }
}
/// Memory structure includes region and mapping information.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vhost_memory {
    pub nregions: u32,
    pub regions: __IncompleteArrayField<rte_vhost_mem_region>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_vhost_memory() {
    assert_eq!(::std::mem::size_of::<rte_vhost_memory>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_vhost_memory ) ));
    assert_eq! (::std::mem::align_of::<rte_vhost_memory>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_vhost_memory ) ));
}
impl Clone for rte_vhost_memory {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_vhost_vring {
    pub desc: *mut vring_desc,
    pub avail: *mut vring_avail,
    pub used: *mut vring_used,
    pub log_guest_addr: u64,
    pub callfd: ::std::os::raw::c_int,
    pub kickfd: ::std::os::raw::c_int,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_rte_vhost_vring() {
    assert_eq!(::std::mem::size_of::<rte_vhost_vring>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_vhost_vring ) ));
    assert_eq! (::std::mem::align_of::<rte_vhost_vring>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_vhost_vring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . desc as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . avail as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( avail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . used as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . log_guest_addr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( log_guest_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . callfd as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( callfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . kickfd as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( kickfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_vhost_vring ) ) . size as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_vhost_vring ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for rte_vhost_vring {
    fn clone(&self) -> Self { *self }
}
/// Device and vring operations.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vhost_device_ops {
    /// < Add device.
    pub new_device: ::std::option::Option<unsafe extern "C" fn(vid:
                                                                   ::std::os::raw::c_int)
                                              -> ::std::os::raw::c_int>,
    /// < Remove device.
    pub destroy_device: ::std::option::Option<unsafe extern "C" fn(vid:
                                                                       ::std::os::raw::c_int)>,
    /// < triggered when a vring is enabled or disabled
    pub vring_state_changed: ::std::option::Option<unsafe extern "C" fn(vid:
                                                                            ::std::os::raw::c_int,
                                                                        queue_id:
                                                                            u16,
                                                                        enable:
                                                                            ::std::os::raw::c_int)
                                                       ->
                                                           ::std::os::raw::c_int>,
    /// Features could be changed after the feature negotiation.
    /// For example, VHOST_F_LOG_ALL will be set/cleared at the
    /// start/end of live migration, respectively. This callback
    /// is used to inform the application on such change.
    pub features_changed: ::std::option::Option<unsafe extern "C" fn(vid:
                                                                         ::std::os::raw::c_int,
                                                                     features:
                                                                         u64)
                                                    -> ::std::os::raw::c_int>,
    /// < Reserved for future extension
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout_vhost_device_ops() {
    assert_eq!(::std::mem::size_of::<vhost_device_ops>() , 64usize , concat !
               ( "Size of: " , stringify ! ( vhost_device_ops ) ));
    assert_eq! (::std::mem::align_of::<vhost_device_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( vhost_device_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_device_ops ) ) . new_device as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_device_ops ) ,
                "::" , stringify ! ( new_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_device_ops ) ) . destroy_device as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_device_ops ) ,
                "::" , stringify ! ( destroy_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_device_ops ) ) .
                vring_state_changed as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( vhost_device_ops ) ,
                "::" , stringify ! ( vring_state_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_device_ops ) ) . features_changed
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_device_ops ) ,
                "::" , stringify ! ( features_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vhost_device_ops ) ) . reserved as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vhost_device_ops ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for vhost_device_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Log the memory write start with given address.
///
/// This function only need be invoked when the live migration starts.
/// Therefore, we won't need call it at all in the most of time. For
/// making the performance impact be minimum, it's suggested to do a
/// check before calling it:
///
/// if (unlikely(RTE_VHOST_NEED_LOG(features)))
/// rte_vhost_log_write(vid, addr, len);
///
/// @param vid
/// vhost device ID
/// @param addr
/// the starting address for write
/// @param len
/// the length to write
    pub fn rte_vhost_log_write(vid: ::std::os::raw::c_int, addr: u64,
                               len: u64);
}
extern "C" {
    /// Log the used ring update start at given offset.
///
/// Same as rte_vhost_log_write, it's suggested to do a check before
/// calling it:
///
/// if (unlikely(RTE_VHOST_NEED_LOG(features)))
/// rte_vhost_log_used_vring(vid, vring_idx, offset, len);
///
/// @param vid
/// vhost device ID
/// @param vring_idx
/// the vring index
/// @param offset
/// the offset inside the used ring
/// @param len
/// the length to write
    pub fn rte_vhost_log_used_vring(vid: ::std::os::raw::c_int,
                                    vring_idx: u16, offset: u64, len: u64);
}
extern "C" {
    pub fn rte_vhost_enable_guest_notification(vid: ::std::os::raw::c_int,
                                               queue_id: u16,
                                               enable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register vhost driver. path could be different for multiple
/// instance support.
    pub fn rte_vhost_driver_register(path: *const ::std::os::raw::c_char,
                                     flags: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_vhost_driver_unregister(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the feature bits the vhost-user driver supports.
///
/// @param path
/// The vhost-user socket file path
/// @param features
/// Supported features
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_driver_set_features(path: *const ::std::os::raw::c_char,
                                         features: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable vhost-user driver features.
///
/// Note that
/// - the param features should be a subset of the feature bits provided
/// by rte_vhost_driver_set_features().
/// - it must be invoked before vhost-user negotiation starts.
///
/// @param path
/// The vhost-user socket file path
/// @param features
/// Features to enable
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_driver_enable_features(path:
                                                *const ::std::os::raw::c_char,
                                            features: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disable vhost-user driver features.
///
/// The two notes at rte_vhost_driver_enable_features() also apply here.
///
/// @param path
/// The vhost-user socket file path
/// @param features
/// Features to disable
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_driver_disable_features(path:
                                                 *const ::std::os::raw::c_char,
                                             features: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the feature bits before feature negotiation.
///
/// @param path
/// The vhost-user socket file path
/// @param features
/// A pointer to store the queried feature bits
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_driver_get_features(path: *const ::std::os::raw::c_char,
                                         features: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the feature bits after negotiation
///
/// @param vid
/// Vhost device ID
/// @param features
/// A pointer to store the queried feature bits
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_get_negotiated_features(vid: ::std::os::raw::c_int,
                                             features: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_vhost_driver_callback_register(path:
                                                  *const ::std::os::raw::c_char,
                                              ops: *const vhost_device_ops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start the vhost-user driver.
///
/// This function triggers the vhost-user negotiation.
///
/// @param path
/// The vhost-user socket file path
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_driver_start(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the MTU value of the device if set in QEMU.
///
/// @param vid
/// virtio-net device ID
/// @param mtu
/// The variable to store the MTU value
///
/// @return
/// 0: success
/// -EAGAIN: device not yet started
/// -ENOTSUP: device does not support MTU feature
    pub fn rte_vhost_get_mtu(vid: ::std::os::raw::c_int, mtu: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the numa node from which the virtio net device's memory
/// is allocated.
///
/// @param vid
/// vhost device ID
///
/// @return
/// The numa node, -1 on failure
    pub fn rte_vhost_get_numa_node(vid: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated
/// Get the number of queues the device supports.
///
/// Note this function is deprecated, as it returns a queue pair number,
/// which is vhost specific. Instead, rte_vhost_get_vring_num should
/// be used.
///
/// @param vid
/// vhost device ID
///
/// @return
/// The number of queues, 0 on failure
    pub fn rte_vhost_get_queue_num(vid: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    /// Get the number of vrings the device supports.
///
/// @param vid
/// vhost device ID
///
/// @return
/// The number of vrings, 0 on failure
    pub fn rte_vhost_get_vring_num(vid: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    /// Get the virtio net device's ifname, which is the vhost-user socket
/// file path.
///
/// @param vid
/// vhost device ID
/// @param buf
/// The buffer to stored the queried ifname
/// @param len
/// The length of buf
///
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_get_ifname(vid: ::std::os::raw::c_int,
                                buf: *mut ::std::os::raw::c_char, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get how many avail entries are left in the queue
///
/// @param vid
/// vhost device ID
/// @param queue_id
/// virtio queue index
///
/// @return
/// num of avail entires left
    pub fn rte_vhost_avail_entries(vid: ::std::os::raw::c_int, queue_id: u16)
     -> u16;
}
extern "C" {
    /// This function adds buffers to the virtio devices RX virtqueue. Buffers can
/// be received from the physical port or from another virtual device. A packet
/// count is returned to indicate the number of packets that were successfully
/// added to the RX queue.
/// @param vid
/// vhost device ID
/// @param queue_id
/// virtio queue index in mq case
/// @param pkts
/// array to contain packets to be enqueued
/// @param count
/// packets num to be enqueued
/// @return
/// num of packets enqueued
    pub fn rte_vhost_enqueue_burst(vid: ::std::os::raw::c_int, queue_id: u16,
                                   pkts: *mut *mut rte_mbuf, count: u16)
     -> u16;
}
extern "C" {
    /// This function gets guest buffers from the virtio device TX virtqueue,
/// construct host mbufs, copies guest buffer content to host mbufs and
/// store them in pkts to be processed.
/// @param vid
/// vhost device ID
/// @param queue_id
/// virtio queue index in mq case
/// @param mbuf_pool
/// mbuf_pool where host mbuf is allocated.
/// @param pkts
/// array to contain packets to be dequeued
/// @param count
/// packets num to be dequeued
/// @return
/// num of packets dequeued
    pub fn rte_vhost_dequeue_burst(vid: ::std::os::raw::c_int, queue_id: u16,
                                   mbuf_pool: *mut rte_mempool,
                                   pkts: *mut *mut rte_mbuf, count: u16)
     -> u16;
}
extern "C" {
    /// Get guest mem table: a list of memory regions.
///
/// An rte_vhost_vhost_memory object will be allocated internaly, to hold the
/// guest memory regions. Application should free it at destroy_device()
/// callback.
///
/// @param vid
/// vhost device ID
/// @param mem
/// To store the returned mem regions
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_get_mem_table(vid: ::std::os::raw::c_int,
                                   mem: *mut *mut rte_vhost_memory)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get guest vring info, including the vring address, vring size, etc.
///
/// @param vid
/// vhost device ID
/// @param vring_idx
/// vring index
/// @param vring
/// the structure to hold the requested vring info
/// @return
/// 0 on success, -1 on failure
    pub fn rte_vhost_get_vhost_vring(vid: ::std::os::raw::c_int,
                                     vring_idx: u16,
                                     vring: *mut rte_vhost_vring)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get vhost RX queue avail count.
///
/// @param vid
/// vhost device ID
/// @param qid
/// virtio queue index in mq case
/// @return
/// num of desc available
    pub fn rte_vhost_rx_queue_count(vid: ::std::os::raw::c_int, qid: u16)
     -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vhost_queue_event {
    pub queue_id: u16,
    pub rx: bool,
    pub enable: bool,
}
#[test]
fn bindgen_test_layout_rte_eth_vhost_queue_event() {
    assert_eq!(::std::mem::size_of::<rte_eth_vhost_queue_event>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_eth_vhost_queue_event ) ));
    assert_eq! (::std::mem::align_of::<rte_eth_vhost_queue_event>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eth_vhost_queue_event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vhost_queue_event ) ) . queue_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vhost_queue_event ) , "::" , stringify ! ( queue_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vhost_queue_event ) ) . rx as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vhost_queue_event ) , "::" , stringify ! ( rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vhost_queue_event ) ) . enable as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_eth_vhost_queue_event ) , "::" , stringify ! ( enable )
                ));
}
impl Clone for rte_eth_vhost_queue_event {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Get queue events from specified port.
/// If a callback for below event is registered by
/// rte_eth_dev_callback_register(), this function will describe what was
/// changed.
/// - RTE_ETH_EVENT_QUEUE_STATE
/// Multiple events may cause only one callback kicking, so call this function
/// while returning 0.
///
/// @param port_id
/// Port id.
/// @param event
/// Pointer to a rte_eth_vhost_queue_event structure.
/// @return
/// - On success, zero.
/// - On failure, a negative value.
    pub fn rte_eth_vhost_get_queue_event(port_id: u8,
                                         event:
                                             *mut rte_eth_vhost_queue_event)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the 'vid' value associated with the specified port.
///
/// @return
/// - On success, the 'vid' associated with 'port_id'.
/// - On failure, a negative value.
    pub fn rte_eth_vhost_get_vid_from_port_id(port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the total number of event devices that have been successfully
/// initialised.
///
/// @return
/// The total number of usable event devices.
    pub fn rte_event_dev_count() -> u8;
}
extern "C" {
    /// Get the device identifier for the named event device.
///
/// @param name
/// Event device name to select the event device identifier.
///
/// @return
/// Returns event device identifier on success.
/// - <0: Failure to find named event device.
    pub fn rte_event_dev_get_dev_id(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the NUMA socket to which a device is connected.
///
/// @param dev_id
/// The identifier of the device.
/// @return
/// The NUMA socket id to which the device is connected or
/// a default of zero if the socket could not be determined.
/// -(-EINVAL)  dev_id value is out of range.
    pub fn rte_event_dev_socket_id(dev_id: u8) -> ::std::os::raw::c_int;
}
/// Event device information
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event_dev_info {
    /// < Event driver name
    pub driver_name: *const ::std::os::raw::c_char,
    /// < Device information
    pub dev: *mut rte_device,
    pub min_dequeue_timeout_ns: u32,
    pub max_dequeue_timeout_ns: u32,
    pub dequeue_timeout_ns: u32,
    pub max_event_queues: u8,
    pub max_event_queue_flows: u32,
    pub max_event_queue_priority_levels: u8,
    pub max_event_priority_levels: u8,
    pub max_event_ports: u8,
    pub max_event_port_dequeue_depth: u8,
    pub max_event_port_enqueue_depth: u32,
    pub max_num_events: i32,
    pub event_dev_cap: u32,
}
#[test]
fn bindgen_test_layout_rte_event_dev_info() {
    assert_eq!(::std::mem::size_of::<rte_event_dev_info>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( rte_event_dev_info ) ));
    assert_eq! (::std::mem::align_of::<rte_event_dev_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_event_dev_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . driver_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( driver_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . dev as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                min_dequeue_timeout_ns as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( min_dequeue_timeout_ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_dequeue_timeout_ns as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_dequeue_timeout_ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                dequeue_timeout_ns as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( dequeue_timeout_ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . max_event_queues
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_event_queue_flows as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_queue_flows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_event_queue_priority_levels as * const _ as usize } ,
                36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_queue_priority_levels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_event_priority_levels as * const _ as usize } , 37usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_priority_levels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . max_event_ports
                as * const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_ports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_event_port_dequeue_depth as * const _ as usize } , 39usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_port_dequeue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) .
                max_event_port_enqueue_depth as * const _ as usize } , 40usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_event_port_enqueue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . max_num_events
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( max_num_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_info ) ) . event_dev_cap as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_info ) ,
                "::" , stringify ! ( event_dev_cap ) ));
}
impl Clone for rte_event_dev_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Retrieve the contextual information of an event device.
///
/// @param dev_id
/// The identifier of the device.
///
/// @param[out] dev_info
/// A pointer to a structure of type *rte_event_dev_info* to be filled with the
/// contextual information of the device.
///
/// @return
/// - 0: Success, driver updates the contextual information of the event device
/// - <0: Error code returned by the driver info get function.
///
    pub fn rte_event_dev_info_get(dev_id: u8,
                                  dev_info: *mut rte_event_dev_info)
     -> ::std::os::raw::c_int;
}
/// Event device configuration structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event_dev_config {
    pub dequeue_timeout_ns: u32,
    pub nb_events_limit: i32,
    pub nb_event_queues: u8,
    pub nb_event_ports: u8,
    pub nb_event_queue_flows: u32,
    pub nb_event_port_dequeue_depth: u32,
    pub nb_event_port_enqueue_depth: u32,
    pub event_dev_cfg: u32,
}
#[test]
fn bindgen_test_layout_rte_event_dev_config() {
    assert_eq!(::std::mem::size_of::<rte_event_dev_config>() , 28usize ,
               concat ! ( "Size of: " , stringify ! ( rte_event_dev_config )
               ));
    assert_eq! (::std::mem::align_of::<rte_event_dev_config>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event_dev_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                dequeue_timeout_ns as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( dequeue_timeout_ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                nb_events_limit as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_events_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                nb_event_queues as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_event_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) . nb_event_ports
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_event_ports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                nb_event_queue_flows as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_event_queue_flows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                nb_event_port_dequeue_depth as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_event_port_dequeue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) .
                nb_event_port_enqueue_depth as * const _ as usize } , 20usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( nb_event_port_enqueue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_config ) ) . event_dev_cfg
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_dev_config )
                , "::" , stringify ! ( event_dev_cfg ) ));
}
impl Clone for rte_event_dev_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Configure an event device.
///
/// This function must be invoked first before any other function in the
/// API. This function can also be re-invoked when a device is in the
/// stopped state.
///
/// The caller may use rte_event_dev_info_get() to get the capability of each
/// resources available for this event device.
///
/// @param dev_id
/// The identifier of the device to configure.
/// @param dev_conf
/// The event device configuration structure.
///
/// @return
/// - 0: Success, device configured.
/// - <0: Error code returned by the driver configuration function.
    pub fn rte_event_dev_configure(dev_id: u8,
                                   dev_conf: *const rte_event_dev_config)
     -> ::std::os::raw::c_int;
}
/// Event queue configuration structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event_queue_conf {
    pub nb_atomic_flows: u32,
    pub nb_atomic_order_sequences: u32,
    /// < Queue cfg flags(EVENT_QUEUE_CFG_)
    pub event_queue_cfg: u32,
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_event_queue_conf() {
    assert_eq!(::std::mem::size_of::<rte_event_queue_conf>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_event_queue_conf )
               ));
    assert_eq! (::std::mem::align_of::<rte_event_queue_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event_queue_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_queue_conf ) ) .
                nb_atomic_flows as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_queue_conf )
                , "::" , stringify ! ( nb_atomic_flows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_queue_conf ) ) .
                nb_atomic_order_sequences as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_event_queue_conf )
                , "::" , stringify ! ( nb_atomic_order_sequences ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_queue_conf ) ) .
                event_queue_cfg as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_queue_conf )
                , "::" , stringify ! ( event_queue_cfg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_queue_conf ) ) . priority as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_queue_conf )
                , "::" , stringify ! ( priority ) ));
}
impl Clone for rte_event_queue_conf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Retrieve the default configuration information of an event queue designated
/// by its *queue_id* from the event driver for an event device.
///
/// This function intended to be used in conjunction with rte_event_queue_setup()
/// where caller needs to set up the queue by overriding few default values.
///
/// @param dev_id
/// The identifier of the device.
/// @param queue_id
/// The index of the event queue to get the configuration information.
/// The value must be in the range [0, nb_event_queues - 1]
/// previously supplied to rte_event_dev_configure().
/// @param[out] queue_conf
/// The pointer to the default event queue configuration data.
/// @return
/// - 0: Success, driver updates the default event queue configuration data.
/// - <0: Error code returned by the driver info get function.
///
/// @see rte_event_queue_setup()
///
    pub fn rte_event_queue_default_conf_get(dev_id: u8, queue_id: u8,
                                            queue_conf:
                                                *mut rte_event_queue_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up an event queue for an event device.
///
/// @param dev_id
/// The identifier of the device.
/// @param queue_id
/// The index of the event queue to setup. The value must be in the range
/// [0, nb_event_queues - 1] previously supplied to rte_event_dev_configure().
/// @param queue_conf
/// The pointer to the configuration data to be used for the event queue.
/// NULL value is allowed, in which case default configuration	used.
///
/// @see rte_event_queue_default_conf_get()
///
/// @return
/// - 0: Success, event queue correctly set up.
/// - <0: event queue configuration failed
    pub fn rte_event_queue_setup(dev_id: u8, queue_id: u8,
                                 queue_conf: *const rte_event_queue_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of event queues on a specific event device
///
/// @param dev_id
/// Event device identifier.
/// @return
/// - The number of configured event queues
    pub fn rte_event_queue_count(dev_id: u8) -> u8;
}
extern "C" {
    /// Get the priority of the event queue on a specific event device
///
/// @param dev_id
/// Event device identifier.
/// @param queue_id
/// Event queue identifier.
/// @return
/// - If the device has RTE_EVENT_DEV_CAP_QUEUE_QOS capability then the
/// configured priority of the event queue in
/// [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST] range
/// else the value RTE_EVENT_DEV_PRIORITY_NORMAL
    pub fn rte_event_queue_priority(dev_id: u8, queue_id: u8) -> u8;
}
/// Event port configuration structure
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event_port_conf {
    pub new_event_threshold: i32,
    pub dequeue_depth: u16,
    pub enqueue_depth: u16,
}
#[test]
fn bindgen_test_layout_rte_event_port_conf() {
    assert_eq!(::std::mem::size_of::<rte_event_port_conf>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_event_port_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_event_port_conf>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event_port_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_port_conf ) ) .
                new_event_threshold as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_event_port_conf ) ,
                "::" , stringify ! ( new_event_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_port_conf ) ) . dequeue_depth
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_port_conf ) ,
                "::" , stringify ! ( dequeue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_port_conf ) ) . enqueue_depth
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_port_conf ) ,
                "::" , stringify ! ( enqueue_depth ) ));
}
impl Clone for rte_event_port_conf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Retrieve the default configuration information of an event port designated
/// by its *port_id* from the event driver for an event device.
///
/// This function intended to be used in conjunction with rte_event_port_setup()
/// where caller needs to set up the port by overriding few default values.
///
/// @param dev_id
/// The identifier of the device.
/// @param port_id
/// The index of the event port to get the configuration information.
/// The value must be in the range [0, nb_event_ports - 1]
/// previously supplied to rte_event_dev_configure().
/// @param[out] port_conf
/// The pointer to the default event port configuration data
/// @return
/// - 0: Success, driver updates the default event port configuration data.
/// - <0: Error code returned by the driver info get function.
///
/// @see rte_event_port_setup()
///
    pub fn rte_event_port_default_conf_get(dev_id: u8, port_id: u8,
                                           port_conf:
                                               *mut rte_event_port_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up an event port for an event device.
///
/// @param dev_id
/// The identifier of the device.
/// @param port_id
/// The index of the event port to setup. The value must be in the range
/// [0, nb_event_ports - 1] previously supplied to rte_event_dev_configure().
/// @param port_conf
/// The pointer to the configuration data to be used for the queue.
/// NULL value is allowed, in which case default configuration	used.
///
/// @see rte_event_port_default_conf_get()
///
/// @return
/// - 0: Success, event port correctly set up.
/// - <0: Port configuration failed
/// - (-EDQUOT) Quota exceeded(Application tried to link the queue configured
/// with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports)
    pub fn rte_event_port_setup(dev_id: u8, port_id: u8,
                                port_conf: *const rte_event_port_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of dequeue queue depth configured for event port designated
/// by its *port_id* on a specific event device
///
/// @param dev_id
/// Event device identifier.
/// @param port_id
/// Event port identifier.
/// @return
/// - The number of configured dequeue queue depth
///
/// @see rte_event_dequeue_burst()
    pub fn rte_event_port_dequeue_depth(dev_id: u8, port_id: u8) -> u8;
}
extern "C" {
    /// Get the number of enqueue queue depth configured for event port designated
/// by its *port_id* on a specific event device
///
/// @param dev_id
/// Event device identifier.
/// @param port_id
/// Event port identifier.
/// @return
/// - The number of configured enqueue queue depth
///
/// @see rte_event_enqueue_burst()
    pub fn rte_event_port_enqueue_depth(dev_id: u8, port_id: u8) -> u8;
}
extern "C" {
    /// Get the number of ports on a specific event device
///
/// @param dev_id
/// Event device identifier.
/// @return
/// - The number of configured ports
    pub fn rte_event_port_count(dev_id: u8) -> u8;
}
extern "C" {
    /// Start an event device.
///
/// The device start step is the last one and consists of setting the event
/// queues to start accepting the events and schedules to event ports.
///
/// On success, all basic functions exported by the API (event enqueue,
/// event dequeue and so on) can be invoked.
///
/// @param dev_id
/// Event device identifier
/// @return
/// - 0: Success, device started.
/// - -ESTALE : Not all ports of the device are configured
/// - -ENOLINK: Not all queues are linked, which could lead to deadlock.
    pub fn rte_event_dev_start(dev_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop an event device. The device can be restarted with a call to
/// rte_event_dev_start()
///
/// @param dev_id
/// Event device identifier.
    pub fn rte_event_dev_stop(dev_id: u8);
}
extern "C" {
    /// Close an event device. The device cannot be restarted!
///
/// @param dev_id
/// Event device identifier
///
/// @return
/// - 0 on successfully closing device
/// - <0 on failure to close device
/// - (-EAGAIN) if device is busy
    pub fn rte_event_dev_close(dev_id: u8) -> ::std::os::raw::c_int;
}
/// The generic *rte_event* structure to hold the event attributes
/// for dequeue and enqueue operation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event {
    pub __bindgen_anon_1: rte_event__bindgen_ty_1,
    pub __bindgen_anon_2: rte_event__bindgen_ty_2,
}
/// WORD0
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event__bindgen_ty_1 {
    pub event: __BindgenUnionField<u64>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_event__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
/// Event attributes for dequeue or enqueue operation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: [u32; 2usize],
    pub queue_id: u8,
    pub priority: u8,
    pub impl_opaque: u8,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_event__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_event__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               rte_event__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_event__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_event__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_1__bindgen_ty_1 ) )
                . queue_id as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_event__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                queue_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_1__bindgen_ty_1 ) )
                . priority as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_event__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_1__bindgen_ty_1 ) )
                . impl_opaque as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_event__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                impl_opaque ) ));
}
impl Clone for rte_event__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl rte_event__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn flow_id(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1048575u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_flow_id(&mut self, val: u32) {
        let mask = 1048575u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn sub_event_type(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 267386880u64 as u64;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sub_event_type(&mut self, val: u32) {
        let mask = 267386880u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn event_type(&self) -> u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4026531840u64 as u64;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_event_type(&mut self, val: u32) {
        let mask = 4026531840u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn op(&self) -> u8 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 12884901888u64 as u64;
        let val = (unit_field_val & mask) >> 32usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_op(&mut self, val: u8) {
        let mask = 12884901888u64 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 32usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 257698037760u64 as u64;
        let val = (unit_field_val & mask) >> 34usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        let mask = 257698037760u64 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 34usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn sched_type(&self) -> u8 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 824633720832u64 as u64;
        let val = (unit_field_val & mask) >> 38usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_sched_type(&mut self, val: u8) {
        let mask = 824633720832u64 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 38usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(flow_id: u32, sub_event_type: u32, event_type: u32,
                          op: u8, rsvd: u8, sched_type: u8) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((flow_id as u32 as u64) << 0usize) &
                                          (1048575u64 as u64))
                             } |
                                 ((sub_event_type as u32 as u64) << 20usize) &
                                     (267386880u64 as u64))
                        } |
                            ((event_type as u32 as u64) << 28usize) &
                                (4026531840u64 as u64))
                   } |
                       ((op as u8 as u64) << 32usize) &
                           (12884901888u64 as u64))
              } | ((rsvd as u8 as u64) << 34usize) & (257698037760u64 as u64))
         } |
             ((sched_type as u8 as u64) << 38usize) &
                 (824633720832u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_rte_event__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_event__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_event__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_event__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_1 ) ) . event as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event__bindgen_ty_1
                ) , "::" , stringify ! ( event ) ));
}
impl Clone for rte_event__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/// WORD1
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_event__bindgen_ty_2 {
    pub u64: __BindgenUnionField<u64>,
    pub event_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub mbuf: __BindgenUnionField<*mut rte_mbuf>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_event__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_event__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_event__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_event__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_2 ) ) . u64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event__bindgen_ty_2
                ) , "::" , stringify ! ( u64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_2 ) ) . event_ptr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event__bindgen_ty_2
                ) , "::" , stringify ! ( event_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event__bindgen_ty_2 ) ) . mbuf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event__bindgen_ty_2
                ) , "::" , stringify ! ( mbuf ) ));
}
impl Clone for rte_event__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_event() {
    assert_eq!(::std::mem::size_of::<rte_event>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_event ) ));
    assert_eq! (::std::mem::align_of::<rte_event>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_event ) ));
}
impl Clone for rte_event {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eventdev_driver {
    _unused: [u8; 0],
}
/// Event device operations function pointer table
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eventdev_ops {
    /// < Get device info.
    pub dev_infos_get: eventdev_info_get_t,
    /// < Configure device.
    pub dev_configure: eventdev_configure_t,
    /// < Start device.
    pub dev_start: eventdev_start_t,
    /// < Stop device.
    pub dev_stop: eventdev_stop_t,
    /// < Close device.
    pub dev_close: eventdev_close_t,
    pub queue_def_conf: eventdev_queue_default_conf_get_t,
    pub queue_setup: eventdev_queue_setup_t,
    pub queue_release: eventdev_queue_release_t,
    pub port_def_conf: eventdev_port_default_conf_get_t,
    pub port_setup: eventdev_port_setup_t,
    pub port_release: eventdev_port_release_t,
    pub port_link: eventdev_port_link_t,
    pub port_unlink: eventdev_port_unlink_t,
    pub timeout_ticks: eventdev_dequeue_timeout_ticks_t,
    pub dump: eventdev_dump_t,
    pub xstats_get: eventdev_xstats_get_t,
    pub xstats_get_names: eventdev_xstats_get_names_t,
    pub xstats_get_by_name: eventdev_xstats_get_by_name,
    pub xstats_reset: eventdev_xstats_reset_t,
}
#[test]
fn bindgen_test_layout_rte_eventdev_ops() {
    assert_eq!(::std::mem::size_of::<rte_eventdev_ops>() , 152usize , concat !
               ( "Size of: " , stringify ! ( rte_eventdev_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_eventdev_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_eventdev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dev_infos_get as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dev_infos_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dev_configure as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dev_configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dev_start as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dev_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dev_stop as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dev_stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dev_close as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dev_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . queue_def_conf as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( queue_def_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . queue_setup as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( queue_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . queue_release as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( queue_release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . port_def_conf as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( port_def_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . port_setup as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( port_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . port_release as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( port_release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . port_link as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( port_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . port_unlink as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( port_unlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . timeout_ticks as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( timeout_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . dump as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( dump ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . xstats_get as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( xstats_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . xstats_get_names
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( xstats_get_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . xstats_get_by_name
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( xstats_get_by_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_ops ) ) . xstats_reset as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_ops ) ,
                "::" , stringify ! ( xstats_reset ) ));
}
impl Clone for rte_eventdev_ops {
    fn clone(&self) -> Self { *self }
}
/// @internal The data structure associated with each event device.
#[repr(C)]
#[derive(Copy)]
pub struct rte_eventdev {
    pub schedule: event_schedule_t,
    pub enqueue: event_enqueue_t,
    pub enqueue_burst: event_enqueue_burst_t,
    pub enqueue_new_burst: event_enqueue_burst_t,
    pub enqueue_forward_burst: event_enqueue_burst_t,
    pub dequeue: event_dequeue_t,
    pub dequeue_burst: event_dequeue_burst_t,
    pub data: *mut rte_eventdev_data,
    pub dev_ops: *const rte_eventdev_ops,
    pub dev: *mut rte_device,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 47usize],
}
#[test]
fn bindgen_test_layout_rte_eventdev() {
    assert_eq!(::std::mem::size_of::<rte_eventdev>() , 128usize , concat ! (
               "Size of: " , stringify ! ( rte_eventdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . schedule as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( schedule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . enqueue as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . enqueue_burst as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( enqueue_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . enqueue_new_burst as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( enqueue_new_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . enqueue_forward_burst
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( enqueue_forward_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . dequeue as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( dequeue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . dequeue_burst as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( dequeue_burst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . data as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . dev_ops as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( dev_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev ) ) . dev as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev ) , "::" ,
                stringify ! ( dev ) ));
}
impl Clone for rte_eventdev {
    fn clone(&self) -> Self { *self }
}
impl rte_eventdev {
    #[inline]
    pub fn attached(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_attached(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(attached: u8) -> u8 {
        ({ 0 } | ((attached as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type event_schedule_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev)>;
pub type event_enqueue_t =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               ev: *const rte_event) -> u16>;
pub type event_enqueue_burst_t =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               ev: *const rte_event,
                                               nb_events: u16) -> u16>;
pub type event_dequeue_t =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               ev: *mut rte_event,
                                               timeout_ticks: u64) -> u16>;
pub type event_dequeue_burst_t =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               ev: *mut rte_event,
                                               nb_events: u16,
                                               timeout_ticks: u64) -> u16>;
/// @internal
/// The data part, with no function pointers, associated with each device.
///
/// This structure is safe to place in shared memory to be common among
/// different processes in a multi-process configuration.
#[repr(C)]
pub struct rte_eventdev_data {
    pub socket_id: ::std::os::raw::c_int,
    pub dev_id: u8,
    pub nb_queues: u8,
    pub nb_ports: u8,
    pub ports: *mut *mut ::std::os::raw::c_void,
    pub ports_dequeue_depth: *mut u8,
    pub ports_enqueue_depth: *mut u8,
    pub queues_prio: *mut u8,
    pub links_map: *mut u16,
    pub dev_private: *mut ::std::os::raw::c_void,
    pub event_dev_cap: u32,
    pub dev_conf: rte_event_dev_config,
    pub _bitfield_1: u8,
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_padding_0: [u8; 39usize],
}
#[test]
fn bindgen_test_layout_rte_eventdev_data() {
    assert_eq!(::std::mem::size_of::<rte_eventdev_data>() , 192usize , concat
               ! ( "Size of: " , stringify ! ( rte_eventdev_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . socket_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . dev_id as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . nb_queues as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( nb_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . nb_ports as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( nb_ports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . ports as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( ports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) .
                ports_dequeue_depth as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( ports_dequeue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) .
                ports_enqueue_depth as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( ports_enqueue_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . queues_prio as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( queues_prio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . links_map as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( links_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . dev_private as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( dev_private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . event_dev_cap as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( event_dev_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . dev_conf as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( dev_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_data ) ) . name as * const _
                as usize } , 89usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_data ) ,
                "::" , stringify ! ( name ) ));
}
impl rte_eventdev_data {
    #[inline]
    pub fn dev_started(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(dev_started: u8) -> u8 {
        ({ 0 } | ((dev_started as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
extern "C" {
    #[link_name = "rte_eventdevs"]
    pub static mut rte_eventdevs: *mut rte_eventdev;
}
extern "C" {
    /// Converts nanoseconds to *timeout_ticks* value for rte_event_dequeue_burst()
///
/// If the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT flag
/// then application can use this function to convert timeout value in
/// nanoseconds to implementations specific timeout value supplied in
/// rte_event_dequeue_burst()
///
/// @param dev_id
/// The identifier of the device.
/// @param ns
/// Wait time in nanosecond
/// @param[out] timeout_ticks
/// Value for the *timeout_ticks* parameter in rte_event_dequeue_burst()
///
/// @return
/// - 0 on success.
/// - -ENOTSUP if the device doesn't support timeouts
/// - -EINVAL if *dev_id* is invalid or *timeout_ticks* is NULL
/// - other values < 0 on failure.
///
/// @see rte_event_dequeue_burst(), RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT
/// @see rte_event_dev_configure()
///
    pub fn rte_event_dequeue_timeout_ticks(dev_id: u8, ns: u64,
                                           timeout_ticks: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Link multiple source event queues supplied in *queues* to the destination
/// event port designated by its *port_id* with associated service priority
/// supplied in *priorities* on the event device designated by its *dev_id*.
///
/// The link establishment shall enable the event port *port_id* from
/// receiving events from the specified event queue(s) supplied in *queues*
///
/// An event queue may link to one or more event ports.
/// The number of links can be established from an event queue to event port is
/// implementation defined.
///
/// Event queue(s) to event port link establishment can be changed at runtime
/// without re-configuring the device to support scaling and to reduce the
/// latency of critical work by establishing the link with more event ports
/// at runtime.
///
/// @param dev_id
/// The identifier of the device.
///
/// @param port_id
/// Event port identifier to select the destination port to link.
///
/// @param queues
/// Points to an array of *nb_links* event queues to be linked
/// to the event port.
/// NULL value is allowed, in which case this function links all the configured
/// event queues *nb_event_queues* which previously supplied to
/// rte_event_dev_configure() to the event port *port_id*
///
/// @param priorities
/// Points to an array of *nb_links* service priorities associated with each
/// event queue link to event port.
/// The priority defines the event port's servicing priority for
/// event queue, which may be ignored by an implementation.
/// The requested priority should in the range of
/// [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST].
/// The implementation shall normalize the requested priority to
/// implementation supported priority value.
/// NULL value is allowed, in which case this function links the event queues
/// with RTE_EVENT_DEV_PRIORITY_NORMAL servicing priority
///
/// @param nb_links
/// The number of links to establish. This parameter is ignored if queues is
/// NULL.
///
/// @return
/// The number of links actually established. The return value can be less than
/// the value of the *nb_links* parameter when the implementation has the
/// limitation on specific queue to port link establishment or if invalid
/// parameters are specified in *queues*
/// If the return value is less than *nb_links*, the remaining links at the end
/// of link[] are not established, and the caller has to take care of them.
/// If return value is less than *nb_links* then implementation shall update the
/// rte_errno accordingly, Possible rte_errno values are
/// (-EDQUOT) Quota exceeded(Application tried to link the queue configured with
/// RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports)
/// (-EINVAL) Invalid parameter
///
    pub fn rte_event_port_link(dev_id: u8, port_id: u8, queues: *const u8,
                               priorities: *const u8, nb_links: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unlink multiple source event queues supplied in *queues* from the destination
/// event port designated by its *port_id* on the event device designated
/// by its *dev_id*.
///
/// The unlink establishment shall disable the event port *port_id* from
/// receiving events from the specified event queue *queue_id*
///
/// Event queue(s) to event port unlink establishment can be changed at runtime
/// without re-configuring the device.
///
/// @param dev_id
/// The identifier of the device.
///
/// @param port_id
/// Event port identifier to select the destination port to unlink.
///
/// @param queues
/// Points to an array of *nb_unlinks* event queues to be unlinked
/// from the event port.
/// NULL value is allowed, in which case this function unlinks all the
/// event queue(s) from the event port *port_id*.
///
/// @param nb_unlinks
/// The number of unlinks to establish. This parameter is ignored if queues is
/// NULL.
///
/// @return
/// The number of unlinks actually established. The return value can be less
/// than the value of the *nb_unlinks* parameter when the implementation has the
/// limitation on specific queue to port unlink establishment or
/// if invalid parameters are specified.
/// If the return value is less than *nb_unlinks*, the remaining queues at the
/// end of queues[] are not established, and the caller has to take care of them.
/// If return value is less than *nb_unlinks* then implementation shall update
/// the rte_errno accordingly, Possible rte_errno values are
/// (-EINVAL) Invalid parameter
///
    pub fn rte_event_port_unlink(dev_id: u8, port_id: u8, queues: *mut u8,
                                 nb_unlinks: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the list of source event queues and its associated service priority
/// linked to the destination event port designated by its *port_id*
/// on the event device designated by its *dev_id*.
///
/// @param dev_id
/// The identifier of the device.
///
/// @param port_id
/// Event port identifier.
///
/// @param[out] queues
/// Points to an array of *queues* for output.
/// The caller has to allocate *RTE_EVENT_MAX_QUEUES_PER_DEV* bytes to
/// store the event queue(s) linked with event port *port_id*
///
/// @param[out] priorities
/// Points to an array of *priorities* for output.
/// The caller has to allocate *RTE_EVENT_MAX_QUEUES_PER_DEV* bytes to
/// store the service priority associated with each event queue linked
///
/// @return
/// The number of links established on the event port designated by its
/// *port_id*.
/// - <0 on failure.
///
    pub fn rte_event_port_links_get(dev_id: u8, port_id: u8, queues: *mut u8,
                                    priorities: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump internal information about *dev_id* to the FILE* provided in *f*.
///
/// @param dev_id
/// The identifier of the device.
///
/// @param f
/// A pointer to a file for output
///
/// @return
/// - 0: on success
/// - <0: on failure.
    pub fn rte_event_dev_dump(dev_id: u8, f: *mut FILE)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// Selects the component of the eventdev to retrieve statistics from.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_event_dev_xstats_mode {
    RTE_EVENT_DEV_XSTATS_DEVICE = 0,
    RTE_EVENT_DEV_XSTATS_PORT = 1,
    RTE_EVENT_DEV_XSTATS_QUEUE = 2,
}
/// A name-key lookup element for extended statistics.
///
/// This structure is used to map between names and ID numbers
/// for extended ethdev statistics.
#[repr(C)]
pub struct rte_event_dev_xstats_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_event_dev_xstats_name() {
    assert_eq!(::std::mem::size_of::<rte_event_dev_xstats_name>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_event_dev_xstats_name ) ));
    assert_eq! (::std::mem::align_of::<rte_event_dev_xstats_name>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_event_dev_xstats_name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_dev_xstats_name ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_event_dev_xstats_name ) , "::" , stringify ! ( name ) ));
}
extern "C" {
    /// Retrieve names of extended statistics of an event device.
///
/// @param dev_id
/// The identifier of the event device.
/// @param mode
/// The mode of statistics to retrieve. Choices include the device statistics,
/// port statistics or queue statistics.
/// @param queue_port_id
/// Used to specify the port or queue number in queue or port mode, and is
/// ignored in device mode.
/// @param[out] xstats_names
/// Block of memory to insert names into. Must be at least size in capacity.
/// If set to NULL, function returns required capacity.
/// @param[out] ids
/// Block of memory to insert ids into. Must be at least size in capacity.
/// If set to NULL, function returns required capacity. The id values returned
/// can be passed to *rte_event_dev_xstats_get* to select statistics.
/// @param size
/// Capacity of xstats_names (number of names).
/// @return
/// - positive value lower or equal to size: success. The return value
/// is the number of entries filled in the stats table.
/// - positive value higher than size: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// - negative value on error:
/// -ENODEV for invalid *dev_id*
/// -EINVAL for invalid mode, queue port or id parameters
/// -ENOTSUP if the device doesn't support this function.
    pub fn rte_event_dev_xstats_names_get(dev_id: u8,
                                          mode: rte_event_dev_xstats_mode,
                                          queue_port_id: u8,
                                          xstats_names:
                                              *mut rte_event_dev_xstats_name,
                                          ids: *mut ::std::os::raw::c_uint,
                                          size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve extended statistics of an event device.
///
/// @param dev_id
/// The identifier of the device.
/// @param mode
/// The mode of statistics to retrieve. Choices include the device statistics,
/// port statistics or queue statistics.
/// @param queue_port_id
/// Used to specify the port or queue number in queue or port mode, and is
/// ignored in device mode.
/// @param ids
/// The id numbers of the stats to get. The ids can be got from the stat
/// position in the stat list from rte_event_dev_get_xstats_names(), or
/// by using rte_eventdev_get_xstats_by_name()
/// @param[out] values
/// The values for each stats request by ID.
/// @param n
/// The number of stats requested
/// @return
/// - positive value: number of stat entries filled into the values array
/// - negative value on error:
/// -ENODEV for invalid *dev_id*
/// -EINVAL for invalid mode, queue port or id parameters
/// -ENOTSUP if the device doesn't support this function.
    pub fn rte_event_dev_xstats_get(dev_id: u8,
                                    mode: rte_event_dev_xstats_mode,
                                    queue_port_id: u8,
                                    ids: *const ::std::os::raw::c_uint,
                                    values: *mut u64,
                                    n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the value of a single stat by requesting it by name.
///
/// @param dev_id
/// The identifier of the device
/// @param name
/// The stat name to retrieve
/// @param[out] id
/// If non-NULL, the numerical id of the stat will be returned, so that further
/// requests for the stat can be got using rte_eventdev_xstats_get, which will
/// be faster as it doesn't need to scan a list of names for the stat.
/// If the stat cannot be found, the id returned will be (unsigned)-1.
/// @return
/// - positive value or zero: the stat value
/// - negative value: -EINVAL if stat not found, -ENOTSUP if not supported.
    pub fn rte_event_dev_xstats_by_name_get(dev_id: u8,
                                            name:
                                                *const ::std::os::raw::c_char,
                                            id: *mut ::std::os::raw::c_uint)
     -> u64;
}
extern "C" {
    /// Reset the values of the xstats of the selected component in the device.
///
/// @param dev_id
/// The identifier of the device
/// @param mode
/// The mode of the statistics to reset. Choose from device, queue or port.
/// @param queue_port_id
/// The queue or port to reset. 0 and positive values select ports and queues,
/// while -1 indicates all ports or queues.
/// @param ids
/// Selects specific statistics to be reset. When NULL, all statistics selected
/// by *mode* will be reset. If non-NULL, must point to array of at least
/// *nb_ids* size.
/// @param nb_ids
/// The number of ids available from the *ids* array. Ignored when ids is NULL.
/// @return
/// - zero: successfully reset the statistics to zero
/// - negative value: -EINVAL invalid parameters, -ENOTSUP if not supported.
    pub fn rte_event_dev_xstats_reset(dev_id: u8,
                                      mode: rte_event_dev_xstats_mode,
                                      queue_port_id: i16, ids: *const u32,
                                      nb_ids: u32) -> ::std::os::raw::c_int;
}
/// Global structure used for maintaining state of allocated event devices
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eventdev_global {
    /// < Number of devices found
    pub nb_devs: u8,
}
#[test]
fn bindgen_test_layout_rte_eventdev_global() {
    assert_eq!(::std::mem::size_of::<rte_eventdev_global>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( rte_eventdev_global ) ));
    assert_eq! (::std::mem::align_of::<rte_eventdev_global>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_eventdev_global ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eventdev_global ) ) . nb_devs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_eventdev_global ) ,
                "::" , stringify ! ( nb_devs ) ));
}
impl Clone for rte_eventdev_global {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_eventdev_globals"]
    pub static mut rte_eventdev_globals: *mut rte_eventdev_global;
}
/// Get device information of a device.
///
/// @param dev
/// Event device pointer
/// @param dev_info
/// Event device information structure
///
/// @return
/// Returns 0 on success
pub type eventdev_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               dev_info:
                                                   *mut rte_event_dev_info)>;
/// Configure a device.
///
/// @param dev
/// Event device pointer
///
/// @return
/// Returns 0 on success
pub type eventdev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *const rte_eventdev)
                              -> ::std::os::raw::c_int>;
/// Start a configured device.
///
/// @param dev
/// Event device pointer
///
/// @return
/// Returns 0 on success
pub type eventdev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev)
                              -> ::std::os::raw::c_int>;
/// Stop a configured device.
///
/// @param dev
/// Event device pointer
pub type eventdev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev)>;
/// Close a configured device.
///
/// @param dev
/// Event device pointer
///
/// @return
/// - 0 on success
/// - (-EAGAIN) if can't close as device is busy
pub type eventdev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev)
                              -> ::std::os::raw::c_int>;
/// Retrieve the default event queue configuration.
///
/// @param dev
/// Event device pointer
/// @param queue_id
/// Event queue index
/// @param[out] queue_conf
/// Event queue configuration structure
///
pub type eventdev_queue_default_conf_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               queue_id: u8,
                                               queue_conf:
                                                   *mut rte_event_queue_conf)>;
/// Setup an event queue.
///
/// @param dev
/// Event device pointer
/// @param queue_id
/// Event queue index
/// @param queue_conf
/// Event queue configuration structure
///
/// @return
/// Returns 0 on success.
pub type eventdev_queue_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               queue_id: u8,
                                               queue_conf:
                                                   *const rte_event_queue_conf)
                              -> ::std::os::raw::c_int>;
/// Release resources allocated by given event queue.
///
/// @param dev
/// Event device pointer
/// @param queue_id
/// Event queue index
///
pub type eventdev_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               queue_id: u8)>;
/// Retrieve the default event port configuration.
///
/// @param dev
/// Event device pointer
/// @param port_id
/// Event port index
/// @param[out] port_conf
/// Event port configuration structure
///
pub type eventdev_port_default_conf_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               port_id: u8,
                                               port_conf:
                                                   *mut rte_event_port_conf)>;
/// Setup an event port.
///
/// @param dev
/// Event device pointer
/// @param port_id
/// Event port index
/// @param port_conf
/// Event port configuration structure
///
/// @return
/// Returns 0 on success.
pub type eventdev_port_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               port_id: u8,
                                               port_conf:
                                                   *const rte_event_port_conf)
                              -> ::std::os::raw::c_int>;
/// Release memory resources allocated by given event port.
///
/// @param port
/// Event port pointer
///
pub type eventdev_port_release_t =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)>;
/// Link multiple source event queues to destination event port.
///
/// @param dev
/// Event device pointer
/// @param port
/// Event port pointer
/// @param link
/// Points to an array of *nb_links* event queues to be linked
/// to the event port.
/// @param priorities
/// Points to an array of *nb_links* service priorities associated with each
/// event queue link to event port.
/// @param nb_links
/// The number of links to establish
///
/// @return
/// Returns 0 on success.
///
pub type eventdev_port_link_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               port:
                                                   *mut ::std::os::raw::c_void,
                                               queues: *const u8,
                                               priorities: *const u8,
                                               nb_links: u16)
                              -> ::std::os::raw::c_int>;
/// Unlink multiple source event queues from destination event port.
///
/// @param dev
/// Event device pointer
/// @param port
/// Event port pointer
/// @param queues
/// An array of *nb_unlinks* event queues to be unlinked from the event port.
/// @param nb_unlinks
/// The number of unlinks to establish
///
/// @return
/// Returns 0 on success.
///
pub type eventdev_port_unlink_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               port:
                                                   *mut ::std::os::raw::c_void,
                                               queues: *mut u8,
                                               nb_unlinks: u16)
                              -> ::std::os::raw::c_int>;
/// Converts nanoseconds to *timeout_ticks* value for rte_event_dequeue()
///
/// @param dev
/// Event device pointer
/// @param ns
/// Wait time in nanosecond
/// @param[out] timeout_ticks
/// Value for the *timeout_ticks* parameter in rte_event_dequeue() function
///
/// @return
/// Returns 0 on success.
///
pub type eventdev_dequeue_timeout_ticks_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               ns: u64,
                                               timeout_ticks: *mut u64)
                              -> ::std::os::raw::c_int>;
/// Dump internal information
///
/// @param dev
/// Event device pointer
/// @param f
/// A pointer to a file for output
///
pub type eventdev_dump_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               f: *mut FILE)>;
/// Retrieve a set of statistics from device
///
/// @param dev
/// Event device pointer
/// @param ids
/// The stat ids to retrieve
/// @param values
/// The returned stat values
/// @param n
/// The number of id values and entries in the values array
/// @return
/// The number of stat values successfully filled into the values array
pub type eventdev_xstats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *const rte_eventdev,
                                               mode:
                                                   rte_event_dev_xstats_mode,
                                               queue_port_id: u8,
                                               ids:
                                                   *const ::std::os::raw::c_uint,
                                               values: *mut u64,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/// Resets the statistic values in xstats for the device, based on mode.
pub type eventdev_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev,
                                               mode:
                                                   rte_event_dev_xstats_mode,
                                               queue_port_id: i16,
                                               ids: *const u32, nb_ids: u32)
                              -> ::std::os::raw::c_int>;
/// Get names of extended stats of an event device
///
/// @param dev
/// Event device pointer
/// @param xstats_names
/// Array of name values to be filled in
/// @param size
/// Number of values in the xstats_names array
/// @return
/// When size >= the number of stats, return the number of stat values filled
/// into the array.
/// When size < the number of available stats, return the number of stats
/// values, and do not fill in any data into xstats_names.
pub type eventdev_xstats_get_names_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *const rte_eventdev,
                                               mode:
                                                   rte_event_dev_xstats_mode,
                                               queue_port_id: u8,
                                               xstats_names:
                                                   *mut rte_event_dev_xstats_name,
                                               ids:
                                                   *mut ::std::os::raw::c_uint,
                                               size: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/// Get value of one stats and optionally return its id
///
/// @param dev
/// Event device pointer
/// @param name
/// The name of the stat to retrieve
/// @param id
/// Pointer to an unsigned int where we store the stat-id for future reference.
/// This pointer may be null if the id is not required.
/// @return
/// The value of the stat, or (uint64_t)-1 if the stat is not found.
/// If the stat is not found, the id value will be returned as (unsigned)-1,
/// if id pointer is non-NULL
pub type eventdev_xstats_get_by_name =
    ::std::option::Option<unsafe extern "C" fn(dev: *const rte_eventdev,
                                               name:
                                                   *const ::std::os::raw::c_char,
                                               id:
                                                   *mut ::std::os::raw::c_uint)
                              -> u64>;
extern "C" {
    /// Allocates a new eventdev slot for an event device and returns the pointer
/// to that slot for the driver to use.
///
/// @param name
/// Unique identifier name for each device
/// @param socket_id
/// Socket to allocate resources on.
/// @return
/// - Slot in the rte_dev_devices array for a new device;
    pub fn rte_event_pmd_allocate(name: *const ::std::os::raw::c_char,
                                  socket_id: ::std::os::raw::c_int)
     -> *mut rte_eventdev;
}
extern "C" {
    /// Release the specified eventdev device.
///
/// @param eventdev
/// The *eventdev* pointer is the address of the *rte_eventdev* structure.
/// @return
/// - 0 on success, negative on error
    pub fn rte_event_pmd_release(eventdev: *mut rte_eventdev)
     -> ::std::os::raw::c_int;
}
pub type eventdev_pmd_pci_callback_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eventdev)
                              -> ::std::os::raw::c_int>;
/// Generic ring structure for passing rte_event objects from core to core.
///
/// Based on the primitives given in the rte_ring library. Designed to be
/// used inside software eventdev implementations and by applications
/// directly as needed.
#[repr(C)]
#[derive(Copy)]
pub struct rte_event_ring {
    pub r: rte_ring,
}
#[test]
fn bindgen_test_layout_rte_event_ring() {
    assert_eq!(::std::mem::size_of::<rte_event_ring>() , 384usize , concat ! (
               "Size of: " , stringify ! ( rte_event_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_event_ring ) ) . r as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_event_ring ) , "::"
                , stringify ! ( r ) ));
}
impl Clone for rte_event_ring {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rte_event_ring_init(r: *mut rte_event_ring,
                               name: *const ::std::os::raw::c_char,
                               count: ::std::os::raw::c_uint,
                               flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_event_ring_create(name: *const ::std::os::raw::c_char,
                                 count: ::std::os::raw::c_uint,
                                 socket_id: ::std::os::raw::c_int,
                                 flags: ::std::os::raw::c_uint)
     -> *mut rte_event_ring;
}
extern "C" {
    /// Search for an event ring based on its name
///
/// @param name
/// The name of the ring.
/// @return
/// The pointer to the ring matching the name, or NULL if not found,
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
    pub fn rte_event_ring_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_event_ring;
}
extern "C" {
    /// De-allocate all memory used by the ring.
///
/// @param r
/// Ring to free
    pub fn rte_event_ring_free(r: *mut rte_event_ring);
}
extern "C" {
    #[link_name = "crc32c_tables"]
    pub static mut crc32c_tables: [[u32; 256usize]; 8usize];
}
extern "C" {
    #[link_name = "crc32_alg"]
    pub static mut crc32_alg: u8;
}
/// Type of function that can be used for calculating the hash value.
pub type rte_fbk_hash_fn =
    ::std::option::Option<unsafe extern "C" fn(key: u32, init_val: u32)
                              -> u32>;
/// Parameters used when creating four-byte key hash table.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fbk_hash_params {
    /// < Name of the hash table.
    pub name: *const ::std::os::raw::c_char,
    /// < Total number of entries.
    pub entries: u32,
    /// < Number of entries in a bucket.
    pub entries_per_bucket: u32,
    /// < Socket to allocate memory on.
    pub socket_id: ::std::os::raw::c_int,
    /// < The hash function.
    pub hash_func: rte_fbk_hash_fn,
    /// < For initialising hash function.
    pub init_val: u32,
}
#[test]
fn bindgen_test_layout_rte_fbk_hash_params() {
    assert_eq!(::std::mem::size_of::<rte_fbk_hash_params>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( rte_fbk_hash_params ) ));
    assert_eq! (::std::mem::align_of::<rte_fbk_hash_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_fbk_hash_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) . entries as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) .
                entries_per_bucket as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( entries_per_bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) . socket_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) . hash_func as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( hash_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_params ) ) . init_val as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_params ) ,
                "::" , stringify ! ( init_val ) ));
}
impl Clone for rte_fbk_hash_params {
    fn clone(&self) -> Self { *self }
}
/// Individual entry in the four-byte key hash table.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fbk_hash_entry {
    /// < For accessing entire entry.
    pub whole_entry: __BindgenUnionField<u64>,
    /// < For accessing each entry part.
    pub entry: __BindgenUnionField<rte_fbk_hash_entry__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fbk_hash_entry__bindgen_ty_1 {
    /// < Non-zero if entry is active.
    pub is_entry: u16,
    /// < Value returned by lookup.
    pub value: u16,
    /// < Key used to find value.
    pub key: u32,
}
#[test]
fn bindgen_test_layout_rte_fbk_hash_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_fbk_hash_entry__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( rte_fbk_hash_entry__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_fbk_hash_entry__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_fbk_hash_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_entry__bindgen_ty_1 ) ) .
                is_entry as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_fbk_hash_entry__bindgen_ty_1 ) , "::" , stringify ! (
                is_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_entry__bindgen_ty_1 ) ) .
                value as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_fbk_hash_entry__bindgen_ty_1 ) , "::" , stringify ! (
                value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_entry__bindgen_ty_1 ) ) .
                key as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_fbk_hash_entry__bindgen_ty_1 ) , "::" , stringify ! ( key
                ) ));
}
impl Clone for rte_fbk_hash_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_fbk_hash_entry() {
    assert_eq!(::std::mem::size_of::<rte_fbk_hash_entry>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_fbk_hash_entry ) ));
    assert_eq! (::std::mem::align_of::<rte_fbk_hash_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_fbk_hash_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_entry ) ) . whole_entry as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_entry ) ,
                "::" , stringify ! ( whole_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fbk_hash_entry ) ) . entry as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_fbk_hash_entry ) ,
                "::" , stringify ! ( entry ) ));
}
impl Clone for rte_fbk_hash_entry {
    fn clone(&self) -> Self { *self }
}
/// The four-byte key hash table structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fbk_hash_table {
    /// < Name of the hash.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Total number of entries.
    pub entries: u32,
    /// < Number of entries in a bucket.
    pub entries_per_bucket: u32,
    /// < How many entries are used.
    pub used_entries: u32,
    /// < To find which bucket the key is in.
    pub bucket_mask: u32,
    /// < Convert bucket to table offset.
    pub bucket_shift: u32,
    /// < The hash function.
    pub hash_func: rte_fbk_hash_fn,
    /// < For initialising hash function.
    pub init_val: u32,
    /// A flat table of all buckets.
    pub t: __IncompleteArrayField<rte_fbk_hash_entry>,
}
#[test]
fn bindgen_test_layout_rte_fbk_hash_table() {
    assert_eq!(::std::mem::size_of::<rte_fbk_hash_table>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( rte_fbk_hash_table ) ));
    assert_eq! (::std::mem::align_of::<rte_fbk_hash_table>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_fbk_hash_table ) ));
}
impl Clone for rte_fbk_hash_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Performs a lookup for an existing hash table, and returns a pointer to
/// the table if found.
///
/// @param name
/// Name of the hash table to find
///
/// @return
/// pointer to hash table structure or NULL on error with rte_errno
/// set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
    pub fn rte_fbk_hash_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_fbk_hash_table;
}
extern "C" {
    /// Create a new hash table for use with four byte keys.
///
/// @param params
/// Parameters used in creation of hash table.
///
/// @return
/// Pointer to hash table structure that is used in future hash table
/// operations, or NULL on error with rte_errno set appropriately.
/// Possible rte_errno error values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - invalid parameter value passed to function
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_fbk_hash_create(params: *const rte_fbk_hash_params)
     -> *mut rte_fbk_hash_table;
}
extern "C" {
    /// Free all memory used by a hash table.
/// Has no effect on hash tables allocated in memory zones
///
/// @param ht
/// Hash table to deallocate.
    pub fn rte_fbk_hash_free(ht: *mut rte_fbk_hash_table);
}
/// ICMP Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: u16,
    pub icmp_ident: u16,
    pub icmp_seq_nb: u16,
}
#[test]
fn bindgen_test_layout_icmp_hdr() {
    assert_eq!(::std::mem::size_of::<icmp_hdr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( icmp_hdr ) ));
    assert_eq! (::std::mem::align_of::<icmp_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( icmp_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( icmp_hdr ) , "::" ,
                stringify ! ( icmp_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_code as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( icmp_hdr ) , "::" ,
                stringify ! ( icmp_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_cksum as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( icmp_hdr ) , "::" ,
                stringify ! ( icmp_cksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_ident as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( icmp_hdr ) , "::" ,
                stringify ! ( icmp_ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_seq_nb as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( icmp_hdr ) , "::" ,
                stringify ! ( icmp_seq_nb ) ));
}
impl Clone for icmp_hdr {
    fn clone(&self) -> Self { *self }
}
/// IPv4 Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv4_hdr {
    /// < version and header length
    pub version_ihl: u8,
    /// < type of service
    pub type_of_service: u8,
    /// < length of packet
    pub total_length: u16,
    /// < packet ID
    pub packet_id: u16,
    /// < fragmentation offset
    pub fragment_offset: u16,
    /// < time to live
    pub time_to_live: u8,
    /// < protocol ID
    pub next_proto_id: u8,
    /// < header checksum
    pub hdr_checksum: u16,
    /// < source address
    pub src_addr: u32,
    /// < destination address
    pub dst_addr: u32,
}
#[test]
fn bindgen_test_layout_ipv4_hdr() {
    assert_eq!(::std::mem::size_of::<ipv4_hdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv4_hdr ) ));
    assert_eq! (::std::mem::align_of::<ipv4_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ipv4_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . version_ihl as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( version_ihl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . type_of_service as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( type_of_service ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . total_length as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( total_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . packet_id as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( packet_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . fragment_offset as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( fragment_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . time_to_live as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( time_to_live ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . next_proto_id as * const _
                as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( next_proto_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . hdr_checksum as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( hdr_checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . src_addr as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( src_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . dst_addr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv4_hdr ) , "::" ,
                stringify ! ( dst_addr ) ));
}
impl Clone for ipv4_hdr {
    fn clone(&self) -> Self { *self }
}
/// IPv6 Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv6_hdr {
    /// < IP version, traffic class & flow label.
    pub vtc_flow: u32,
    /// < IP packet length - includes sizeof(ip_header).
    pub payload_len: u16,
    /// < Protocol, next header.
    pub proto: u8,
    /// < Hop limits.
    pub hop_limits: u8,
    /// < IP address of source host.
    pub src_addr: [u8; 16usize],
    /// < IP address of destination host(s).
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ipv6_hdr() {
    assert_eq!(::std::mem::size_of::<ipv6_hdr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ipv6_hdr ) ));
    assert_eq! (::std::mem::align_of::<ipv6_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . vtc_flow as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( vtc_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . payload_len as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( payload_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . proto as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . hop_limits as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( hop_limits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . src_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( src_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . dst_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_hdr ) , "::" ,
                stringify ! ( dst_addr ) ));
}
impl Clone for ipv6_hdr {
    fn clone(&self) -> Self { *self }
}
/// SCTP Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct sctp_hdr {
    /// < Source port.
    pub src_port: u16,
    /// < Destin port.
    pub dst_port: u16,
    /// < Validation tag.
    pub tag: u32,
    /// < Checksum.
    pub cksum: u32,
}
#[test]
fn bindgen_test_layout_sctp_hdr() {
    assert_eq!(::std::mem::size_of::<sctp_hdr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( sctp_hdr ) ));
    assert_eq! (::std::mem::align_of::<sctp_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( sctp_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . src_port as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sctp_hdr ) , "::" ,
                stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sctp_hdr ) , "::" ,
                stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . tag as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sctp_hdr ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . cksum as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sctp_hdr ) , "::" ,
                stringify ! ( cksum ) ));
}
impl Clone for sctp_hdr {
    fn clone(&self) -> Self { *self }
}
/// TCP Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct tcp_hdr {
    /// < TCP source port.
    pub src_port: u16,
    /// < TCP destination port.
    pub dst_port: u16,
    /// < TX data sequence number.
    pub sent_seq: u32,
    /// < RX data acknowledgement sequence number.
    pub recv_ack: u32,
    /// < Data offset.
    pub data_off: u8,
    /// < TCP flags
    pub tcp_flags: u8,
    /// < RX flow control window.
    pub rx_win: u16,
    /// < TCP checksum.
    pub cksum: u16,
    /// < TCP urgent pointer, if any.
    pub tcp_urp: u16,
}
#[test]
fn bindgen_test_layout_tcp_hdr() {
    assert_eq!(::std::mem::size_of::<tcp_hdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tcp_hdr ) ));
    assert_eq! (::std::mem::align_of::<tcp_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tcp_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . src_port as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . sent_seq as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( sent_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . recv_ack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( recv_ack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . data_off as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . tcp_flags as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( tcp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . rx_win as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( rx_win ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . cksum as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( cksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . tcp_urp as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_hdr ) , "::" ,
                stringify ! ( tcp_urp ) ));
}
impl Clone for tcp_hdr {
    fn clone(&self) -> Self { *self }
}
/// UDP Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct udp_hdr {
    /// < UDP source port.
    pub src_port: u16,
    /// < UDP destination port.
    pub dst_port: u16,
    /// < UDP datagram length
    pub dgram_len: u16,
    /// < UDP datagram checksum
    pub dgram_cksum: u16,
}
#[test]
fn bindgen_test_layout_udp_hdr() {
    assert_eq!(::std::mem::size_of::<udp_hdr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( udp_hdr ) ));
    assert_eq! (::std::mem::align_of::<udp_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( udp_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . src_port as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udp_hdr ) , "::" ,
                stringify ! ( src_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( udp_hdr ) , "::" ,
                stringify ! ( dst_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dgram_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( udp_hdr ) , "::" ,
                stringify ! ( dgram_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dgram_cksum as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( udp_hdr ) , "::" ,
                stringify ! ( dgram_cksum ) ));
}
impl Clone for udp_hdr {
    fn clone(&self) -> Self { *self }
}
/// Flow rule attributes.
///
/// Priorities are set on two levels: per group and per rule within groups.
///
/// Lower values denote higher priority, the highest priority for both levels
/// is 0, so that a rule with priority 0 in group 8 is always matched after a
/// rule with priority 8 in group 0.
///
/// Although optional, applications are encouraged to group similar rules as
/// much as possible to fully take advantage of hardware capabilities
/// (e.g. optimized matching) and work around limitations (e.g. a single
/// pattern type possibly allowed in a given group).
///
/// Group and priority levels are arbitrary and up to the application, they
/// do not need to be contiguous nor start from 0, however the maximum number
/// varies between devices and may be affected by existing flow rules.
///
/// If a packet is matched by several rules of a given group for a given
/// priority level, the outcome is undefined. It can take any path, may be
/// duplicated or even cause unrecoverable errors.
///
/// Note that support for more than a single group and priority level is not
/// guaranteed.
///
/// Flow rules can apply to inbound and/or outbound traffic (ingress/egress).
///
/// Several pattern items and actions are valid and can be used in both
/// directions. Those valid for only one direction are described as such.
///
/// At least one direction must be specified.
///
/// Specifying both directions at once for a given rule is not recommended
/// but may be valid in a few cases (e.g. shared counter).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_attr {
    /// < Priority group.
    pub group: u32,
    /// < Priority level within group.
    pub priority: u32,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_attr() {
    assert_eq!(::std::mem::size_of::<rte_flow_attr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_attr ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_attr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_flow_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_attr ) ) . group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_attr ) , "::"
                , stringify ! ( group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_attr ) ) . priority as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_attr ) , "::"
                , stringify ! ( priority ) ));
}
impl Clone for rte_flow_attr {
    fn clone(&self) -> Self { *self }
}
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ingress: u32, egress: u32, reserved: u32) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((ingress as u32 as u32) << 0usize) & (1u64 as u32))
              } | ((egress as u32 as u32) << 1usize) & (2u64 as u32))
         } | ((reserved as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
#[repr(u32)]
/// Matching pattern item types.
///
/// Pattern items fall in two categories:
///
/// - Matching protocol headers and packet data (ANY, RAW, ETH, VLAN, IPV4,
/// IPV6, ICMP, UDP, TCP, SCTP, VXLAN and so on), usually associated with a
/// specification structure. These must be stacked in the same order as the
/// protocol layers to match, starting from the lowest.
///
/// - Matching meta-data or affecting pattern processing (END, VOID, INVERT,
/// PF, VF, PORT and so on), often without a specification structure. Since
/// they do not match packet contents, these can be specified anywhere
/// within item lists without affecting others.
///
/// See the description of individual types for more information. Those
/// marked with [META] fall into the second category.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_flow_item_type {
    RTE_FLOW_ITEM_TYPE_END = 0,
    RTE_FLOW_ITEM_TYPE_VOID = 1,
    RTE_FLOW_ITEM_TYPE_INVERT = 2,
    RTE_FLOW_ITEM_TYPE_ANY = 3,
    RTE_FLOW_ITEM_TYPE_PF = 4,
    RTE_FLOW_ITEM_TYPE_VF = 5,
    RTE_FLOW_ITEM_TYPE_PORT = 6,
    RTE_FLOW_ITEM_TYPE_RAW = 7,
    RTE_FLOW_ITEM_TYPE_ETH = 8,
    RTE_FLOW_ITEM_TYPE_VLAN = 9,
    RTE_FLOW_ITEM_TYPE_IPV4 = 10,
    RTE_FLOW_ITEM_TYPE_IPV6 = 11,
    RTE_FLOW_ITEM_TYPE_ICMP = 12,
    RTE_FLOW_ITEM_TYPE_UDP = 13,
    RTE_FLOW_ITEM_TYPE_TCP = 14,
    RTE_FLOW_ITEM_TYPE_SCTP = 15,
    RTE_FLOW_ITEM_TYPE_VXLAN = 16,
    RTE_FLOW_ITEM_TYPE_E_TAG = 17,
    RTE_FLOW_ITEM_TYPE_NVGRE = 18,
    RTE_FLOW_ITEM_TYPE_MPLS = 19,
    RTE_FLOW_ITEM_TYPE_GRE = 20,
    RTE_FLOW_ITEM_TYPE_FUZZY = 21,
}
/// RTE_FLOW_ITEM_TYPE_ANY
///
/// Matches any protocol in place of the current layer, a single ANY may also
/// stand for several protocol layers.
///
/// This is usually specified as the first pattern item when looking for a
/// protocol anywhere in a packet.
///
/// A zeroed mask stands for any number of layers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_any {
    /// < Number of layers covered.
    pub num: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_any() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_any>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_any ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_any>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_any ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_any ) ) . num as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_any ) ,
                "::" , stringify ! ( num ) ));
}
impl Clone for rte_flow_item_any {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_any_mask"]
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
/// RTE_FLOW_ITEM_TYPE_VF
///
/// Matches packets addressed to a virtual function ID of the device.
///
/// If the underlying device function differs from the one that would
/// normally receive the matched traffic, specifying this item prevents it
/// from reaching that device unless the flow rule contains a VF
/// action. Packets are not duplicated between device instances by default.
///
/// - Likely to return an error or never match any traffic if this causes a
/// VF device to match traffic addressed to a different VF.
/// - Can be specified multiple times to match traffic addressed to several
/// VF IDs.
/// - Can be combined with a PF item to match both PF and VF traffic.
///
/// A zeroed mask can be used to match any VF ID.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_vf {
    /// < Destination VF ID.
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vf() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_vf>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_item_vf ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_vf>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_flow_item_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vf ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vf ) ,
                "::" , stringify ! ( id ) ));
}
impl Clone for rte_flow_item_vf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_vf_mask"]
    pub static rte_flow_item_vf_mask: rte_flow_item_vf;
}
/// RTE_FLOW_ITEM_TYPE_PORT
///
/// Matches packets coming from the specified physical port of the underlying
/// device.
///
/// The first PORT item overrides the physical port normally associated with
/// the specified DPDK input port (port_id). This item can be provided
/// several times to match additional physical ports.
///
/// Note that physical ports are not necessarily tied to DPDK input ports
/// (port_id) when those are not under DPDK control. Possible values are
/// specific to each device, they are not necessarily indexed from zero and
/// may not be contiguous.
///
/// As a device property, the list of allowed values as well as the value
/// associated with a port_id should be retrieved by other means.
///
/// A zeroed mask can be used to match any port index.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_port {
    /// < Physical port index.
    pub index: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_port() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_port>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_port ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_port>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_port ) ) . index as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_port ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for rte_flow_item_port {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_port_mask"]
    pub static rte_flow_item_port_mask: rte_flow_item_port;
}
/// RTE_FLOW_ITEM_TYPE_RAW
///
/// Matches a byte string of a given length at a given offset.
///
/// Offset is either absolute (using the start of the packet) or relative to
/// the end of the previous matched item in the stack, in which case negative
/// values are allowed.
///
/// If search is enabled, offset is used as the starting point. The search
/// area can be delimited by setting limit to a nonzero value, which is the
/// maximum number of bytes after offset where the pattern may start.
///
/// Matching a zero-length pattern is allowed, doing so resets the relative
/// offset for subsequent items.
///
/// This type does not support ranges (struct rte_flow_item.last).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_raw {
    pub _bitfield_1: u32,
    /// < Absolute or relative offset for pattern.
    pub offset: i32,
    /// < Search area limit for start of pattern.
    pub limit: u16,
    /// < Pattern length.
    pub length: u16,
    /// < Byte string to look for.
    pub pattern: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_flow_item_raw() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_raw>() , 12usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_raw ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_raw>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_raw ) ));
}
impl Clone for rte_flow_item_raw {
    fn clone(&self) -> Self { *self }
}
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(relative: u32, search: u32, reserved: u32) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((relative as u32 as u32) << 0usize) & (1u64 as u32))
              } | ((search as u32 as u32) << 1usize) & (2u64 as u32))
         } | ((reserved as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
extern "C" {
    #[link_name = "rte_flow_item_raw_mask"]
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
/// RTE_FLOW_ITEM_TYPE_ETH
///
/// Matches an Ethernet header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_eth {
    /// < Destination MAC.
    pub dst: ether_addr,
    /// < Source MAC.
    pub src: ether_addr,
    /// < EtherType.
    pub type_: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_eth() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_eth>() , 14usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_eth ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_eth>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_eth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_eth ) ) . dst as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_eth ) ,
                "::" , stringify ! ( dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_eth ) ) . src as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_eth ) ,
                "::" , stringify ! ( src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_eth ) ) . type_ as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_eth ) ,
                "::" , stringify ! ( type_ ) ));
}
impl Clone for rte_flow_item_eth {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_eth_mask"]
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
/// RTE_FLOW_ITEM_TYPE_VLAN
///
/// Matches an 802.1Q/ad VLAN tag.
///
/// This type normally follows either RTE_FLOW_ITEM_TYPE_ETH or
/// RTE_FLOW_ITEM_TYPE_VLAN.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_vlan {
    /// < Tag protocol identifier.
    pub tpid: rte_be16_t,
    /// < Tag control information.
    pub tci: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vlan() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_vlan>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_vlan ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_vlan>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_vlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vlan ) ) . tpid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vlan ) ,
                "::" , stringify ! ( tpid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vlan ) ) . tci as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vlan ) ,
                "::" , stringify ! ( tci ) ));
}
impl Clone for rte_flow_item_vlan {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_vlan_mask"]
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
/// RTE_FLOW_ITEM_TYPE_IPV4
///
/// Matches an IPv4 header.
///
/// Note: IPv4 options are handled by dedicated pattern items.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_ipv4 {
    /// < IPv4 header definition.
    pub hdr: ipv4_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv4() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_ipv4>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_ipv4 ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_ipv4>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_ipv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_ipv4 ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_ipv4 ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_ipv4 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_ipv4_mask"]
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
/// RTE_FLOW_ITEM_TYPE_IPV6.
///
/// Matches an IPv6 header.
///
/// Note: IPv6 options are handled by dedicated pattern items.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_ipv6 {
    /// < IPv6 header definition.
    pub hdr: ipv6_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_ipv6() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_ipv6>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_ipv6 ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_ipv6>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_ipv6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_ipv6 ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_ipv6 ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_ipv6 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_ipv6_mask"]
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
/// RTE_FLOW_ITEM_TYPE_ICMP.
///
/// Matches an ICMP header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_icmp {
    /// < ICMP header definition.
    pub hdr: icmp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_icmp() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_icmp>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_icmp ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_icmp>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_icmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_icmp ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_icmp ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_icmp {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_icmp_mask"]
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
/// RTE_FLOW_ITEM_TYPE_UDP.
///
/// Matches a UDP header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_udp {
    /// < UDP header definition.
    pub hdr: udp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_udp() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_udp>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_udp ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_udp>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_udp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_udp ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_udp ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_udp {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_udp_mask"]
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
/// RTE_FLOW_ITEM_TYPE_TCP.
///
/// Matches a TCP header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_tcp {
    /// < TCP header definition.
    pub hdr: tcp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_tcp() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_tcp>() , 20usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_tcp ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_tcp>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_tcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_tcp ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_tcp ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_tcp {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_tcp_mask"]
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
/// RTE_FLOW_ITEM_TYPE_SCTP.
///
/// Matches a SCTP header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_sctp {
    /// < SCTP header definition.
    pub hdr: sctp_hdr,
}
#[test]
fn bindgen_test_layout_rte_flow_item_sctp() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_sctp>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_sctp ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_sctp>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_sctp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_sctp ) ) . hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_sctp ) ,
                "::" , stringify ! ( hdr ) ));
}
impl Clone for rte_flow_item_sctp {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_sctp_mask"]
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
/// RTE_FLOW_ITEM_TYPE_VXLAN.
///
/// Matches a VXLAN header (RFC 7348).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_vxlan {
    /// < Normally 0x08 (I flag).
    pub flags: u8,
    /// < Reserved, normally 0x000000.
    pub rsvd0: [u8; 3usize],
    /// < VXLAN identifier.
    pub vni: [u8; 3usize],
    /// < Reserved, normally 0x00.
    pub rsvd1: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_vxlan() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_vxlan>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_vxlan ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_vxlan>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_item_vxlan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vxlan ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vxlan ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vxlan ) ) . rsvd0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vxlan ) ,
                "::" , stringify ! ( rsvd0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vxlan ) ) . vni as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vxlan ) ,
                "::" , stringify ! ( vni ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_vxlan ) ) . rsvd1 as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_vxlan ) ,
                "::" , stringify ! ( rsvd1 ) ));
}
impl Clone for rte_flow_item_vxlan {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_vxlan_mask"]
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
/// RTE_FLOW_ITEM_TYPE_E_TAG.
///
/// Matches a E-tag header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_e_tag {
    /// < Tag protocol identifier (0x893F).
    pub tpid: rte_be16_t,
    /// E-Tag control information (E-TCI).
    /// E-PCP (3b), E-DEI (1b), ingress E-CID base (12b).
    pub epcp_edei_in_ecid_b: rte_be16_t,
    /// Reserved (2b), GRP (2b), E-CID base (12b).
    pub rsvd_grp_ecid_b: rte_be16_t,
    /// < Ingress E-CID ext.
    pub in_ecid_e: u8,
    /// < E-CID ext.
    pub ecid_e: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_e_tag() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_e_tag>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_e_tag ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_e_tag>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_item_e_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_e_tag ) ) . tpid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_e_tag ) ,
                "::" , stringify ! ( tpid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_e_tag ) ) .
                epcp_edei_in_ecid_b as * const _ as usize } , 2usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_e_tag ) ,
                "::" , stringify ! ( epcp_edei_in_ecid_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_e_tag ) ) . rsvd_grp_ecid_b
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_e_tag ) ,
                "::" , stringify ! ( rsvd_grp_ecid_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_e_tag ) ) . in_ecid_e as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_e_tag ) ,
                "::" , stringify ! ( in_ecid_e ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_e_tag ) ) . ecid_e as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_e_tag ) ,
                "::" , stringify ! ( ecid_e ) ));
}
impl Clone for rte_flow_item_e_tag {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_e_tag_mask"]
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
/// RTE_FLOW_ITEM_TYPE_NVGRE.
///
/// Matches a NVGRE header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_nvgre {
    /// Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),
    /// reserved 0 (9b), version (3b).
    ///
    /// c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637.
    pub c_k_s_rsvd0_ver: rte_be16_t,
    /// < Protocol type (0x6558).
    pub protocol: rte_be16_t,
    /// < Virtual subnet ID.
    pub tni: [u8; 3usize],
    /// < Flow ID.
    pub flow_id: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_nvgre() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_nvgre>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_nvgre ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_nvgre>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_item_nvgre ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_nvgre ) ) . c_k_s_rsvd0_ver
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_nvgre ) ,
                "::" , stringify ! ( c_k_s_rsvd0_ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_nvgre ) ) . protocol as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_nvgre ) ,
                "::" , stringify ! ( protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_nvgre ) ) . tni as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_nvgre ) ,
                "::" , stringify ! ( tni ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_nvgre ) ) . flow_id as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_nvgre ) ,
                "::" , stringify ! ( flow_id ) ));
}
impl Clone for rte_flow_item_nvgre {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_nvgre_mask"]
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
/// RTE_FLOW_ITEM_TYPE_MPLS.
///
/// Matches a MPLS header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_mpls {
    /// Label (20b), TC (3b), Bottom of Stack (1b).
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
#[test]
fn bindgen_test_layout_rte_flow_item_mpls() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_mpls>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_mpls ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_mpls>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_mpls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_mpls ) ) . label_tc_s as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_mpls ) ,
                "::" , stringify ! ( label_tc_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_mpls ) ) . ttl as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_mpls ) ,
                "::" , stringify ! ( ttl ) ));
}
impl Clone for rte_flow_item_mpls {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_mpls_mask"]
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
/// RTE_FLOW_ITEM_TYPE_GRE.
///
/// Matches a GRE header.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_gre {
    /// Checksum (1b), reserved 0 (12b), version (3b).
    /// Refer to RFC 2784.
    pub c_rsvd0_ver: rte_be16_t,
    /// < Protocol type.
    pub protocol: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_flow_item_gre() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_gre>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_item_gre ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_gre>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_item_gre ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_gre ) ) . c_rsvd0_ver as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_gre ) ,
                "::" , stringify ! ( c_rsvd0_ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_gre ) ) . protocol as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_gre ) ,
                "::" , stringify ! ( protocol ) ));
}
impl Clone for rte_flow_item_gre {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_gre_mask"]
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
/// RTE_FLOW_ITEM_TYPE_FUZZY
///
/// Fuzzy pattern match, expect faster than default.
///
/// This is for device that support fuzzy match option.
/// Usually a fuzzy match is fast but the cost is accuracy.
/// i.e. Signature Match only match pattern's hash value, but it is
/// possible two different patterns have the same hash value.
///
/// Matching accuracy level can be configure by threshold.
/// Driver can divide the range of threshold and map to different
/// accuracy levels that device support.
///
/// Threshold 0 means perfect match (no fuzziness), while threshold
/// 0xffffffff means fuzziest match.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item_fuzzy {
    /// < Accuracy threshold.
    pub thresh: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_item_fuzzy() {
    assert_eq!(::std::mem::size_of::<rte_flow_item_fuzzy>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_item_fuzzy ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item_fuzzy>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_item_fuzzy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item_fuzzy ) ) . thresh as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item_fuzzy ) ,
                "::" , stringify ! ( thresh ) ));
}
impl Clone for rte_flow_item_fuzzy {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_flow_item_fuzzy_mask"]
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
/// Matching pattern item definition.
///
/// A pattern is formed by stacking items starting from the lowest protocol
/// layer to match. This stacking restriction does not apply to meta items
/// which can be placed anywhere in the stack without affecting the meaning
/// of the resulting pattern.
///
/// Patterns are terminated by END items.
///
/// The spec field should be a valid pointer to a structure of the related
/// item type. It may remain unspecified (NULL) in many cases to request
/// broad (nonspecific) matching. In such cases, last and mask must also be
/// set to NULL.
///
/// Optionally, last can point to a structure of the same type to define an
/// inclusive range. This is mostly supported by integer and address fields,
/// may cause errors otherwise. Fields that do not support ranges must be set
/// to 0 or to the same value as the corresponding fields in spec.
///
/// Only the fields defined to nonzero values in the default masks (see
/// rte_flow_item_{name}_mask constants) are considered relevant by
/// default. This can be overridden by providing a mask structure of the
/// same type with applicable bits set to one. It can also be used to
/// partially filter out specific fields (e.g. as an alternate mean to match
/// ranges of IP addresses).
///
/// Mask is a simple bit-mask applied before interpreting the contents of
/// spec and last, which may yield unexpected results if not used
/// carefully. For example, if for an IPv4 address field, spec provides
/// 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the
/// effective range becomes 10.1.0.0 to 10.3.255.255.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_item {
    /// < Item type.
    pub type_: rte_flow_item_type,
    /// < Pointer to item specification structure.
    pub spec: *const ::std::os::raw::c_void,
    /// < Defines an inclusive range (spec to last).
    pub last: *const ::std::os::raw::c_void,
    /// < Bit-mask applied to spec and last.
    pub mask: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_item() {
    assert_eq!(::std::mem::size_of::<rte_flow_item>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_item ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_item>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_flow_item ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item ) ) . spec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item ) , "::"
                , stringify ! ( spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item ) ) . last as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item ) , "::"
                , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_item ) ) . mask as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_item ) , "::"
                , stringify ! ( mask ) ));
}
impl Clone for rte_flow_item {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Action types.
///
/// Each possible action is represented by a type. Some have associated
/// configuration structures. Several actions combined in a list can be
/// affected to a flow rule. That list is not ordered.
///
/// They fall in three categories:
///
/// - Terminating actions (such as QUEUE, DROP, RSS, PF, VF) that prevent
/// processing matched packets by subsequent flow rules, unless overridden
/// with PASSTHRU.
///
/// - Non terminating actions (PASSTHRU, DUP) that leave matched packets up
/// for additional processing by subsequent flow rules.
///
/// - Other non terminating meta actions that do not affect the fate of
/// packets (END, VOID, MARK, FLAG, COUNT).
///
/// When several actions are combined in a flow rule, they should all have
/// different types (e.g. dropping a packet twice is not possible).
///
/// Only the last action of a given type is taken into account. PMDs still
/// perform error checking on the entire list.
///
/// Note that PASSTHRU is the only action able to override a terminating
/// rule.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_flow_action_type {
    RTE_FLOW_ACTION_TYPE_END = 0,
    RTE_FLOW_ACTION_TYPE_VOID = 1,
    RTE_FLOW_ACTION_TYPE_PASSTHRU = 2,
    RTE_FLOW_ACTION_TYPE_MARK = 3,
    RTE_FLOW_ACTION_TYPE_FLAG = 4,
    RTE_FLOW_ACTION_TYPE_QUEUE = 5,
    RTE_FLOW_ACTION_TYPE_DROP = 6,
    RTE_FLOW_ACTION_TYPE_COUNT = 7,
    RTE_FLOW_ACTION_TYPE_DUP = 8,
    RTE_FLOW_ACTION_TYPE_RSS = 9,
    RTE_FLOW_ACTION_TYPE_PF = 10,
    RTE_FLOW_ACTION_TYPE_VF = 11,
}
/// RTE_FLOW_ACTION_TYPE_MARK
///
/// Attaches an integer value to packets and sets PKT_RX_FDIR and
/// PKT_RX_FDIR_ID mbuf flags.
///
/// This value is arbitrary and application-defined. Maximum allowed value
/// depends on the underlying implementation. It is returned in the
/// hash.fdir.hi mbuf field.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action_mark {
    /// < Integer value to return with packets.
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_mark() {
    assert_eq!(::std::mem::size_of::<rte_flow_action_mark>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_action_mark ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_action_mark>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_action_mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action_mark ) ) . id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action_mark )
                , "::" , stringify ! ( id ) ));
}
impl Clone for rte_flow_action_mark {
    fn clone(&self) -> Self { *self }
}
/// RTE_FLOW_ACTION_TYPE_QUEUE
///
/// Assign packets to a given queue index.
///
/// Terminating by default.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action_queue {
    /// < Queue index to use.
    pub index: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_queue() {
    assert_eq!(::std::mem::size_of::<rte_flow_action_queue>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( rte_flow_action_queue )
               ));
    assert_eq! (::std::mem::align_of::<rte_flow_action_queue>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_action_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action_queue ) ) . index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action_queue )
                , "::" , stringify ! ( index ) ));
}
impl Clone for rte_flow_action_queue {
    fn clone(&self) -> Self { *self }
}
/// RTE_FLOW_ACTION_TYPE_COUNT (query)
///
/// Query structure to retrieve and reset flow rule counters.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_query_count {
    pub _bitfield_1: u32,
    /// < Number of hits for this rule [out].
    pub hits: u64,
    /// < Number of bytes through this rule [out].
    pub bytes: u64,
}
#[test]
fn bindgen_test_layout_rte_flow_query_count() {
    assert_eq!(::std::mem::size_of::<rte_flow_query_count>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_flow_query_count )
               ));
    assert_eq! (::std::mem::align_of::<rte_flow_query_count>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_query_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_query_count ) ) . hits as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_query_count )
                , "::" , stringify ! ( hits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_query_count ) ) . bytes as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_query_count )
                , "::" , stringify ! ( bytes ) ));
}
impl Clone for rte_flow_query_count {
    fn clone(&self) -> Self { *self }
}
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967288u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967288u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(reset: u32, hits_set: u32, bytes_set: u32,
                          reserved: u32) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((reset as u32 as u32) << 0usize) & (1u64 as u32))
                   } | ((hits_set as u32 as u32) << 1usize) & (2u64 as u32))
              } | ((bytes_set as u32 as u32) << 2usize) & (4u64 as u32))
         } | ((reserved as u32 as u32) << 3usize) & (4294967288u64 as u32))
    }
}
/// RTE_FLOW_ACTION_TYPE_DUP
///
/// Duplicates packets to a given queue index.
///
/// This is normally combined with QUEUE, however when used alone, it is
/// actually similar to QUEUE + PASSTHRU.
///
/// Non-terminating by default.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action_dup {
    /// < Queue index to duplicate packets to.
    pub index: u16,
}
#[test]
fn bindgen_test_layout_rte_flow_action_dup() {
    assert_eq!(::std::mem::size_of::<rte_flow_action_dup>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_action_dup ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_action_dup>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_action_dup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action_dup ) ) . index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action_dup ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for rte_flow_action_dup {
    fn clone(&self) -> Self { *self }
}
/// RTE_FLOW_ACTION_TYPE_RSS
///
/// Similar to QUEUE, except RSS is additionally performed on packets to
/// spread them among several queues according to the provided parameters.
///
/// Note: RSS hash result is stored in the hash.rss mbuf field which overlaps
/// hash.fdir.lo. Since the MARK action sets the hash.fdir.hi field only,
/// both can be requested simultaneously.
///
/// Terminating by default.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action_rss {
    /// < RSS parameters.
    pub rss_conf: *const rte_eth_rss_conf,
    /// < Number of entries in queue[].
    pub num: u16,
    /// < Queues indices to use.
    pub queue: __IncompleteArrayField<u16>,
}
#[test]
fn bindgen_test_layout_rte_flow_action_rss() {
    assert_eq!(::std::mem::size_of::<rte_flow_action_rss>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_flow_action_rss ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_action_rss>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_flow_action_rss ) ));
}
impl Clone for rte_flow_action_rss {
    fn clone(&self) -> Self { *self }
}
/// RTE_FLOW_ACTION_TYPE_VF
///
/// Redirects packets to a virtual function (VF) of the current device.
///
/// Packets matched by a VF pattern item can be redirected to their original
/// VF ID instead of the specified one. This parameter may not be available
/// and is not guaranteed to work properly if the VF part is matched by a
/// prior flow rule or if packets are not addressed to a VF in the first
/// place.
///
/// Terminating by default.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action_vf {
    pub _bitfield_1: u32,
    /// < VF ID to redirect packets to.
    pub id: u32,
}
#[test]
fn bindgen_test_layout_rte_flow_action_vf() {
    assert_eq!(::std::mem::size_of::<rte_flow_action_vf>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_flow_action_vf ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_action_vf>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_flow_action_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action_vf ) ) . id as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action_vf ) ,
                "::" , stringify ! ( id ) ));
}
impl Clone for rte_flow_action_vf {
    fn clone(&self) -> Self { *self }
}
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967294u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        let mask = 4294967294u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> u32 {
        ({ ({ 0 } | ((original as u32 as u32) << 0usize) & (1u64 as u32)) } |
             ((reserved as u32 as u32) << 1usize) & (4294967294u64 as u32))
    }
}
/// Definition of a single action.
///
/// A list of actions is terminated by a END action.
///
/// For simple actions without a configuration structure, conf remains NULL.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_action {
    /// < Action type.
    pub type_: rte_flow_action_type,
    /// < Pointer to action configuration structure.
    pub conf: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_flow_action() {
    assert_eq!(::std::mem::size_of::<rte_flow_action>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_action ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_action>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_flow_action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_action ) ) . conf as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_action ) ,
                "::" , stringify ! ( conf ) ));
}
impl Clone for rte_flow_action {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[repr(u32)]
/// Verbose error types.
///
/// Most of them provide the type of the object referenced by struct
/// rte_flow_error.cause.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_flow_error_type {
    RTE_FLOW_ERROR_TYPE_NONE = 0,
    RTE_FLOW_ERROR_TYPE_UNSPECIFIED = 1,
    RTE_FLOW_ERROR_TYPE_HANDLE = 2,
    RTE_FLOW_ERROR_TYPE_ATTR_GROUP = 3,
    RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY = 4,
    RTE_FLOW_ERROR_TYPE_ATTR_INGRESS = 5,
    RTE_FLOW_ERROR_TYPE_ATTR_EGRESS = 6,
    RTE_FLOW_ERROR_TYPE_ATTR = 7,
    RTE_FLOW_ERROR_TYPE_ITEM_NUM = 8,
    RTE_FLOW_ERROR_TYPE_ITEM = 9,
    RTE_FLOW_ERROR_TYPE_ACTION_NUM = 10,
    RTE_FLOW_ERROR_TYPE_ACTION = 11,
}
/// Verbose error structure definition.
///
/// This object is normally allocated by applications and set by PMDs, the
/// message points to a constant string which does not need to be freed by
/// the application, however its pointer can be considered valid only as long
/// as its associated DPDK port remains configured. Closing the underlying
/// device or unloading the PMD invalidates it.
///
/// Both cause and message may be NULL regardless of the error type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_error {
    /// < Cause field and error types.
    pub type_: rte_flow_error_type,
    /// < Object responsible for the error.
    pub cause: *const ::std::os::raw::c_void,
    /// < Human-readable error message.
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_flow_error() {
    assert_eq!(::std::mem::size_of::<rte_flow_error>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_error ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_error>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_flow_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_error ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_error ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_error ) ) . cause as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_error ) , "::"
                , stringify ! ( cause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_error ) ) . message as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_error ) , "::"
                , stringify ! ( message ) ));
}
impl Clone for rte_flow_error {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Check whether a flow rule can be created on a given port.
///
/// The flow rule is validated for correctness and whether it could be accepted
/// by the device given sufficient resources. The rule is checked against the
/// current device mode and queue configuration. The flow rule may also
/// optionally be validated against existing flow rules and device resources.
/// This function has no effect on the target device.
///
/// The returned value is guaranteed to remain valid only as long as no
/// successful calls to rte_flow_create() or rte_flow_destroy() are made in
/// the meantime and no device parameter affecting flow rules in any way are
/// modified, due to possible collisions or resource limitations (although in
/// such cases EINVAL should not be returned).
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param[in] attr
/// Flow rule attributes.
/// @param[in] pattern
/// Pattern specification (list terminated by the END pattern item).
/// @param[in] actions
/// Associated actions (list terminated by the END action).
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// 0 if flow rule is valid and can be created. A negative errno value
/// otherwise (rte_errno is also set), the following errors are defined:
///
/// -ENOSYS: underlying device does not support this functionality.
///
/// -EINVAL: unknown or invalid rule specification.
///
/// -ENOTSUP: valid but unsupported rule specification (e.g. partial
/// bit-masks are unsupported).
///
/// -EEXIST: collision with an existing rule. Only returned if device
/// supports flow rule collision checking and there was a flow rule
/// collision. Not receiving this return code is no guarantee that creating
/// the rule will not fail due to a collision.
///
/// -ENOMEM: not enough memory to execute the function, or if the device
/// supports resource validation, resource limitation on the device.
///
/// -EBUSY: action cannot be performed due to busy device resources, may
/// succeed if the affected queues or even the entire port are in a stopped
/// state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop()).
    pub fn rte_flow_validate(port_id: u8, attr: *const rte_flow_attr,
                             pattern: *const rte_flow_item,
                             actions: *const rte_flow_action,
                             error: *mut rte_flow_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a flow rule on a given port.
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param[in] attr
/// Flow rule attributes.
/// @param[in] pattern
/// Pattern specification (list terminated by the END pattern item).
/// @param[in] actions
/// Associated actions (list terminated by the END action).
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// A valid handle in case of success, NULL otherwise and rte_errno is set
/// to the positive version of one of the error codes defined for
/// rte_flow_validate().
    pub fn rte_flow_create(port_id: u8, attr: *const rte_flow_attr,
                           pattern: *const rte_flow_item,
                           actions: *const rte_flow_action,
                           error: *mut rte_flow_error) -> *mut rte_flow;
}
extern "C" {
    /// Destroy a flow rule on a given port.
///
/// Failure to destroy a flow rule handle may occur when other flow rules
/// depend on it, and destroying it would result in an inconsistent state.
///
/// This function is only guaranteed to succeed if handles are destroyed in
/// reverse order of their creation.
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param flow
/// Flow rule handle to destroy.
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// 0 on success, a negative errno value otherwise and rte_errno is set.
    pub fn rte_flow_destroy(port_id: u8, flow: *mut rte_flow,
                            error: *mut rte_flow_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Destroy all flow rules associated with a port.
///
/// In the unlikely event of failure, handles are still considered destroyed
/// and no longer valid but the port must be assumed to be in an inconsistent
/// state.
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// 0 on success, a negative errno value otherwise and rte_errno is set.
    pub fn rte_flow_flush(port_id: u8, error: *mut rte_flow_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Query an existing flow rule.
///
/// This function allows retrieving flow-specific data such as counters.
/// Data is gathered by special actions which must be present in the flow
/// rule definition.
///
/// \see RTE_FLOW_ACTION_TYPE_COUNT
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param flow
/// Flow rule handle to query.
/// @param action
/// Action type to query.
/// @param[in, out] data
/// Pointer to storage for the associated query data type.
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// 0 on success, a negative errno value otherwise and rte_errno is set.
    pub fn rte_flow_query(port_id: u8, flow: *mut rte_flow,
                          action: rte_flow_action_type,
                          data: *mut ::std::os::raw::c_void,
                          error: *mut rte_flow_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Restrict ingress traffic to the defined flow rules.
///
/// Isolated mode guarantees that all ingress traffic comes from defined flow
/// rules only (current and future).
///
/// Besides making ingress more deterministic, it allows PMDs to safely reuse
/// resources otherwise assigned to handle the remaining traffic, such as
/// global RSS configuration settings, VLAN filters, MAC address entries,
/// legacy filter API rules and so on in order to expand the set of possible
/// flow rule types.
///
/// Calling this function as soon as possible after device initialization,
/// ideally before the first call to rte_eth_dev_configure(), is recommended
/// to avoid possible failures due to conflicting settings.
///
/// Once effective, leaving isolated mode may not be possible depending on
/// PMD implementation.
///
/// Additionally, the following functionality has no effect on the underlying
/// port and may return errors such as ENOTSUP ("not supported"):
///
/// - Toggling promiscuous mode.
/// - Toggling allmulticast mode.
/// - Configuring MAC addresses.
/// - Configuring multicast addresses.
/// - Configuring VLAN filters.
/// - Configuring Rx filters through the legacy API (e.g. FDIR).
/// - Configuring global RSS settings.
///
/// @param port_id
/// Port identifier of Ethernet device.
/// @param set
/// Nonzero to enter isolated mode, attempt to leave it otherwise.
/// @param[out] error
/// Perform verbose error reporting if not NULL. PMDs initialize this
/// structure in case of error only.
///
/// @return
/// 0 on success, a negative errno value otherwise and rte_errno is set.
    pub fn rte_flow_isolate(port_id: u8, set: ::std::os::raw::c_int,
                            error: *mut rte_flow_error)
     -> ::std::os::raw::c_int;
}
/// Generic flow representation.
///
/// This form is sufficient to describe an rte_flow independently from any
/// PMD implementation and allows for replayability and identification.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_desc {
    /// < Allocated space including data[].
    pub size: usize,
    /// < Attributes.
    pub attr: rte_flow_attr,
    /// < Items.
    pub items: *mut rte_flow_item,
    /// < Actions.
    pub actions: *mut rte_flow_action,
    /// < Storage for items/actions.
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_flow_desc() {
    assert_eq!(::std::mem::size_of::<rte_flow_desc>() , 40usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_desc ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_flow_desc ) ));
}
impl Clone for rte_flow_desc {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Copy an rte_flow rule description.
///
/// @param[in] fd
/// Flow rule description.
/// @param[in] len
/// Total size of allocated data for the flow description.
/// @param[in] attr
/// Flow rule attributes.
/// @param[in] items
/// Pattern specification (list terminated by the END pattern item).
/// @param[in] actions
/// Associated actions (list terminated by the END action).
///
/// @return
/// If len is greater or equal to the size of the flow, the total size of the
/// flow description and its data.
/// If len is lower than the size of the flow, the number of bytes that would
/// have been written to desc had it been sufficient. Nothing is written.
    pub fn rte_flow_copy(fd: *mut rte_flow_desc, len: usize,
                         attr: *const rte_flow_attr,
                         items: *const rte_flow_item,
                         actions: *const rte_flow_action) -> usize;
}
/// Generic flow operations structure implemented and returned by PMDs.
///
/// To implement this API, PMDs must handle the RTE_ETH_FILTER_GENERIC filter
/// type in their .filter_ctrl callback function (struct eth_dev_ops) as well
/// as the RTE_ETH_FILTER_GET filter operation.
///
/// If successful, this operation must result in a pointer to a PMD-specific
/// struct rte_flow_ops written to the argument address as described below:
///
/// \code
///
/// // PMD filter_ctrl callback
///
/// static const struct rte_flow_ops pmd_flow_ops = { ... };
///
/// switch (filter_type) {
/// case RTE_ETH_FILTER_GENERIC:
/// if (filter_op != RTE_ETH_FILTER_GET)
/// return -EINVAL;
/// *(const void **)arg = &pmd_flow_ops;
/// return 0;
/// }
///
/// \endcode
///
/// See also rte_flow_ops_get().
///
/// These callback functions are not supposed to be used by applications
/// directly, which must rely on the API defined in rte_flow.h.
///
/// Public-facing wrapper functions perform a few consistency checks so that
/// unimplemented (i.e. NULL) callbacks simply return -ENOTSUP. These
/// callbacks otherwise only differ by their first argument (with port ID
/// already resolved to a pointer to struct rte_eth_dev).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_flow_ops {
    /// See rte_flow_validate().
    pub validate: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut rte_eth_dev,
                                                             arg2:
                                                                 *const rte_flow_attr,
                                                             arg3:
                                                                 *const rte_flow_item,
                                                             arg4:
                                                                 *const rte_flow_action,
                                                             arg5:
                                                                 *mut rte_flow_error)
                                            -> ::std::os::raw::c_int>,
    /// See rte_flow_create().
    pub create: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut rte_eth_dev,
                                                           arg2:
                                                               *const rte_flow_attr,
                                                           arg3:
                                                               *const rte_flow_item,
                                                           arg4:
                                                               *const rte_flow_action,
                                                           arg5:
                                                               *mut rte_flow_error)
                                          -> *mut rte_flow>,
    /// See rte_flow_destroy().
    pub destroy: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut rte_eth_dev,
                                                            arg2:
                                                                *mut rte_flow,
                                                            arg3:
                                                                *mut rte_flow_error)
                                           -> ::std::os::raw::c_int>,
    /// See rte_flow_flush().
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut rte_eth_dev,
                                                          arg2:
                                                              *mut rte_flow_error)
                                         -> ::std::os::raw::c_int>,
    /// See rte_flow_query().
    pub query: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut rte_eth_dev,
                                                          arg2: *mut rte_flow,
                                                          arg3:
                                                              rte_flow_action_type,
                                                          arg4:
                                                              *mut ::std::os::raw::c_void,
                                                          arg5:
                                                              *mut rte_flow_error)
                                         -> ::std::os::raw::c_int>,
    /// See rte_flow_isolate().
    pub isolate: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut rte_eth_dev,
                                                            arg2:
                                                                ::std::os::raw::c_int,
                                                            arg3:
                                                                *mut rte_flow_error)
                                           -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rte_flow_ops() {
    assert_eq!(::std::mem::size_of::<rte_flow_ops>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_flow_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_flow_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_flow_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . validate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( validate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . create as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . destroy as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . flush as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . query as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_flow_ops ) ) . isolate as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_flow_ops ) , "::" ,
                stringify ! ( isolate ) ));
}
impl Clone for rte_flow_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Get generic flow operations structure from a port.
///
/// @param port_id
/// Port identifier to query.
/// @param[out] error
/// Pointer to flow error structure.
///
/// @return
/// The flow operations structure associated with port_id, NULL in case of
/// error, in which case rte_errno is set and the error structure contains
/// additional details.
    pub fn rte_flow_ops_get(port_id: u8, error: *mut rte_flow_error)
     -> *const rte_flow_ops;
}
/// GRE Header
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct gre_hdr {
    pub _bitfield_1: [u8; 2usize],
    /// < Protocol Type
    pub proto: u16,
}
#[test]
fn bindgen_test_layout_gre_hdr() {
    assert_eq!(::std::mem::size_of::<gre_hdr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( gre_hdr ) ));
    assert_eq! (::std::mem::align_of::<gre_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( gre_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gre_hdr ) ) . proto as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( gre_hdr ) , "::" ,
                stringify ! ( proto ) ));
}
impl Clone for gre_hdr {
    fn clone(&self) -> Self { *self }
}
impl gre_hdr {
    #[inline]
    pub fn res2(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 15u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        let mask = 15u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn k(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_k(&mut self, val: u16) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn c(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_c(&mut self, val: u16) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ver(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1792u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        let mask = 1792u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 63488u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        let mask = 63488u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(res2: u16, s: u16, k: u16, res1: u16, c: u16,
                          ver: u16, res3: u16) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((res2 as u16 as u16) << 0usize) &
                                               (15u64 as u16))
                                  } |
                                      ((s as u16 as u16) << 4usize) &
                                          (16u64 as u16))
                             } |
                                 ((k as u16 as u16) << 5usize) &
                                     (32u64 as u16))
                        } | ((res1 as u16 as u16) << 6usize) & (64u64 as u16))
                   } | ((c as u16 as u16) << 7usize) & (128u64 as u16))
              } | ((ver as u16 as u16) << 8usize) & (1792u64 as u16))
         } | ((res3 as u16 as u16) << 11usize) & (63488u64 as u16))
    }
}
/// A structure which is used to create GRO context objects or tell
/// rte_gro_reassemble_burst() what reassembly rules are demanded.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_gro_param {
    pub gro_types: u64,
    pub max_flow_num: u16,
    pub max_item_per_flow: u16,
    pub socket_id: u16,
}
#[test]
fn bindgen_test_layout_rte_gro_param() {
    assert_eq!(::std::mem::size_of::<rte_gro_param>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_gro_param ) ));
    assert_eq! (::std::mem::align_of::<rte_gro_param>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_gro_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_gro_param ) ) . gro_types as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_gro_param ) , "::"
                , stringify ! ( gro_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_gro_param ) ) . max_flow_num as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_gro_param ) , "::"
                , stringify ! ( max_flow_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_gro_param ) ) . max_item_per_flow as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_gro_param ) , "::"
                , stringify ! ( max_item_per_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_gro_param ) ) . socket_id as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_gro_param ) , "::"
                , stringify ! ( socket_id ) ));
}
impl Clone for rte_gro_param {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// This function create a GRO context object, which is used to merge
/// packets in rte_gro_reassemble().
///
/// @param param
/// applications use it to pass needed parameters to create a GRO
/// context object.
///
/// @return
/// if create successfully, return a pointer which points to the GRO
/// context object. Otherwise, return NULL.
    pub fn rte_gro_ctx_create(param: *const rte_gro_param)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// This function destroys a GRO context object.
///
/// @param ctx
/// pointer points to a GRO context object.
    pub fn rte_gro_ctx_destroy(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// This is one of the main reassembly APIs, which merges numbers of
/// packets at a time. It assumes that all inputted packets are with
/// correct checksums. That is, applications should guarantee all
/// inputted packets are correct. Besides, it doesn't re-calculate
/// checksums for merged packets. If inputted packets are IP fragmented,
/// this function assumes them are complete (i.e. with L4 header). After
/// finishing processing, it returns all GROed packets to applications
/// immediately.
///
/// @param pkts
/// a pointer array which points to the packets to reassemble. Besides,
/// it keeps mbuf addresses for the GROed packets.
/// @param nb_pkts
/// the number of packets to reassemble.
/// @param param
/// applications use it to tell rte_gro_reassemble_burst() what rules
/// are demanded.
///
/// @return
/// the number of packets after been GROed. If no packets are merged,
/// the returned value is nb_pkts.
    pub fn rte_gro_reassemble_burst(pkts: *mut *mut rte_mbuf, nb_pkts: u16,
                                    param: *const rte_gro_param) -> u16;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Reassembly function, which tries to merge inputted packets with
/// the packets in the reassembly tables of a given GRO context. This
/// function assumes all inputted packets are with correct checksums.
/// And it won't update checksums if two packets are merged. Besides,
/// if inputted packets are IP fragmented, this function assumes they
/// are complete packets (i.e. with L4 header).
///
/// If the inputted packets don't have data or are with unsupported GRO
/// types etc., they won't be processed and are returned to applications.
/// Otherwise, the inputted packets are either merged or inserted into
/// the table. If applications want get packets in the table, they need
/// to call flush API.
///
/// @param pkts
/// packet to reassemble. Besides, after this function finishes, it
/// keeps the unprocessed packets (e.g. without data or unsupported
/// GRO types).
/// @param nb_pkts
/// the number of packets to reassemble.
/// @param ctx
/// a pointer points to a GRO context object.
///
/// @return
/// return the number of unprocessed packets (e.g. without data or
/// unsupported GRO types). If all packets are processed (merged or
/// inserted into the table), return 0.
    pub fn rte_gro_reassemble(pkts: *mut *mut rte_mbuf, nb_pkts: u16,
                              ctx: *mut ::std::os::raw::c_void) -> u16;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// This function flushes the timeout packets from reassembly tables of
/// desired GRO types. The max number of flushed timeout packets is the
/// element number of the array which is used to keep the flushed packets.
///
/// Besides, this function won't re-calculate checksums for merged
/// packets in the tables. That is, the returned packets may be with
/// wrong checksums.
///
/// @param ctx
/// a pointer points to a GRO context object.
/// @param timeout_cycles
/// max TTL for packets in reassembly tables, measured in nanosecond.
/// @param gro_types
/// this function only flushes packets which belong to the GRO types
/// specified by gro_types.
/// @param out
/// a pointer array that is used to keep flushed timeout packets.
/// @param max_nb_out
/// the element number of out. It's also the max number of timeout
/// packets that can be flushed finally.
///
/// @return
/// the number of flushed packets. If no packets are flushed, return 0.
    pub fn rte_gro_timeout_flush(ctx: *mut ::std::os::raw::c_void,
                                 timeout_cycles: u64, gro_types: u64,
                                 out: *mut *mut rte_mbuf, max_nb_out: u16)
     -> u16;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// This function returns the number of packets in all reassembly tables
/// of a given GRO context.
///
/// @param ctx
/// pointer points to a GRO context object.
///
/// @return
/// the number of packets in all reassembly tables.
    pub fn rte_gro_get_pkt_count(ctx: *mut ::std::os::raw::c_void) -> u64;
}
/// Signature of key that is stored internally.
pub type hash_sig_t = u32;
/// Type of function that can be used for calculating the hash value.
pub type rte_hash_function =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               key_len: u32, init_val: u32)
                              -> u32>;
/// Type of function used to compare the hash key.
pub type rte_hash_cmp_eq_t =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               key_len: usize)
                              -> ::std::os::raw::c_int>;
/// Parameters used when creating the hash table.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_hash_parameters {
    /// < Name of the hash.
    pub name: *const ::std::os::raw::c_char,
    /// < Total hash table entries.
    pub entries: u32,
    /// < Unused field. Should be set to 0
    pub reserved: u32,
    /// < Length of hash key.
    pub key_len: u32,
    /// < Primary Hash function used to calculate hash.
    pub hash_func: rte_hash_function,
    /// < Init value used by hash_func.
    pub hash_func_init_val: u32,
    /// < NUMA Socket ID for memory.
    pub socket_id: ::std::os::raw::c_int,
    /// < Indicate if additional parameters are present.
    pub extra_flag: u8,
}
#[test]
fn bindgen_test_layout_rte_hash_parameters() {
    assert_eq!(::std::mem::size_of::<rte_hash_parameters>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( rte_hash_parameters ) ));
    assert_eq! (::std::mem::align_of::<rte_hash_parameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_hash_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . entries as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . reserved as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . key_len as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( key_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . hash_func as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( hash_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) .
                hash_func_init_val as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( hash_func_init_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . socket_id as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . extra_flag as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_hash_parameters ) ,
                "::" , stringify ! ( extra_flag ) ));
}
impl Clone for rte_hash_parameters {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hash {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a new hash table.
///
/// @param params
/// Parameters used to create and initialise the hash table.
/// @return
/// Pointer to hash table structure that is used in future hash table
/// operations, or NULL on error, with error code set in rte_errno.
/// Possible rte_errno errors include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - ENOENT - missing entry
/// - EINVAL - invalid parameter passed to function
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_hash_create(params: *const rte_hash_parameters)
     -> *mut rte_hash;
}
extern "C" {
    /// Set a new hash compare function other than the default one.
///
/// @note Function pointer does not work with multi-process, so do not use it
/// in multi-process mode.
///
/// @param h
/// Hash table for which the function is to be changed
/// @param func
/// New compare function
    pub fn rte_hash_set_cmp_func(h: *mut rte_hash, func: rte_hash_cmp_eq_t);
}
extern "C" {
    /// Find an existing hash table object and return a pointer to it.
///
/// @param name
/// Name of the hash table as passed to rte_hash_create()
/// @return
/// Pointer to hash table or NULL if object not found
/// with rte_errno set appropriately. Possible rte_errno values include:
/// - ENOENT - value not available for return
    pub fn rte_hash_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_hash;
}
extern "C" {
    /// De-allocate all memory used by hash table.
/// @param h
/// Hash table to free
    pub fn rte_hash_free(h: *mut rte_hash);
}
extern "C" {
    /// Reset all hash structure, by zeroing all entries
/// @param h
/// Hash table to reset
    pub fn rte_hash_reset(h: *mut rte_hash);
}
extern "C" {
    /// Add a key-value pair to an existing hash table.
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to add the key to.
/// @param key
/// Key to add to the hash table.
/// @param data
/// Data to add to the hash table.
/// @return
/// - 0 if added successfully
/// - -EINVAL if the parameters are invalid.
/// - -ENOSPC if there is no space in the hash for this key.
    pub fn rte_hash_add_key_data(h: *const rte_hash,
                                 key: *const ::std::os::raw::c_void,
                                 data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a key-value pair with a pre-computed hash value
/// to an existing hash table.
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to add the key to.
/// @param key
/// Key to add to the hash table.
/// @param sig
/// Precomputed hash value for 'key'
/// @param data
/// Data to add to the hash table.
/// @return
/// - 0 if added successfully
/// - -EINVAL if the parameters are invalid.
/// - -ENOSPC if there is no space in the hash for this key.
    pub fn rte_hash_add_key_with_hash_data(h: *const rte_hash,
                                           key: *const ::std::os::raw::c_void,
                                           sig: hash_sig_t,
                                           data: *mut ::std::os::raw::c_void)
     -> i32;
}
extern "C" {
    /// Add a key to an existing hash table. This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to add the key to.
/// @param key
/// Key to add to the hash table.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOSPC if there is no space in the hash for this key.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key.
    pub fn rte_hash_add_key(h: *const rte_hash,
                            key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /// Add a key to an existing hash table.
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to add the key to.
/// @param key
/// Key to add to the hash table.
/// @param sig
/// Precomputed hash value for 'key'.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOSPC if there is no space in the hash for this key.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key.
    pub fn rte_hash_add_key_with_hash(h: *const rte_hash,
                                      key: *const ::std::os::raw::c_void,
                                      sig: hash_sig_t) -> i32;
}
extern "C" {
    /// Remove a key from an existing hash table.
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to remove the key from.
/// @param key
/// Key to remove from the hash table.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOENT if the key is not found.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key, and is the same
/// value that was returned when the key was added.
    pub fn rte_hash_del_key(h: *const rte_hash,
                            key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /// Remove a key from an existing hash table.
/// This operation is not multi-thread safe
/// and should only be called from one thread.
///
/// @param h
/// Hash table to remove the key from.
/// @param key
/// Key to remove from the hash table.
/// @param sig
/// Precomputed hash value for 'key'.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOENT if the key is not found.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key, and is the same
/// value that was returned when the key was added.
    pub fn rte_hash_del_key_with_hash(h: *const rte_hash,
                                      key: *const ::std::os::raw::c_void,
                                      sig: hash_sig_t) -> i32;
}
extern "C" {
    /// Find a key in the hash table given the position.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to get the key from.
/// @param position
/// Position returned when the key was inserted.
/// @param key
/// Output containing a pointer to the key
/// @return
/// - 0 if retrieved successfully
/// - EINVAL if the parameters are invalid.
/// - ENOENT if no valid key is found in the given position.
    pub fn rte_hash_get_key_with_position(h: *const rte_hash, position: i32,
                                          key:
                                              *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find a key-value pair in the hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param key
/// Key to find.
/// @param data
/// Output with pointer to data returned from the hash table.
/// @return
/// 0 if successful lookup
/// - EINVAL if the parameters are invalid.
/// - ENOENT if the key is not found.
    pub fn rte_hash_lookup_data(h: *const rte_hash,
                                key: *const ::std::os::raw::c_void,
                                data: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find a key-value pair with a pre-computed hash value
/// to an existing hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param key
/// Key to find.
/// @param sig
/// Precomputed hash value for 'key'
/// @param data
/// Output with pointer to data returned from the hash table.
/// @return
/// 0 if successful lookup
/// - EINVAL if the parameters are invalid.
/// - ENOENT if the key is not found.
    pub fn rte_hash_lookup_with_hash_data(h: *const rte_hash,
                                          key: *const ::std::os::raw::c_void,
                                          sig: hash_sig_t,
                                          data:
                                              *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find a key in the hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param key
/// Key to find.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOENT if the key is not found.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key, and is the same
/// value that was returned when the key was added.
    pub fn rte_hash_lookup(h: *const rte_hash,
                           key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /// Find a key in the hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param key
/// Key to find.
/// @param sig
/// Hash value to remove from the hash table.
/// @return
/// - -EINVAL if the parameters are invalid.
/// - -ENOENT if the key is not found.
/// - A positive value that can be used by the caller as an offset into an
/// array of user data. This value is unique for this key, and is the same
/// value that was returned when the key was added.
    pub fn rte_hash_lookup_with_hash(h: *const rte_hash,
                                     key: *const ::std::os::raw::c_void,
                                     sig: hash_sig_t) -> i32;
}
extern "C" {
    /// Calc a hash value by key.
/// This operation is not multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param key
/// Key to find.
/// @return
/// - hash value
    pub fn rte_hash_hash(h: *const rte_hash,
                         key: *const ::std::os::raw::c_void) -> hash_sig_t;
}
extern "C" {
    /// Find multiple keys in the hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param keys
/// A pointer to a list of keys to look for.
/// @param num_keys
/// How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
/// @param hit_mask
/// Output containing a bitmask with all successful lookups.
/// @param data
/// Output containing array of data returned from all the successful lookups.
/// @return
/// -EINVAL if there's an error, otherwise number of successful lookups.
    pub fn rte_hash_lookup_bulk_data(h: *const rte_hash,
                                     keys: *mut *const ::std::os::raw::c_void,
                                     num_keys: u32, hit_mask: *mut u64,
                                     data: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find multiple keys in the hash table.
/// This operation is multi-thread safe.
///
/// @param h
/// Hash table to look in.
/// @param keys
/// A pointer to a list of keys to look for.
/// @param num_keys
/// How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
/// @param positions
/// Output containing a list of values, corresponding to the list of keys that
/// can be used by the caller as an offset into an array of user data. These
/// values are unique for each key, and are the same values that were returned
/// when each key was added. If a key in the list was not found, then -ENOENT
/// will be the value.
/// @return
/// -EINVAL if there's an error, otherwise 0.
    pub fn rte_hash_lookup_bulk(h: *const rte_hash,
                                keys: *mut *const ::std::os::raw::c_void,
                                num_keys: u32, positions: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Iterate through the hash table, returning key-value pairs.
///
/// @param h
/// Hash table to iterate
/// @param key
/// Output containing the key where current iterator
/// was pointing at
/// @param data
/// Output containing the data associated with key.
/// Returns NULL if data was not stored.
/// @param next
/// Pointer to iterator. Should be 0 to start iterating the hash table.
/// Iterator is incremented after each call of this function.
/// @return
/// Position where key was stored, if successful.
/// - -EINVAL if the parameters are invalid.
/// - -ENOENT if end of the hash table.
    pub fn rte_hash_iterate(h: *const rte_hash,
                            key: *mut *const ::std::os::raw::c_void,
                            data: *mut *mut ::std::os::raw::c_void,
                            next: *mut u32) -> i32;
}
extern "C" {
    /// Dump out memory in a special hex dump format.
///
/// @param f
/// A pointer to a file for output
/// @param title
/// If not NULL this string is printed as a header to the output.
/// @param buf
/// This is the buffer address to print out.
/// @param len
/// The number of bytes to dump out
/// @return
/// None.
    pub fn rte_hexdump(f: *mut FILE, title: *const ::std::os::raw::c_char,
                       buf: *const ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint);
}
extern "C" {
    /// Dump out memory in a hex format with colons between bytes.
///
/// @param f
/// A pointer to a file for output
/// @param title
/// If not NULL this string is printed as a header to the output.
/// @param buf
/// This is the buffer address to print out.
/// @param len
/// The number of bytes to dump out
/// @return
/// None.
    pub fn rte_memdump(f: *mut FILE, title: *const ::std::os::raw::c_char,
                       buf: *const ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint);
}
pub const IP_LAST_FRAG_IDX: _bindgen_ty_24 = _bindgen_ty_24::IP_LAST_FRAG_IDX;
pub const IP_FIRST_FRAG_IDX: _bindgen_ty_24 =
    _bindgen_ty_24::IP_FIRST_FRAG_IDX;
pub const IP_MIN_FRAG_NUM: _bindgen_ty_24 = _bindgen_ty_24::IP_MIN_FRAG_NUM;
pub const IP_MAX_FRAG_NUM: _bindgen_ty_24 = _bindgen_ty_24::IP_MAX_FRAG_NUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 {
    IP_LAST_FRAG_IDX = 0,
    IP_FIRST_FRAG_IDX = 1,
    IP_MIN_FRAG_NUM = 2,
    IP_MAX_FRAG_NUM = 4,
}
/// @internal fragmented mbuf
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag {
    /// < offset into the packet
    pub ofs: u16,
    /// < length of fragment
    pub len: u16,
    /// < fragment mbuf
    pub mb: *mut rte_mbuf,
}
#[test]
fn bindgen_test_layout_ip_frag() {
    assert_eq!(::std::mem::size_of::<ip_frag>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ip_frag ) ));
    assert_eq! (::std::mem::align_of::<ip_frag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ip_frag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . ofs as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag ) , "::" ,
                stringify ! ( ofs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . len as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . mb as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag ) , "::" ,
                stringify ! ( mb ) ));
}
impl Clone for ip_frag {
    fn clone(&self) -> Self { *self }
}
/// @internal <src addr, dst_addr, id> to uniquely indetify fragmented datagram.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_key {
    /// < src address, first 8 bytes used for IPv4
    pub src_dst: [u64; 4usize],
    /// < dst address
    pub id: u32,
    /// < src/dst key length
    pub key_len: u32,
}
#[test]
fn bindgen_test_layout_ip_frag_key() {
    assert_eq!(::std::mem::size_of::<ip_frag_key>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ip_frag_key ) ));
    assert_eq! (::std::mem::align_of::<ip_frag_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ip_frag_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . src_dst as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_key ) , "::" ,
                stringify ! ( src_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . id as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_key ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . key_len as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_key ) , "::" ,
                stringify ! ( key_len ) ));
}
impl Clone for ip_frag_key {
    fn clone(&self) -> Self { *self }
}
/// @internal Fragmented packet to reassemble.
/// First two entries in the frags[] array are for the last and first fragments.
#[repr(C)]
#[derive(Copy)]
pub struct ip_frag_pkt {
    /// < LRU list
    pub lru: ip_frag_pkt__bindgen_ty_1,
    /// < fragmentation key
    pub key: ip_frag_key,
    /// < creation timestamp
    pub start: u64,
    /// < expected reassembled size
    pub total_size: u32,
    /// < size of fragments received
    pub frag_size: u32,
    /// < index of next entry to fill
    pub last_idx: u32,
    /// < fragments
    pub frags: [ip_frag; 4usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_pkt__bindgen_ty_1 {
    pub tqe_next: *mut ip_frag_pkt,
    pub tqe_prev: *mut *mut ip_frag_pkt,
}
#[test]
fn bindgen_test_layout_ip_frag_pkt__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ip_frag_pkt__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ip_frag_pkt__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ip_frag_pkt__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ip_frag_pkt__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_frag_pkt__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_frag_pkt__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for ip_frag_pkt__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ip_frag_pkt() {
    assert_eq!(::std::mem::size_of::<ip_frag_pkt>() , 192usize , concat ! (
               "Size of: " , stringify ! ( ip_frag_pkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . lru as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( lru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . start as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . total_size as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( total_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . frag_size as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( frag_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . last_idx as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( last_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . frags as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_pkt ) , "::" ,
                stringify ! ( frags ) ));
}
impl Clone for ip_frag_pkt {
    fn clone(&self) -> Self { *self }
}
/// mbuf death row (packets to be freed)
#[repr(C)]
pub struct rte_ip_frag_death_row {
    /// < number of mbufs currently on death row
    pub cnt: u32,
    pub row: [*mut rte_mbuf; 160usize],
}
#[test]
fn bindgen_test_layout_rte_ip_frag_death_row() {
    assert_eq!(::std::mem::size_of::<rte_ip_frag_death_row>() , 1288usize ,
               concat ! ( "Size of: " , stringify ! ( rte_ip_frag_death_row )
               ));
    assert_eq! (::std::mem::align_of::<rte_ip_frag_death_row>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_ip_frag_death_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_death_row ) ) . cnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_death_row )
                , "::" , stringify ! ( cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_death_row ) ) . row as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_death_row )
                , "::" , stringify ! ( row ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_pkt_list {
    pub tqh_first: *mut ip_frag_pkt,
    pub tqh_last: *mut *mut ip_frag_pkt,
}
#[test]
fn bindgen_test_layout_ip_pkt_list() {
    assert_eq!(::std::mem::size_of::<ip_pkt_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ip_pkt_list ) ));
    assert_eq! (::std::mem::align_of::<ip_pkt_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ip_pkt_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_pkt_list ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_pkt_list ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_pkt_list ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_pkt_list ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for ip_pkt_list {
    fn clone(&self) -> Self { *self }
}
/// fragmentation table statistics
#[repr(C)]
#[derive(Copy)]
pub struct ip_frag_tbl_stat {
    /// < total # of find/insert attempts.
    pub find_num: u64,
    /// < # of add ops.
    pub add_num: u64,
    /// < # of del ops.
    pub del_num: u64,
    /// < # of reuse (del/add) ops.
    pub reuse_num: u64,
    /// < total # of add failures.
    pub fail_total: u64,
    /// < # of 'no space' add failures.
    pub fail_nospace: u64,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ip_frag_tbl_stat() {
    assert_eq!(::std::mem::size_of::<ip_frag_tbl_stat>() , 64usize , concat !
               ( "Size of: " , stringify ! ( ip_frag_tbl_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . find_num as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( find_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . add_num as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( add_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . del_num as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( del_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . reuse_num as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( reuse_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . fail_total as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( fail_total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . fail_nospace as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_frag_tbl_stat ) ,
                "::" , stringify ! ( fail_nospace ) ));
}
impl Clone for ip_frag_tbl_stat {
    fn clone(&self) -> Self { *self }
}
/// fragmentation table
#[repr(C)]
#[derive(Copy)]
pub struct rte_ip_frag_tbl {
    /// < ttl for table entries.
    pub max_cycles: u64,
    /// < hash value mask.
    pub entry_mask: u32,
    /// < max entries allowed.
    pub max_entries: u32,
    /// < entries in use.
    pub use_entries: u32,
    /// < hash assocaitivity.
    pub bucket_entries: u32,
    /// < total size of the table.
    pub nb_entries: u32,
    /// < num of associativity lines.
    pub nb_buckets: u32,
    /// < last used entry.
    pub last: *mut ip_frag_pkt,
    /// < LRU list for table entries.
    pub lru: ip_pkt_list,
    pub __bindgen_padding_0: u64,
    /// < statistics counters.
    pub stat: ip_frag_tbl_stat,
    /// < hash table.
    pub pkt: __IncompleteArrayField<ip_frag_pkt>,
}
#[test]
fn bindgen_test_layout_rte_ip_frag_tbl() {
    assert_eq!(::std::mem::size_of::<rte_ip_frag_tbl>() , 128usize , concat !
               ( "Size of: " , stringify ! ( rte_ip_frag_tbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . max_cycles as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( max_cycles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . entry_mask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( entry_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . max_entries as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( max_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . use_entries as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( use_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . bucket_entries as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( bucket_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . nb_entries as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( nb_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . nb_buckets as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( nb_buckets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . last as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . lru as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( lru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . stat as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . pkt as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ip_frag_tbl ) ,
                "::" , stringify ! ( pkt ) ));
}
impl Clone for rte_ip_frag_tbl {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv6_extension_fragment {
    /// < Next header type
    pub next_header: u8,
    /// < Reserved
    pub reserved: u8,
    /// < All fragmentation data
    pub frag_data: u16,
    /// < Packet ID
    pub id: u32,
}
#[test]
fn bindgen_test_layout_ipv6_extension_fragment() {
    assert_eq!(::std::mem::size_of::<ipv6_extension_fragment>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ipv6_extension_fragment ) ));
    assert_eq! (::std::mem::align_of::<ipv6_extension_fragment>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( ipv6_extension_fragment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . next_header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_extension_fragment
                ) , "::" , stringify ! ( next_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . reserved as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_extension_fragment
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . frag_data
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_extension_fragment
                ) , "::" , stringify ! ( frag_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_extension_fragment
                ) , "::" , stringify ! ( id ) ));
}
impl Clone for ipv6_extension_fragment {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Create a new IP fragmentation table.
///
/// @param bucket_num
/// Number of buckets in the hash table.
/// @param bucket_entries
/// Number of entries per bucket (e.g. hash associativity).
/// Should be power of two.
/// @param max_entries
/// Maximum number of entries that could be stored in the table.
/// The value should be less or equal then bucket_num * bucket_entries.
/// @param max_cycles
/// Maximum TTL in cycles for each fragmented packet.
/// @param socket_id
/// The *socket_id* argument is the socket identifier in the case of
/// NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA constraints.
/// @return
/// The pointer to the new allocated fragmentation table, on success. NULL on error.
    pub fn rte_ip_frag_table_create(bucket_num: u32, bucket_entries: u32,
                                    max_entries: u32, max_cycles: u64,
                                    socket_id: ::std::os::raw::c_int)
     -> *mut rte_ip_frag_tbl;
}
extern "C" {
    /// Free allocated IP fragmentation table.
///
/// @param tbl
/// Fragmentation table to free.
    pub fn rte_ip_frag_table_destroy(tbl: *mut rte_ip_frag_tbl);
}
extern "C" {
    /// This function implements the fragmentation of IPv6 packets.
///
/// @param pkt_in
/// The input packet.
/// @param pkts_out
/// Array storing the output fragments.
/// @param nb_pkts_out
/// Number of fragments.
/// @param mtu_size
/// Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv6
/// datagrams. This value includes the size of the IPv6 header.
/// @param pool_direct
/// MBUF pool used for allocating direct buffers for the output fragments.
/// @param pool_indirect
/// MBUF pool used for allocating indirect buffers for the output fragments.
/// @return
/// Upon successful completion - number of output fragments placed
/// in the pkts_out array.
/// Otherwise - (-1) * errno.
    pub fn rte_ipv6_fragment_packet(pkt_in: *mut rte_mbuf,
                                    pkts_out: *mut *mut rte_mbuf,
                                    nb_pkts_out: u16, mtu_size: u16,
                                    pool_direct: *mut rte_mempool,
                                    pool_indirect: *mut rte_mempool) -> i32;
}
extern "C" {
    /// This function implements reassembly of fragmented IPv6 packets.
/// Incoming mbuf should have its l2_len/l3_len fields setup correctly.
///
/// @param tbl
/// Table where to lookup/add the fragmented packet.
/// @param dr
/// Death row to free buffers to
/// @param mb
/// Incoming mbuf with IPv6 fragment.
/// @param tms
/// Fragment arrival timestamp.
/// @param ip_hdr
/// Pointer to the IPv6 header.
/// @param frag_hdr
/// Pointer to the IPv6 fragment extension header.
/// @return
/// Pointer to mbuf for reassembled packet, or NULL if:
/// - an error occurred.
/// - not all fragments of the packet are collected yet.
    pub fn rte_ipv6_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl,
                                           dr: *mut rte_ip_frag_death_row,
                                           mb: *mut rte_mbuf, tms: u64,
                                           ip_hdr: *mut ipv6_hdr,
                                           frag_hdr:
                                               *mut ipv6_extension_fragment)
     -> *mut rte_mbuf;
}
extern "C" {
    /// IPv4 fragmentation.
///
/// This function implements the fragmentation of IPv4 packets.
///
/// @param pkt_in
/// The input packet.
/// @param pkts_out
/// Array storing the output fragments.
/// @param nb_pkts_out
/// Number of fragments.
/// @param mtu_size
/// Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv4
/// datagrams. This value includes the size of the IPv4 header.
/// @param pool_direct
/// MBUF pool used for allocating direct buffers for the output fragments.
/// @param pool_indirect
/// MBUF pool used for allocating indirect buffers for the output fragments.
/// @return
/// Upon successful completion - number of output fragments placed
/// in the pkts_out array.
/// Otherwise - (-1) * errno.
    pub fn rte_ipv4_fragment_packet(pkt_in: *mut rte_mbuf,
                                    pkts_out: *mut *mut rte_mbuf,
                                    nb_pkts_out: u16, mtu_size: u16,
                                    pool_direct: *mut rte_mempool,
                                    pool_indirect: *mut rte_mempool) -> i32;
}
extern "C" {
    /// This function implements reassembly of fragmented IPv4 packets.
/// Incoming mbufs should have its l2_len/l3_len fields setup correclty.
///
/// @param tbl
/// Table where to lookup/add the fragmented packet.
/// @param dr
/// Death row to free buffers to
/// @param mb
/// Incoming mbuf with IPv4 fragment.
/// @param tms
/// Fragment arrival timestamp.
/// @param ip_hdr
/// Pointer to the IPV4 header inside the fragment.
/// @return
/// Pointer to mbuf for reassebled packet, or NULL if:
/// - an error occurred.
/// - not all fragments of the packet are collected yet.
    pub fn rte_ipv4_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl,
                                           dr: *mut rte_ip_frag_death_row,
                                           mb: *mut rte_mbuf, tms: u64,
                                           ip_hdr: *mut ipv4_hdr)
     -> *mut rte_mbuf;
}
extern "C" {
    /// Free mbufs on a given death row.
///
/// @param dr
/// Death row to free mbufs in.
/// @param prefetch
/// How many buffers to prefetch before freeing.
    pub fn rte_ip_frag_free_death_row(dr: *mut rte_ip_frag_death_row,
                                      prefetch: u32);
}
extern "C" {
    /// Dump fragmentation table statistics to file.
///
/// @param f
/// File to dump statistics to
/// @param tbl
/// Fragmentation table to dump statistics from
    pub fn rte_ip_frag_table_statistics_dump(f: *mut FILE,
                                             tbl: *const rte_ip_frag_tbl);
}
#[repr(C)]
#[derive(Copy)]
pub struct rte_jobstats_context {
    /// Variable holding time at different points:
    /// -# loop start time if loop was started but no job executed yet.
    /// -# job start time if job is currently executing.
    /// -# job finish time if job finished its execution.
    /// -# loop finish time if loop finished its execution.
    pub state_time: u64,
    pub loop_executed_jobs: u64,
    pub exec_time: u64,
    pub min_exec_time: u64,
    pub max_exec_time: u64,
    /// Sum of time that is not the execute time (ex: from job finish to next
    /// job start).
    ///
    /// This time might be considered as overhead of library + job scheduling.
    pub management_time: u64,
    pub min_management_time: u64,
    pub max_management_time: u64,
    pub start_time: u64,
    pub job_exec_cnt: u64,
    pub loop_cnt: u64,
    pub __bindgen_padding_0: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rte_jobstats_context() {
    assert_eq!(::std::mem::size_of::<rte_jobstats_context>() , 128usize ,
               concat ! ( "Size of: " , stringify ! ( rte_jobstats_context )
               ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . state_time as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( state_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) .
                loop_executed_jobs as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( loop_executed_jobs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . exec_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . min_exec_time
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( min_exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . max_exec_time
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( max_exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) .
                management_time as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( management_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) .
                min_management_time as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( min_management_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) .
                max_management_time as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( max_management_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . start_time as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . job_exec_cnt
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( job_exec_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats_context ) ) . loop_cnt as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats_context )
                , "::" , stringify ! ( loop_cnt ) ));
}
impl Clone for rte_jobstats_context {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rte_jobstats {
    pub period: u64,
    pub min_period: u64,
    pub max_period: u64,
    pub target: i64,
    pub update_period_cb: rte_job_update_period_cb_t,
    pub exec_time: u64,
    pub min_exec_time: u64,
    pub max_exec_time: u64,
    pub exec_cnt: u64,
    pub name: [::std::os::raw::c_char; 32usize],
    pub context: *mut rte_jobstats_context,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rte_jobstats() {
    assert_eq!(::std::mem::size_of::<rte_jobstats>() , 128usize , concat ! (
               "Size of: " , stringify ! ( rte_jobstats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . period as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . min_period as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( min_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . max_period as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( max_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . target as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . update_period_cb as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( update_period_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . exec_time as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . min_exec_time as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( min_exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . max_exec_time as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( max_exec_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . exec_cnt as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( exec_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . name as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_jobstats ) ) . context as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_jobstats ) , "::" ,
                stringify ! ( context ) ));
}
impl Clone for rte_jobstats {
    fn clone(&self) -> Self { *self }
}
/// This function should calculate new period and set it using
/// rte_jobstats_set_period() function. Time spent in this function will be
/// added to job's runtime.
///
/// @param job
/// The job data structure handler.
/// @param job_result
/// Result of calling job callback.
pub type rte_job_update_period_cb_t =
    ::std::option::Option<unsafe extern "C" fn(job: *mut rte_jobstats,
                                               job_result: i64)>;
extern "C" {
    /// Initialize given context object with default values.
///
/// @param ctx
/// Job stats context object to initialize.
///
/// @return
/// 0 on success
/// -EINVAL if *ctx* is NULL
    pub fn rte_jobstats_context_init(ctx: *mut rte_jobstats_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Mark that new set of jobs start executing.
///
/// @param ctx
/// Job stats context object.
    pub fn rte_jobstats_context_start(ctx: *mut rte_jobstats_context);
}
extern "C" {
    /// Mark that there is no more jobs ready to execute in this turn. Calculate
/// stats for this loop turn.
///
/// @param ctx
/// Job stats context.
    pub fn rte_jobstats_context_finish(ctx: *mut rte_jobstats_context);
}
extern "C" {
    /// Function resets job context statistics.
///
/// @param ctx
/// Job stats context which statistics will be reset.
    pub fn rte_jobstats_context_reset(ctx: *mut rte_jobstats_context);
}
extern "C" {
    /// Initialize given job stats object.
///
/// @param job
/// Job object.
/// @param name
/// Optional job name.
/// @param min_period
/// Minimum period that this job can accept.
/// @param max_period
/// Maximum period that this job can accept.
/// @param initial_period
/// Initial period. It will be checked against *min_period* and *max_period*.
/// @param target
/// Target value that this job try to achieve.
///
/// @return
/// 0 on success
/// -EINVAL if *job* is NULL
    pub fn rte_jobstats_init(job: *mut rte_jobstats,
                             name: *const ::std::os::raw::c_char,
                             min_period: u64, max_period: u64,
                             initial_period: u64, target: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set job desired target value. Difference between target and job value
/// value must be used to properly adjust job execute period value.
///
/// @param job
/// The job object.
/// @param target
/// New target.
    pub fn rte_jobstats_set_target(job: *mut rte_jobstats, target: i64);
}
extern "C" {
    /// Mark that *job* is starting of its execution in context of *ctx* object.
///
/// @param ctx
/// Job stats context.
/// @param job
/// Job object.
/// @return
/// 0 on success
/// -EINVAL if *ctx* or *job* is NULL or *job* is executing in another context
/// context already,
    pub fn rte_jobstats_start(ctx: *mut rte_jobstats_context,
                              job: *mut rte_jobstats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Mark that *job* finished its execution, but time of this work will be skipped
/// and added to management time.
///
/// @param job
/// Job object.
///
/// @return
/// 0 on success
/// -EINVAL if job is NULL or job was not started (it have no context).
    pub fn rte_jobstats_abort(job: *mut rte_jobstats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Mark that *job* finished its execution. Context in which it was executing
/// will receive stat update. After this function call *job* object is ready to
/// be executed in other context.
///
/// @param job
/// Job object.
/// @param job_value
/// Job value. Job should pass in this parameter a value that it try to optimize
/// for example the number of packets it processed.
///
/// @return
/// 0 if job's period was not updated (job target equals *job_value*)
/// 1 if job's period was updated
/// -EINVAL if job is NULL or job was not started (it have no context).
    pub fn rte_jobstats_finish(job: *mut rte_jobstats, job_value: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set execute period of given job.
///
/// @param job
/// The job object.
/// @param period
/// New period value.
/// @param saturate
/// If zero, skip period saturation to min, max range.
    pub fn rte_jobstats_set_period(job: *mut rte_jobstats, period: u64,
                                   saturate: u8);
}
extern "C" {
    /// Set minimum execute period of given job. Current period will be checked
/// against new minimum value.
///
/// @param job
/// The job object.
/// @param period
/// New minimum period value.
    pub fn rte_jobstats_set_min(job: *mut rte_jobstats, period: u64);
}
extern "C" {
    /// Set maximum execute period of given job. Current period will be checked
/// against new maximum value.
///
/// @param job
/// The job object.
/// @param period
/// New maximum period value.
    pub fn rte_jobstats_set_max(job: *mut rte_jobstats, period: u64);
}
extern "C" {
    /// Set update period callback that is invoked after job finish.
///
/// If application wants to do more sophisticated calculations than default
/// it can provide this handler.
///
/// @param job
/// Job object.
/// @param update_pedriod_cb
/// Callback to set. If NULL restore default update function.
    pub fn rte_jobstats_set_update_period_function(job: *mut rte_jobstats,
                                                   update_period_cb:
                                                       rte_job_update_period_cb_t);
}
extern "C" {
    /// Function resets job statistics.
///
/// @param job
/// Job which statistics will be reset.
    pub fn rte_jobstats_reset(job: *mut rte_jobstats);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_keepalive_state {
    RTE_KA_STATE_UNUSED = 0,
    RTE_KA_STATE_ALIVE = 1,
    RTE_KA_STATE_MISSING = 4,
    RTE_KA_STATE_DEAD = 2,
    RTE_KA_STATE_GONE = 3,
    RTE_KA_STATE_DOZING = 5,
    RTE_KA_STATE_SLEEP = 6,
}
/// Keepalive failure callback.
///
/// Receives a data pointer passed to rte_keepalive_create() and the id of the
/// failed core.
/// @param data Data pointer passed to rte_keepalive_create()
/// @param id_core ID of the core that has failed
pub type rte_keepalive_failure_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               id_core:
                                                   ::std::os::raw::c_int)>;
/// Keepalive relay callback.
///
/// Receives a data pointer passed to rte_keepalive_register_relay_callback(),
/// the id of the core for which state is to be forwarded, and details of the
/// current core state.
/// @param data Data pointer passed to rte_keepalive_register_relay_callback()
/// @param id_core ID of the core for which state is being reported
/// @param core_state The current state of the core
/// @param Timestamp of when core was last seen alive
pub type rte_keepalive_relay_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               id_core: ::std::os::raw::c_int,
                                               core_state:
                                                   rte_keepalive_state,
                                               last_seen: u64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_keepalive {
    _unused: [u8; 0],
}
extern "C" {
    /// Initialise keepalive sub-system.
/// @param callback
/// Function called upon detection of a dead core.
/// @param data
/// Data pointer to be passed to function callback.
/// @return
/// Keepalive structure success, NULL on failure.
    pub fn rte_keepalive_create(callback: rte_keepalive_failure_callback_t,
                                data: *mut ::std::os::raw::c_void)
     -> *mut rte_keepalive;
}
extern "C" {
    /// Checks & handles keepalive state of monitored cores.
/// @param *ptr_timer Triggering timer (unused)
/// @param *ptr_data  Data pointer (keepalive structure)
    pub fn rte_keepalive_dispatch_pings(ptr_timer:
                                            *mut ::std::os::raw::c_void,
                                        ptr_data:
                                            *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Registers a core for keepalive checks.
/// @param *keepcfg
/// Keepalive structure pointer
/// @param id_core
/// ID number of core to register.
    pub fn rte_keepalive_register_core(keepcfg: *mut rte_keepalive,
                                       id_core: ::std::os::raw::c_int);
}
extern "C" {
    /// Per-core keepalive check.
/// @param *keepcfg
/// Keepalive structure pointer
///
/// This function needs to be called from within the main process loop of
/// the LCore to be checked.
    pub fn rte_keepalive_mark_alive(keepcfg: *mut rte_keepalive);
}
extern "C" {
    /// Per-core sleep-time indication.
/// @param *keepcfg
/// Keepalive structure pointer
///
/// If CPU idling is enabled, this function needs to be called from within
/// the main process loop of the LCore going to sleep, in order to avoid
/// the LCore being mis-detected as dead.
    pub fn rte_keepalive_mark_sleep(keepcfg: *mut rte_keepalive);
}
extern "C" {
    /// Registers a 'live core' callback.
///
/// The complement of the 'dead core' callback. This is called when a
/// core is known to be alive, and is intended for cases when an app
/// needs to know 'liveness' beyond just knowing when a core has died.
///
/// @param *keepcfg
/// Keepalive structure pointer
/// @param callback
/// Function called upon detection of a dead core.
/// @param data
/// Data pointer to be passed to function callback.
    pub fn rte_keepalive_register_relay_callback(keepcfg: *mut rte_keepalive,
                                                 callback:
                                                     rte_keepalive_relay_callback_t,
                                                 data:
                                                     *mut ::std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_kni_req_id {
    RTE_KNI_REQ_UNKNOWN = 0,
    RTE_KNI_REQ_CHANGE_MTU = 1,
    RTE_KNI_REQ_CFG_NETWORK_IF = 2,
    RTE_KNI_REQ_MAX = 3,
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_kni_request {
    /// < Request id
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    /// < Result for processing request
    pub result: i32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_request__bindgen_ty_1 {
    /// < New MTU
    pub new_mtu: __BindgenUnionField<u32>,
    /// < 1: interface up, 0: interface down
    pub if_up: __BindgenUnionField<u8>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_kni_request__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_kni_request__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( rte_kni_request__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_kni_request__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_kni_request__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request__bindgen_ty_1 ) ) .
                new_mtu as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_kni_request__bindgen_ty_1 ) , "::" , stringify ! ( new_mtu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request__bindgen_ty_1 ) ) . if_up
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_kni_request__bindgen_ty_1 ) , "::" , stringify ! ( if_up )
                ));
}
impl Clone for rte_kni_request__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_kni_request() {
    assert_eq!(::std::mem::size_of::<rte_kni_request>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_kni_request ) ));
    assert_eq! (::std::mem::align_of::<rte_kni_request>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( rte_kni_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request ) ) . req_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_request ) ,
                "::" , stringify ! ( req_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request ) ) . result as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_request ) ,
                "::" , stringify ! ( result ) ));
}
impl Clone for rte_kni_request {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_fifo {
    /// < Next position to be written
    pub write: ::std::os::raw::c_uint,
    /// < Next position to be read
    pub read: ::std::os::raw::c_uint,
    /// < Circular buffer length
    pub len: ::std::os::raw::c_uint,
    /// < Pointer size - for 32/64 bit OS
    pub elem_size: ::std::os::raw::c_uint,
    /// < The buffer contains mbuf pointers
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(::std::mem::size_of::<rte_kni_fifo>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_kni_fifo ) ));
    assert_eq! (::std::mem::align_of::<rte_kni_fifo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_kni_fifo ) ));
}
impl Clone for rte_kni_fifo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_physaddr: u64,
    /// < Start address of data in segment buffer.
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    /// < Number of segments.
    pub nb_segs: u16,
    pub pad4: [::std::os::raw::c_char; 2usize],
    /// < Offload features.
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    /// < Total pkt len: sum of all segment data_len.
    pub pkt_len: u32,
    /// < Amount of data in segment buffer.
    pub data_len: u16,
    pub __bindgen_padding_0: [u8; 22usize],
    pub pad3: [::std::os::raw::c_char; 8usize],
    pub pool: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_1: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rte_kni_mbuf() {
    assert_eq!(::std::mem::size_of::<rte_kni_mbuf>() , 128usize , concat ! (
               "Size of: " , stringify ! ( rte_kni_mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . buf_addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( buf_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . buf_physaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( buf_physaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . data_off as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad1 as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . nb_segs as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( nb_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad4 as * const _ as
                usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . ol_flags as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( ol_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad2 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pkt_len as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pkt_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . data_len as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad3 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pool as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . next as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_mbuf ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for rte_kni_mbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_device_info {
    /// < Network device name for KNI
    pub name: [::std::os::raw::c_char; 32usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    /// < Vendor ID or PCI_ANY_ID.
    pub vendor_id: u16,
    /// < Device ID or PCI_ANY_ID.
    pub device_id: u16,
    /// < Device bus
    pub bus: u8,
    /// < Device ID
    pub devid: u8,
    /// < Device function.
    pub function: u8,
    /// < Group ID
    pub group_id: u16,
    /// < core ID to bind for kernel thread
    pub core_id: u32,
    pub _bitfield_1: u8,
    pub mbuf_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_kni_device_info() {
    assert_eq!(::std::mem::size_of::<rte_kni_device_info>() , 136usize ,
               concat ! ( "Size of: " , stringify ! ( rte_kni_device_info )
               ));
    assert_eq! (::std::mem::align_of::<rte_kni_device_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_kni_device_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . tx_phys as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( tx_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . rx_phys as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( rx_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . alloc_phys as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( alloc_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . free_phys as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( free_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . req_phys as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( req_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . resp_phys as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( resp_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . sync_phys as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( sync_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . sync_va as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( sync_va ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_va as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( mbuf_va ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_phys as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( mbuf_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . vendor_id as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . device_id as *
                const _ as usize } , 114usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . bus as * const
                _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . devid as *
                const _ as usize } , 117usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( devid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . function as *
                const _ as usize } , 118usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . group_id as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( group_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . core_id as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( core_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_size as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_device_info ) ,
                "::" , stringify ! ( mbuf_size ) ));
}
impl Clone for rte_kni_device_info {
    fn clone(&self) -> Self { *self }
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> u8 {
        ({ 0 } | ((force_bind as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni {
    _unused: [u8; 0],
}
/// Structure which has the function pointers for KNI interface.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_ops {
    pub port_id: u8,
    pub change_mtu: ::std::option::Option<unsafe extern "C" fn(port_id: u8,
                                                               new_mtu:
                                                                   ::std::os::raw::c_uint)
                                              -> ::std::os::raw::c_int>,
    pub config_network_if: ::std::option::Option<unsafe extern "C" fn(port_id:
                                                                          u8,
                                                                      if_up:
                                                                          u8)
                                                     ->
                                                         ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rte_kni_ops() {
    assert_eq!(::std::mem::size_of::<rte_kni_ops>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_kni_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_kni_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_kni_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . port_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_ops ) , "::" ,
                stringify ! ( port_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . change_mtu as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_ops ) , "::" ,
                stringify ! ( change_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . config_network_if as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_ops ) , "::" ,
                stringify ! ( config_network_if ) ));
}
impl Clone for rte_kni_ops {
    fn clone(&self) -> Self { *self }
}
/// Structure for configuring KNI device.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 32usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_kni_conf() {
    assert_eq!(::std::mem::size_of::<rte_kni_conf>() , 68usize , concat ! (
               "Size of: " , stringify ! ( rte_kni_conf ) ));
    assert_eq! (::std::mem::align_of::<rte_kni_conf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_kni_conf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . core_id as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( core_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . group_id as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( group_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . mbuf_size as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( mbuf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . addr as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . id as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_kni_conf ) , "::" ,
                stringify ! ( id ) ));
}
impl Clone for rte_kni_conf {
    fn clone(&self) -> Self { *self }
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> u8 {
        ({ 0 } | ((force_bind as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
extern "C" {
    /// Initialize and preallocate KNI subsystem
///
/// This function is to be executed on the MASTER lcore only, after EAL
/// initialization and before any KNI interface is attempted to be
/// allocated
///
/// @param max_kni_ifaces
/// The maximum number of KNI interfaces that can coexist concurrently
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint);
}
extern "C" {
    /// Allocate KNI interface according to the port id, mbuf size, mbuf pool,
/// configurations and callbacks for kernel requests.The KNI interface created
/// in the kernel space is the net interface the traditional Linux application
/// talking to.
///
/// The rte_kni_alloc shall not be called before rte_kni_init() has been
/// called. rte_kni_alloc is thread safe.
///
/// The mempool should have capacity of more than "2 x KNI_FIFO_COUNT_MAX"
/// elements for each KNI interface allocated.
///
/// @param pktmbuf_pool
/// The mempool for allocting mbufs for packets.
/// @param conf
/// The pointer to the configurations of the KNI device.
/// @param ops
/// The pointer to the callbacks for the KNI kernel requests.
///
/// @return
/// - The pointer to the context of a KNI interface.
/// - NULL indicate error.
    pub fn rte_kni_alloc(pktmbuf_pool: *mut rte_mempool,
                         conf: *const rte_kni_conf, ops: *mut rte_kni_ops)
     -> *mut rte_kni;
}
extern "C" {
    /// Release KNI interface according to the context. It will also release the
/// paired KNI interface in kernel space. All processing on the specific KNI
/// context need to be stopped before calling this interface.
///
/// rte_kni_release is thread safe.
///
/// @param kni
/// The pointer to the context of an existent KNI interface.
///
/// @return
/// - 0 indicates success.
/// - negative value indicates failure.
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It is used to handle the request mbufs sent from kernel space.
/// Then analyzes it and calls the specific actions for the specific requests.
/// Finally constructs the response mbuf and puts it back to the resp_q.
///
/// @param kni
/// The pointer to the context of an existent KNI interface.
///
/// @return
/// - 0
/// - negative value indicates failure.
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve a burst of packets from a KNI interface. The retrieved packets are
/// stored in rte_mbuf structures whose pointers are supplied in the array of
/// mbufs, and the maximum number is indicated by num. It handles allocating
/// the mbufs for KNI interface alloc queue.
///
/// @param kni
/// The KNI interface context.
/// @param mbufs
/// The array to store the pointers of mbufs.
/// @param num
/// The maximum number per burst.
///
/// @return
/// The actual number of packets retrieved.
    pub fn rte_kni_rx_burst(kni: *mut rte_kni, mbufs: *mut *mut rte_mbuf,
                            num: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Send a burst of packets to a KNI interface. The packets to be sent out are
/// stored in rte_mbuf structures whose pointers are supplied in the array of
/// mbufs, and the maximum number is indicated by num. It handles the freeing of
/// the mbufs in the free queue of KNI interface.
///
/// @param kni
/// The KNI interface context.
/// @param mbufs
/// The array to store the pointers of mbufs.
/// @param num
/// The maximum number per burst.
///
/// @return
/// The actual number of packets sent.
    pub fn rte_kni_tx_burst(kni: *mut rte_kni, mbufs: *mut *mut rte_mbuf,
                            num: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the KNI context of its name.
///
/// @param name
/// pointer to the KNI device name.
///
/// @return
/// On success: Pointer to KNI interface.
/// On failure: NULL.
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    /// Get the name given to a KNI device
///
/// @param kni
/// The KNI instance to query
/// @return
/// The pointer to the KNI name
    pub fn rte_kni_get_name(kni: *const rte_kni)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Register KNI request handling for a specified port,and it can
/// be called by master process or slave process.
///
/// @param kni
/// pointer to struct rte_kni.
/// @param ops
/// ponter to struct rte_kni_ops.
///
/// @return
/// On success: 0
/// On failure: -1
    pub fn rte_kni_register_handlers(kni: *mut rte_kni, ops: *mut rte_kni_ops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unregister KNI request handling for a specified port.
///
/// @param kni
/// pointer to struct rte_kni.
///
/// @return
/// On success: 0
/// On failure: -1
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close KNI device.
    pub fn rte_kni_close();
}
/// A name-key lookup for metrics.
///
/// An array of this structure is returned by rte_metrics_get_names().
/// The struct rte_metric_value references these names via their array index.
#[repr(C)]
pub struct rte_metric_name {
    /// String describing metric
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_metric_name() {
    assert_eq!(::std::mem::size_of::<rte_metric_name>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rte_metric_name ) ));
    assert_eq! (::std::mem::align_of::<rte_metric_name>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( rte_metric_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_metric_name ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_metric_name ) ,
                "::" , stringify ! ( name ) ));
}
/// Metric value structure.
///
/// This structure is used by rte_metrics_get_values() to return metrics,
/// which are statistics that are not generated by PMDs. It maps a name key,
/// which corresponds to an index in the array returned by
/// rte_metrics_get_names().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_metric_value {
    /// Numeric identifier of metric.
    pub key: u16,
    /// Value for metric
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_metric_value() {
    assert_eq!(::std::mem::size_of::<rte_metric_value>() , 16usize , concat !
               ( "Size of: " , stringify ! ( rte_metric_value ) ));
    assert_eq! (::std::mem::align_of::<rte_metric_value>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_metric_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_metric_value ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_metric_value ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_metric_value ) ) . value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_metric_value ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for rte_metric_value {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Initializes metric module. This function must be called from
/// a primary process before metrics are used.
///
/// @param socket_id
/// Socket to use for shared memory allocation.
    pub fn rte_metrics_init(socket_id: ::std::os::raw::c_int);
}
extern "C" {
    /// Register a metric, making it available as a reporting parameter.
///
/// Registering a metric is the way producers declare a parameter
/// that they wish to be reported. Once registered, the associated
/// numeric key can be obtained via rte_metrics_get_names(), which
/// is required for updating said metric's value.
///
/// @param name
/// Metric name. If this exceeds RTE_METRICS_MAX_NAME_LEN (including
/// the NULL terminator), it is truncated.
///
/// @return
/// - Zero or positive: Success (index key of new metric)
/// - -EIO: Error, unable to access metrics shared memory
/// (rte_metrics_init() not called)
/// - -EINVAL: Error, invalid parameters
/// - -ENOMEM: Error, maximum metrics reached
    pub fn rte_metrics_reg_name(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register a set of metrics.
///
/// This is a bulk version of rte_metrics_reg_names() and aside from
/// handling multiple keys at once is functionally identical.
///
/// @param names
/// List of metric names
///
/// @param cnt_names
/// Number of metrics in set
///
/// @return
/// - Zero or positive: Success (index key of start of set)
/// - -EIO: Error, unable to access metrics shared memory
/// (rte_metrics_init() not called)
/// - -EINVAL: Error, invalid parameters
/// - -ENOMEM: Error, maximum metrics reached
    pub fn rte_metrics_reg_names(names: *const *const ::std::os::raw::c_char,
                                 cnt_names: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get metric name-key lookup table.
///
/// @param names
/// A struct rte_metric_name array of at least *capacity* in size to
/// receive key names. If this is NULL, function returns the required
/// number of elements for this array.
///
/// @param capacity
/// Size (number of elements) of struct rte_metric_name array.
/// Disregarded if names is NULL.
///
/// @return
/// - Positive value above capacity: error, *names* is too small.
/// Return value is required size.
/// - Positive value equal or less than capacity: Success. Return
/// value is number of elements filled in.
/// - Negative value: error.
    pub fn rte_metrics_get_names(names: *mut rte_metric_name, capacity: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get metric value table.
///
/// @param port_id
/// Port id to query
///
/// @param values
/// A struct rte_metric_value array of at least *capacity* in size to
/// receive metric ids and values. If this is NULL, function returns
/// the required number of elements for this array.
///
/// @param capacity
/// Size (number of elements) of struct rte_metric_value array.
/// Disregarded if names is NULL.
///
/// @return
/// - Positive value above capacity: error, *values* is too small.
/// Return value is required size.
/// - Positive value equal or less than capacity: Success. Return
/// value is number of elements filled in.
/// - Negative value: error.
    pub fn rte_metrics_get_values(port_id: ::std::os::raw::c_int,
                                  values: *mut rte_metric_value,
                                  capacity: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates a metric
///
/// @param port_id
/// Port to update metrics for
/// @param key
/// Id of metric to update
/// @param value
/// New value
///
/// @return
/// - -EIO if unable to access shared metrics memory
/// - Zero on success
    pub fn rte_metrics_update_value(port_id: ::std::os::raw::c_int, key: u16,
                                    value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates a metric set. Note that it is an error to try to
/// update across a set boundary.
///
/// @param port_id
/// Port to update metrics for
/// @param key
/// Base id of metrics set to update
/// @param values
/// Set of new values
/// @param count
/// Number of new values
///
/// @return
/// - -ERANGE if count exceeds metric set size
/// - -EIO if unable to access shared metrics memory
/// - Zero on success
    pub fn rte_metrics_update_values(port_id: ::std::os::raw::c_int, key: u16,
                                     values: *const u64, count: u32)
     -> ::std::os::raw::c_int;
}
/// Note: This function pointer is for future flow based latency stats
/// implementation.
///
/// Function type used for identifting flow types of a Rx packet.
///
/// The callback function is called on Rx for each packet.
/// This function is used for flow based latency calculations.
///
/// @param pkt
/// Packet that has to be identified with its flow types.
/// @param user_param
/// The arbitrary user parameter passed in by the application when
/// the callback was originally configured.
/// @return
/// The flow_mask, representing the multiple flow types of a packet.
pub type rte_latency_stats_flow_type_fn =
    ::std::option::Option<unsafe extern "C" fn(pkt: *mut rte_mbuf,
                                               user_param:
                                                   *mut ::std::os::raw::c_void)
                              -> u16>;
extern "C" {
    /// Registers Rx/Tx callbacks for each active port, queue.
///
/// @param samp_intvl
/// Sampling time period in nano seconds, at which packet
/// should be marked with time stamp.
/// @param user_cb
/// Note: This param is for future flow based latency stats
/// implementation.
/// User callback to be called to get flow types of a packet.
/// Used for flow based latency calculation.
/// If the value is NULL, global stats will be calculated,
/// else flow based latency stats will be calculated.
/// For now just pass on the NULL value to this param.
/// @return
/// -1     : On error
/// -ENOMEM: On error
/// 0     : On success
    pub fn rte_latencystats_init(samp_intvl: u64,
                                 user_cb: rte_latency_stats_flow_type_fn)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates the latency and jitter values internally, exposing the updated
/// values via *rte_latencystats_get* or the rte_metrics API.
/// @return:
/// 0      : on Success
/// < 0    : Error in updating values.
    pub fn rte_latencystats_update() -> i32;
}
extern "C" {
    /// Removes registered Rx/Tx callbacks for each active port, queue.
///
/// @return
/// -1: On error
/// 0: On success
    pub fn rte_latencystats_uninit() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve names of latency statistics
///
/// @param names
/// Block of memory to insert names into. Must be at least size in capacity.
/// If set to NULL, function returns required capacity.
/// @param size
/// Capacity of latency stats names (number of names).
/// @return
/// - positive value lower or equal to size: success. The return value
/// is the number of entries filled in the stats table.
/// - positive value higher than size: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
    pub fn rte_latencystats_get_names(names: *mut rte_metric_name, size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve latency statistics.
///
/// @param values
/// A pointer to a table of structure of type *rte_metric_value*
/// to be filled with latency statistics ids and values.
/// This parameter can be set to NULL if size is 0.
/// @param size
/// The size of the stats table, which should be large enough to store
/// all the latency stats.
/// @return
/// - positive value lower or equal to size: success. The return value
/// is the number of entries filled in the stats table.
/// - positive value higher than size: error, the given statistics table
/// is too small. The return value corresponds to the size that should
/// be given to succeed. The entries in the table are not valid and
/// shall not be used by the caller.
/// -ENOMEM: On failure.
    pub fn rte_latencystats_get(values: *mut rte_metric_value, size: u16)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm6 {
    _unused: [u8; 0],
}
/// LPM configuration structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm6_config {
    /// < Max number of rules.
    pub max_rules: u32,
    /// < Number of tbl8s to allocate.
    pub number_tbl8s: u32,
    /// < This field is currently unused.
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_lpm6_config() {
    assert_eq!(::std::mem::size_of::<rte_lpm6_config>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm6_config ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm6_config>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_lpm6_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . max_rules as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm6_config ) ,
                "::" , stringify ! ( max_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . number_tbl8s as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm6_config ) ,
                "::" , stringify ! ( number_tbl8s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm6_config ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for rte_lpm6_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Create an LPM object.
///
/// @param name
/// LPM object name
/// @param socket_id
/// NUMA socket ID for LPM table memory allocation
/// @param config
/// Structure containing the configuration
/// @return
/// Handle to LPM object on success, NULL otherwise with rte_errno set
/// to an appropriate values. Possible rte_errno values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - invalid parameter passed to function
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_lpm6_create(name: *const ::std::os::raw::c_char,
                           socket_id: ::std::os::raw::c_int,
                           config: *const rte_lpm6_config) -> *mut rte_lpm6;
}
extern "C" {
    /// Find an existing LPM object and return a pointer to it.
///
/// @param name
/// Name of the lpm object as passed to rte_lpm6_create()
/// @return
/// Pointer to lpm object or NULL if object not found with rte_errno
/// set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
    pub fn rte_lpm6_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm6;
}
extern "C" {
    /// Free an LPM object.
///
/// @param lpm
/// LPM object handle
/// @return
/// None
    pub fn rte_lpm6_free(lpm: *mut rte_lpm6);
}
extern "C" {
    /// Add a rule to the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be added to the LPM table
/// @param depth
/// Depth of the rule to be added to the LPM table
/// @param next_hop
/// Next hop of the rule to be added to the LPM table
/// @return
/// 0 on success, negative value otherwise
    pub fn rte_lpm6_add(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8,
                        next_hop: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_add_v20(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8,
                            next_hop: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_add_v1705(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8,
                              next_hop: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if a rule is present in the LPM table,
/// and provide its next hop if it is.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be searched
/// @param depth
/// Depth of the rule to searched
/// @param next_hop
/// Next hop of the rule (valid only if it is found)
/// @return
/// 1 if the rule exists, 0 if it does not, a negative value on failure
    pub fn rte_lpm6_is_rule_present(lpm: *mut rte_lpm6, ip: *mut u8,
                                    depth: u8, next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_is_rule_present_v20(lpm: *mut rte_lpm6, ip: *mut u8,
                                        depth: u8, next_hop: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_is_rule_present_v1705(lpm: *mut rte_lpm6, ip: *mut u8,
                                          depth: u8, next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a rule from the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be deleted from the LPM table
/// @param depth
/// Depth of the rule to be deleted from the LPM table
/// @return
/// 0 on success, negative value otherwise
    pub fn rte_lpm6_delete(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a rule from the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ips
/// Array of IPs to be deleted from the LPM table
/// @param depths
/// Array of depths of the rules to be deleted from the LPM table
/// @param n
/// Number of rules to be deleted from the LPM table
/// @return
/// 0 on success, negative value otherwise.
    pub fn rte_lpm6_delete_bulk_func(lpm: *mut rte_lpm6,
                                     ips: *mut [u8; 16usize], depths: *mut u8,
                                     n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete all rules from the LPM table.
///
/// @param lpm
/// LPM object handle
    pub fn rte_lpm6_delete_all(lpm: *mut rte_lpm6);
}
extern "C" {
    /// Lookup an IP into the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP to be looked up in the LPM table
/// @param next_hop
/// Next hop of the most specific rule found for IP (valid on lookup hit only)
/// @return
/// -EINVAL for incorrect arguments, -ENOENT on lookup miss, 0 on lookup hit
    pub fn rte_lpm6_lookup(lpm: *const rte_lpm6, ip: *mut u8,
                           next_hop: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_lookup_v20(lpm: *const rte_lpm6, ip: *mut u8,
                               next_hop: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_lookup_v1705(lpm: *const rte_lpm6, ip: *mut u8,
                                 next_hop: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Lookup multiple IP addresses in an LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ips
/// Array of IPs to be looked up in the LPM table
/// @param next_hops
/// Next hop of the most specific rule found for IP (valid on lookup hit only).
/// This is an array of two byte values. The next hop will be stored on
/// each position on success; otherwise the position will be set to -1.
/// @param n
/// Number of elements in ips (and next_hops) array to lookup.
/// @return
/// -EINVAL for incorrect arguments, otherwise 0
    pub fn rte_lpm6_lookup_bulk_func(lpm: *const rte_lpm6,
                                     ips: *mut [u8; 16usize],
                                     next_hops: *mut i32,
                                     n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_lookup_bulk_func_v20(lpm: *const rte_lpm6,
                                         ips: *mut [u8; 16usize],
                                         next_hops: *mut i16,
                                         n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm6_lookup_bulk_func_v1705(lpm: *const rte_lpm6,
                                           ips: *mut [u8; 16usize],
                                           next_hops: *mut i32,
                                           n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
/// @internal Tbl24 entry structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry_v20 {
    pub __bindgen_anon_1: rte_lpm_tbl_entry_v20__bindgen_ty_1,
    pub _bitfield_1: u8,
}
/// Stores Next hop (tbl8 or tbl24 when valid_group is not set) or
/// a group index pointing to a tbl8 structure (tbl24 only, when
/// valid_group is set)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry_v20__bindgen_ty_1 {
    pub next_hop: __BindgenUnionField<u8>,
    pub group_idx: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry_v20__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry_v20__bindgen_ty_1>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm_tbl_entry_v20__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry_v20__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                rte_lpm_tbl_entry_v20__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_tbl_entry_v20__bindgen_ty_1 ) ) .
                next_hop as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_lpm_tbl_entry_v20__bindgen_ty_1 ) , "::" , stringify ! (
                next_hop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_tbl_entry_v20__bindgen_ty_1 ) ) .
                group_idx as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_lpm_tbl_entry_v20__bindgen_ty_1 ) , "::" , stringify ! (
                group_idx ) ));
}
impl Clone for rte_lpm_tbl_entry_v20__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry_v20>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( rte_lpm_tbl_entry_v20 )
               ));
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry_v20>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_lpm_tbl_entry_v20 ) ));
}
impl Clone for rte_lpm_tbl_entry_v20 {
    fn clone(&self) -> Self { *self }
}
impl rte_lpm_tbl_entry_v20 {
    #[inline]
    pub fn valid(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn valid_group(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_valid_group(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn depth(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 252u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u8) {
        let mask = 252u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(valid: u8, valid_group: u8, depth: u8) -> u8 {
        ({
             ({ ({ 0 } | ((valid as u8 as u8) << 0usize) & (1u64 as u8)) } |
                  ((valid_group as u8 as u8) << 1usize) & (2u64 as u8))
         } | ((depth as u8 as u8) << 2usize) & (252u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry>() , 4usize , concat !
               ( "Size of: " , stringify ! ( rte_lpm_tbl_entry ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_lpm_tbl_entry ) ));
}
impl Clone for rte_lpm_tbl_entry {
    fn clone(&self) -> Self { *self }
}
impl rte_lpm_tbl_entry {
    #[inline]
    pub fn next_hop(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777215u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_next_hop(&mut self, val: u32) {
        let mask = 16777215u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn valid(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777216u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        let mask = 16777216u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn valid_group(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 33554432u64 as u32;
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_valid_group(&mut self, val: u32) {
        let mask = 33554432u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn depth(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4227858432u64 as u32;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u32) {
        let mask = 4227858432u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(next_hop: u32, valid: u32, valid_group: u32,
                          depth: u32) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((next_hop as u32 as u32) << 0usize) &
                                (16777215u64 as u32))
                   } |
                       ((valid as u32 as u32) << 24usize) &
                           (16777216u64 as u32))
              } |
                  ((valid_group as u32 as u32) << 25usize) &
                      (33554432u64 as u32))
         } | ((depth as u32 as u32) << 26usize) & (4227858432u64 as u32))
    }
}
/// LPM configuration structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_config {
    /// < Max number of rules.
    pub max_rules: u32,
    /// < Number of tbl8s to allocate.
    pub number_tbl8s: u32,
    /// < This field is currently unused.
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_lpm_config() {
    assert_eq!(::std::mem::size_of::<rte_lpm_config>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm_config ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_config>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_lpm_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . max_rules as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_config ) , "::"
                , stringify ! ( max_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . number_tbl8s as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_config ) , "::"
                , stringify ! ( number_tbl8s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_config ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for rte_lpm_config {
    fn clone(&self) -> Self { *self }
}
/// @internal Rule structure.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule_v20 {
    /// < Rule IP address.
    pub ip: u32,
    /// < Rule next hop.
    pub next_hop: u8,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule_v20>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm_rule_v20 ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_rule_v20>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_lpm_rule_v20 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_v20 ) ) . ip as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule_v20 ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_v20 ) ) . next_hop as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule_v20 ) ,
                "::" , stringify ! ( next_hop ) ));
}
impl Clone for rte_lpm_rule_v20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule {
    /// < Rule IP address.
    pub ip: u32,
    /// < Rule next hop.
    pub next_hop: u32,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm_rule ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_rule>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_lpm_rule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule ) ) . ip as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule ) , "::" ,
                stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule ) ) . next_hop as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule ) , "::" ,
                stringify ! ( next_hop ) ));
}
impl Clone for rte_lpm_rule {
    fn clone(&self) -> Self { *self }
}
/// @internal Contains metadata about the rules table.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule_info {
    /// < Used rules so far.
    pub used_rules: u32,
    /// < Indexes the first rule of a given depth.
    pub first_rule: u32,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule_info() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule_info>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_lpm_rule_info ) ));
    assert_eq! (::std::mem::align_of::<rte_lpm_rule_info>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_lpm_rule_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_info ) ) . used_rules as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule_info ) ,
                "::" , stringify ! ( used_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_info ) ) . first_rule as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm_rule_info ) ,
                "::" , stringify ! ( first_rule ) ));
}
impl Clone for rte_lpm_rule_info {
    fn clone(&self) -> Self { *self }
}
/// @internal LPM structure.
#[repr(C)]
pub struct rte_lpm_v20 {
    /// < Name of the lpm.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Max. balanced rules per lpm.
    pub max_rules: u32,
    /// < Rule info table.
    pub rule_info: [rte_lpm_rule_info; 32usize],
    pub tbl24: [rte_lpm_tbl_entry_v20; 16777216usize],
    pub tbl8: [rte_lpm_tbl_entry_v20; 65536usize],
    pub rules_tbl: __IncompleteArrayField<rte_lpm_rule_v20>,
    pub __bindgen_padding_0: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_rte_lpm_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_v20>() , 33685824usize , concat !
               ( "Size of: " , stringify ! ( rte_lpm_v20 ) ));
}
#[repr(C)]
pub struct rte_lpm {
    /// < Name of the lpm.
    pub name: [::std::os::raw::c_char; 32usize],
    /// < Max. balanced rules per lpm.
    pub max_rules: u32,
    /// < Number of tbl8s.
    pub number_tbl8s: u32,
    /// < Rule info table.
    pub rule_info: [rte_lpm_rule_info; 32usize],
    pub __bindgen_padding_0: [u32; 6usize],
    pub tbl24: [rte_lpm_tbl_entry; 16777216usize],
    /// < LPM tbl8 table.
    pub tbl8: *mut rte_lpm_tbl_entry,
    /// < LPM rules.
    pub rules_tbl: *mut rte_lpm_rule,
    pub __bindgen_padding_1: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_lpm() {
    assert_eq!(::std::mem::size_of::<rte_lpm>() , 67109248usize , concat ! (
               "Size of: " , stringify ! ( rte_lpm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . max_rules as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( max_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . number_tbl8s as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( number_tbl8s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . rule_info as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( rule_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . tbl24 as * const _ as usize
                } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( tbl24 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . tbl8 as * const _ as usize
                } , 67109184usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( tbl8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . rules_tbl as * const _ as
                usize } , 67109192usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_lpm ) , "::" ,
                stringify ! ( rules_tbl ) ));
}
extern "C" {
    /// Create an LPM object.
///
/// @param name
/// LPM object name
/// @param socket_id
/// NUMA socket ID for LPM table memory allocation
/// @param config
/// Structure containing the configuration
/// @return
/// Handle to LPM object on success, NULL otherwise with rte_errno set
/// to an appropriate values. Possible rte_errno values include:
/// - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
/// - E_RTE_SECONDARY - function was called from a secondary process instance
/// - EINVAL - invalid parameter passed to function
/// - ENOSPC - the maximum number of memzones has already been allocated
/// - EEXIST - a memzone with the same name already exists
/// - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_lpm_create(name: *const ::std::os::raw::c_char,
                          socket_id: ::std::os::raw::c_int,
                          config: *const rte_lpm_config) -> *mut rte_lpm;
}
extern "C" {
    pub fn rte_lpm_create_v20(name: *const ::std::os::raw::c_char,
                              socket_id: ::std::os::raw::c_int,
                              max_rules: ::std::os::raw::c_int,
                              flags: ::std::os::raw::c_int)
     -> *mut rte_lpm_v20;
}
extern "C" {
    pub fn rte_lpm_create_v1604(name: *const ::std::os::raw::c_char,
                                socket_id: ::std::os::raw::c_int,
                                config: *const rte_lpm_config)
     -> *mut rte_lpm;
}
extern "C" {
    /// Find an existing LPM object and return a pointer to it.
///
/// @param name
/// Name of the lpm object as passed to rte_lpm_create()
/// @return
/// Pointer to lpm object or NULL if object not found with rte_errno
/// set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
    pub fn rte_lpm_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm;
}
extern "C" {
    pub fn rte_lpm_find_existing_v20(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm_v20;
}
extern "C" {
    pub fn rte_lpm_find_existing_v1604(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm;
}
extern "C" {
    /// Free an LPM object.
///
/// @param lpm
/// LPM object handle
/// @return
/// None
    pub fn rte_lpm_free(lpm: *mut rte_lpm);
}
extern "C" {
    pub fn rte_lpm_free_v20(lpm: *mut rte_lpm_v20);
}
extern "C" {
    pub fn rte_lpm_free_v1604(lpm: *mut rte_lpm);
}
extern "C" {
    /// Add a rule to the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be added to the LPM table
/// @param depth
/// Depth of the rule to be added to the LPM table
/// @param next_hop
/// Next hop of the rule to be added to the LPM table
/// @return
/// 0 on success, negative value otherwise
    pub fn rte_lpm_add(lpm: *mut rte_lpm, ip: u32, depth: u8, next_hop: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_add_v20(lpm: *mut rte_lpm_v20, ip: u32, depth: u8,
                           next_hop: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_add_v1604(lpm: *mut rte_lpm, ip: u32, depth: u8,
                             next_hop: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if a rule is present in the LPM table,
/// and provide its next hop if it is.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be searched
/// @param depth
/// Depth of the rule to searched
/// @param next_hop
/// Next hop of the rule (valid only if it is found)
/// @return
/// 1 if the rule exists, 0 if it does not, a negative value on failure
    pub fn rte_lpm_is_rule_present(lpm: *mut rte_lpm, ip: u32, depth: u8,
                                   next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_is_rule_present_v20(lpm: *mut rte_lpm_v20, ip: u32,
                                       depth: u8, next_hop: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_is_rule_present_v1604(lpm: *mut rte_lpm, ip: u32,
                                         depth: u8, next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete a rule from the LPM table.
///
/// @param lpm
/// LPM object handle
/// @param ip
/// IP of the rule to be deleted from the LPM table
/// @param depth
/// Depth of the rule to be deleted from the LPM table
/// @return
/// 0 on success, negative value otherwise
    pub fn rte_lpm_delete(lpm: *mut rte_lpm, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_delete_v20(lpm: *mut rte_lpm_v20, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_delete_v1604(lpm: *mut rte_lpm, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete all rules from the LPM table.
///
/// @param lpm
/// LPM object handle
    pub fn rte_lpm_delete_all(lpm: *mut rte_lpm);
}
extern "C" {
    pub fn rte_lpm_delete_all_v20(lpm: *mut rte_lpm_v20);
}
extern "C" {
    pub fn rte_lpm_delete_all_v1604(lpm: *mut rte_lpm);
}
#[repr(u32)]
/// Packet Color Set
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_meter_color {
    e_RTE_METER_GREEN = 0,
    e_RTE_METER_YELLOW = 1,
    e_RTE_METER_RED = 2,
    e_RTE_METER_COLORS = 3,
}
/// srTCM parameters per metered traffic flow. The CIR, CBS and EBS parameters only
/// count bytes of IP packets and do not include link specific headers. At least one of
/// the CBS or EBS parameters has to be greater than zero.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_srtcm_params {
    /// < Committed Information Rate (CIR). Measured in bytes per second.
    pub cir: u64,
    /// < Committed Burst Size (CBS).  Measured in bytes.
    pub cbs: u64,
    /// < Excess Burst Size (EBS).  Measured in bytes.
    pub ebs: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_srtcm_params() {
    assert_eq!(::std::mem::size_of::<rte_meter_srtcm_params>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_meter_srtcm_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_meter_srtcm_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_meter_srtcm_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . cir as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm_params
                ) , "::" , stringify ! ( cir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . cbs as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm_params
                ) , "::" , stringify ! ( cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . ebs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm_params
                ) , "::" , stringify ! ( ebs ) ));
}
impl Clone for rte_meter_srtcm_params {
    fn clone(&self) -> Self { *self }
}
/// trTCM parameters per metered traffic flow. The CIR, PIR, CBS and PBS parameters
/// only count bytes of IP packets and do not include link specific headers. PIR has to
/// be greater than or equal to CIR. Both CBS or EBS have to be greater than zero.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_trtcm_params {
    /// < Committed Information Rate (CIR). Measured in bytes per second.
    pub cir: u64,
    /// < Peak Information Rate (PIR). Measured in bytes per second.
    pub pir: u64,
    /// < Committed Burst Size (CBS). Measured in byes.
    pub cbs: u64,
    /// < Peak Burst Size (PBS). Measured in bytes.
    pub pbs: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_trtcm_params() {
    assert_eq!(::std::mem::size_of::<rte_meter_trtcm_params>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rte_meter_trtcm_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_meter_trtcm_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_meter_trtcm_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . cir as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm_params
                ) , "::" , stringify ! ( cir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . pir as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm_params
                ) , "::" , stringify ! ( pir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . cbs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm_params
                ) , "::" , stringify ! ( cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . pbs as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm_params
                ) , "::" , stringify ! ( pbs ) ));
}
impl Clone for rte_meter_trtcm_params {
    fn clone(&self) -> Self { *self }
}
/// Internal data structure storing the srTCM run-time context per metered traffic flow.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_srtcm {
    pub time: u64,
    pub tc: u64,
    pub te: u64,
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_srtcm() {
    assert_eq!(::std::mem::size_of::<rte_meter_srtcm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rte_meter_srtcm ) ));
    assert_eq! (::std::mem::align_of::<rte_meter_srtcm>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_meter_srtcm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . time as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . tc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . te as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( te ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . cbs as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . ebs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( ebs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . cir_period as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( cir_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) .
                cir_bytes_per_period as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_srtcm ) ,
                "::" , stringify ! ( cir_bytes_per_period ) ));
}
impl Clone for rte_meter_srtcm {
    fn clone(&self) -> Self { *self }
}
/// Internal data structure storing the trTCM run-time context per metered traffic flow.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_trtcm {
    pub time_tc: u64,
    pub time_tp: u64,
    pub tc: u64,
    pub tp: u64,
    pub cbs: u64,
    pub pbs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub pir_period: u64,
    pub pir_bytes_per_period: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_trtcm() {
    assert_eq!(::std::mem::size_of::<rte_meter_trtcm>() , 80usize , concat ! (
               "Size of: " , stringify ! ( rte_meter_trtcm ) ));
    assert_eq! (::std::mem::align_of::<rte_meter_trtcm>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_meter_trtcm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . time_tc as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( time_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . time_tp as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( time_tp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . tc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . tp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( tp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . cbs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( cbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . pbs as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( pbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . cir_period as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( cir_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) .
                cir_bytes_per_period as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( cir_bytes_per_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . pir_period as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( pir_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) .
                pir_bytes_per_period as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_meter_trtcm ) ,
                "::" , stringify ! ( pir_bytes_per_period ) ));
}
impl Clone for rte_meter_trtcm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// srTCM configuration per metered traffic flow
///
/// @param m
/// Pointer to pre-allocated srTCM data structure
/// @param params
/// User parameters per srTCM metered traffic flow
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_meter_srtcm_config(m: *mut rte_meter_srtcm,
                                  params: *mut rte_meter_srtcm_params)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// trTCM configuration per metered traffic flow
///
/// @param m
/// Pointer to pre-allocated trTCM data structure
/// @param params
/// User parameters per trTCM metered traffic flow
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_meter_trtcm_config(m: *mut rte_meter_trtcm,
                                  params: *mut rte_meter_trtcm_params)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// CRC types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_net_crc_type {
    RTE_NET_CRC16_CCITT = 0,
    RTE_NET_CRC32_ETH = 1,
    RTE_NET_CRC_REQS = 2,
}
#[repr(u32)]
/// CRC compute algorithm
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_net_crc_alg {
    RTE_NET_CRC_SCALAR = 0,
    RTE_NET_CRC_SSE42 = 1,
    RTE_NET_CRC_NEON = 2,
}
extern "C" {
    /// This API set the CRC computation algorithm (i.e. scalar version,
/// x86 64-bit sse4.2 intrinsic version, etc.) and internal data
/// structure.
///
/// @param alg
/// This parameter is used to select the CRC implementation version.
/// - RTE_NET_CRC_SCALAR
/// - RTE_NET_CRC_SSE42 (Use 64-bit SSE4.2 intrinsic)
/// - RTE_NET_CRC_NEON (Use ARM Neon intrinsic)
    pub fn rte_net_crc_set_alg(alg: rte_net_crc_alg);
}
extern "C" {
    /// CRC compute API
///
/// @param data
/// Pointer to the packet data for CRC computation
/// @param data_len
/// Data length for CRC computation
/// @param type
/// CRC type (enum rte_net_crc_type)
///
/// @return
/// CRC value
    pub fn rte_net_crc_calc(data: *const ::std::os::raw::c_void,
                            data_len: u32, type_: rte_net_crc_type) -> u32;
}
/// Structure containing header lengths associated to a packet, filled
/// by rte_net_get_ptype().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_net_hdr_lens {
    pub l2_len: u8,
    pub l3_len: u8,
    pub l4_len: u8,
    pub tunnel_len: u8,
    pub inner_l2_len: u8,
    pub inner_l3_len: u8,
    pub inner_l4_len: u8,
}
#[test]
fn bindgen_test_layout_rte_net_hdr_lens() {
    assert_eq!(::std::mem::size_of::<rte_net_hdr_lens>() , 7usize , concat ! (
               "Size of: " , stringify ! ( rte_net_hdr_lens ) ));
    assert_eq! (::std::mem::align_of::<rte_net_hdr_lens>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( rte_net_hdr_lens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l2_len as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( l2_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l3_len as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( l3_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l4_len as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( l4_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . tunnel_len as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( tunnel_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l2_len as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( inner_l2_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l3_len as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( inner_l3_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l4_len as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_net_hdr_lens ) ,
                "::" , stringify ! ( inner_l4_len ) ));
}
impl Clone for rte_net_hdr_lens {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Parse an Ethernet packet to get its packet type.
///
/// This function parses the network headers in mbuf data and return its
/// packet type.
///
/// If it is provided by the user, it also fills a rte_net_hdr_lens
/// structure that contains the lengths of the parsed network
/// headers. Each length field is valid only if the associated packet
/// type is set. For instance, hdr_lens->l2_len is valid only if
/// (retval & RTE_PTYPE_L2_MASK) != RTE_PTYPE_UNKNOWN.
///
/// Supported packet types are:
/// L2: Ether, Vlan, QinQ
/// L3: IPv4, IPv6
/// L4: TCP, UDP, SCTP
/// Tunnels: IPv4, IPv6, Gre, Nvgre
///
/// @param m
/// The packet mbuf to be parsed.
/// @param hdr_lens
/// A pointer to a structure where the header lengths will be returned,
/// or NULL.
/// @param layers
/// List of layers to parse. The function will stop at the first
/// empty layer. Examples:
/// - To parse all known layers, use RTE_PTYPE_ALL_MASK.
/// - To parse only L2 and L3, use RTE_PTYPE_L2_MASK | RTE_PTYPE_L3_MASK
/// @return
/// The packet type of the packet.
    pub fn rte_net_get_ptype(m: *const rte_mbuf,
                             hdr_lens: *mut rte_net_hdr_lens, layers: u32)
     -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_intr_mode {
    RTE_INTR_MODE_NONE = 0,
    RTE_INTR_MODE_LEGACY = 1,
    RTE_INTR_MODE_MSI = 2,
    RTE_INTR_MODE_MSIX = 3,
}
pub const RTE_PDUMP_FLAG_RX: _bindgen_ty_25 =
    _bindgen_ty_25::RTE_PDUMP_FLAG_RX;
pub const RTE_PDUMP_FLAG_TX: _bindgen_ty_25 =
    _bindgen_ty_25::RTE_PDUMP_FLAG_TX;
pub const RTE_PDUMP_FLAG_RXTX: _bindgen_ty_25 =
    _bindgen_ty_25::RTE_PDUMP_FLAG_RXTX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    RTE_PDUMP_FLAG_RX = 1,
    RTE_PDUMP_FLAG_TX = 2,
    RTE_PDUMP_FLAG_RXTX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pdump_socktype {
    RTE_PDUMP_SOCKET_SERVER = 1,
    RTE_PDUMP_SOCKET_CLIENT = 2,
}
extern "C" {
    /// Initialize packet capturing handling
///
/// Creates pthread and server socket for handling clients
/// requests to enable/disable rxtx callbacks.
///
/// @param path
/// directory path for server socket.
///
/// @return
/// 0 on success, -1 on error
    pub fn rte_pdump_init(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Un initialize packet capturing handling
///
/// Cancels pthread, close server socket, removes server socket address.
///
/// @return
/// 0 on success, -1 on error
    pub fn rte_pdump_uninit() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enables packet capturing on given port and queue.
///
/// @param port
/// port on which packet capturing should be enabled.
/// @param queue
/// queue of a given port on which packet capturing should be enabled.
/// users should pass on value UINT16_MAX to enable packet capturing on all
/// queues of a given port.
/// @param flags
/// flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
/// on which packet capturing should be enabled for a given port and queue.
/// @param ring
/// ring on which captured packets will be enqueued for user.
/// @param mp
/// mempool on to which original packets will be mirrored or duplicated.
/// @param filter
/// place holder for packet filtering.
///
/// @return
/// 0 on success, -1 on error, rte_errno is set accordingly.
    pub fn rte_pdump_enable(port: u8, queue: u16, flags: u32,
                            ring: *mut rte_ring, mp: *mut rte_mempool,
                            filter: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disables packet capturing on given port and queue.
///
/// @param port
/// port on which packet capturing should be disabled.
/// @param queue
/// queue of a given port on which packet capturing should be disabled.
/// users should pass on value UINT16_MAX to disable packet capturing on all
/// queues of a given port.
/// @param flags
/// flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
/// on which packet capturing should be enabled for a given port and queue.
///
/// @return
/// 0 on success, -1 on error, rte_errno is set accordingly.
    pub fn rte_pdump_disable(port: u8, queue: u16, flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enables packet capturing on given device id and queue.
/// device_id can be name or pci address of device.
///
/// @param device_id
/// device id on which packet capturing should be enabled.
/// @param queue
/// queue of a given device id on which packet capturing should be enabled.
/// users should pass on value UINT16_MAX to enable packet capturing on all
/// queues of a given device id.
/// @param flags
/// flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
/// on which packet capturing should be enabled for a given port and queue.
/// @param ring
/// ring on which captured packets will be enqueued for user.
/// @param mp
/// mempool on to which original packets will be mirrored or duplicated.
/// @param filter
/// place holder for packet filtering.
///
/// @return
/// 0 on success, -1 on error, rte_errno is set accordingly.
    pub fn rte_pdump_enable_by_deviceid(device_id:
                                            *mut ::std::os::raw::c_char,
                                        queue: u16, flags: u32,
                                        ring: *mut rte_ring,
                                        mp: *mut rte_mempool,
                                        filter: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disables packet capturing on given device_id and queue.
/// device_id can be name or pci address of device.
///
/// @param device_id
/// pci address or name of the device on which packet capturing
/// should be disabled.
/// @param queue
/// queue of a given device on which packet capturing should be disabled.
/// users should pass on value UINT16_MAX to disable packet capturing on all
/// queues of a given device id.
/// @param flags
/// flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
/// on which packet capturing should be enabled for a given port and queue.
///
/// @return
/// 0 on success, -1 on error, rte_errno is set accordingly.
    pub fn rte_pdump_disable_by_deviceid(device_id:
                                             *mut ::std::os::raw::c_char,
                                         queue: u16, flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allows applications to set server and client socket paths.
/// If specified path is null default path will be selected, i.e.
/// "/var/run/" for root user and "$HOME" for non root user.
/// Clients also need to call this API to set their server path if the
/// server path is different from default path.
/// This API is not thread-safe.
///
/// @param path
/// directory path for server or client socket.
/// @param type
/// specifies RTE_PDUMP_SOCKET_SERVER if socket path is for server.
/// (or)
/// specifies RTE_PDUMP_SOCKET_CLIENT if socket path is for client.
///
/// @return
/// 0 on success, -EINVAL on error
///
    pub fn rte_pdump_set_socket_dir(path: *const ::std::os::raw::c_char,
                                    type_: rte_pdump_socktype)
     -> ::std::os::raw::c_int;
}
/// Input port statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_in_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[test]
fn bindgen_test_layout_rte_port_in_stats() {
    assert_eq!(::std::mem::size_of::<rte_port_in_stats>() , 16usize , concat !
               ( "Size of: " , stringify ! ( rte_port_in_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_port_in_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_port_in_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_stats ) ,
                "::" , stringify ! ( n_pkts_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_stats ) ) . n_pkts_drop as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_stats ) ,
                "::" , stringify ! ( n_pkts_drop ) ));
}
impl Clone for rte_port_in_stats {
    fn clone(&self) -> Self { *self }
}
/// Input port create
///
/// @param params
/// Parameters for input port creation
/// @param socket_id
/// CPU socket ID (e.g. for memory allocation purpose)
/// @return
/// Handle to input port instance
pub type rte_port_in_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
/// Input port free
///
/// @param port
/// Handle to input port instance
/// @return
/// 0 on success, error code otherwise
pub type rte_port_in_op_free =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Input port packet burst RX
///
/// @param port
/// Handle to input port instance
/// @param pkts
/// Burst of input packets
/// @param n_pkts
/// Number of packets in the input burst
/// @return
/// 0 on success, error code otherwise
pub type rte_port_in_op_rx =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkts: *mut *mut rte_mbuf,
                                               n_pkts: u32)
                              -> ::std::os::raw::c_int>;
/// Input port stats get
///
/// @param port
/// Handle to output port instance
/// @param stats
/// Handle to port_in stats struct to copy data
/// @param clear
/// Flag indicating that stats should be cleared after read
///
/// @return
/// Error code or 0 on success.
pub type rte_port_in_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_port_in_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/// Input port interface defining the input port operation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_in_ops {
    /// < Create
    pub f_create: rte_port_in_op_create,
    /// < Free
    pub f_free: rte_port_in_op_free,
    /// < Packet RX (packet burst)
    pub f_rx: rte_port_in_op_rx,
    /// < Stats
    pub f_stats: rte_port_in_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_port_in_ops() {
    assert_eq!(::std::mem::size_of::<rte_port_in_ops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rte_port_in_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_port_in_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_port_in_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_create as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_ops ) ,
                "::" , stringify ! ( f_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_free as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_ops ) ,
                "::" , stringify ! ( f_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_rx as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_ops ) ,
                "::" , stringify ! ( f_rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_stats as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_in_ops ) ,
                "::" , stringify ! ( f_stats ) ));
}
impl Clone for rte_port_in_ops {
    fn clone(&self) -> Self { *self }
}
/// Output port statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_out_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[test]
fn bindgen_test_layout_rte_port_out_stats() {
    assert_eq!(::std::mem::size_of::<rte_port_out_stats>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_port_out_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_port_out_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_port_out_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_stats ) ,
                "::" , stringify ! ( n_pkts_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_stats ) ) . n_pkts_drop as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_stats ) ,
                "::" , stringify ! ( n_pkts_drop ) ));
}
impl Clone for rte_port_out_stats {
    fn clone(&self) -> Self { *self }
}
/// Output port create
///
/// @param params
/// Parameters for output port creation
/// @param socket_id
/// CPU socket ID (e.g. for memory allocation purpose)
/// @return
/// Handle to output port instance
pub type rte_port_out_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
/// Output port free
///
/// @param port
/// Handle to output port instance
/// @return
/// 0 on success, error code otherwise
pub type rte_port_out_op_free =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Output port single packet TX
///
/// @param port
/// Handle to output port instance
/// @param pkt
/// Input packet
/// @return
/// 0 on success, error code otherwise
pub type rte_port_out_op_tx =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkt: *mut rte_mbuf)
                              -> ::std::os::raw::c_int>;
/// Output port packet burst TX
///
/// @param port
/// Handle to output port instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param pkts_mask
/// 64-bit bitmask specifying which packets in the input burst are valid. When
/// pkts_mask bit n is set, then element n of pkts array is pointing to a
/// valid packet. Otherwise, element n of pkts array will not be accessed.
/// @return
/// 0 on success, error code otherwise
pub type rte_port_out_op_tx_bulk =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkt: *mut *mut rte_mbuf,
                                               pkts_mask: u64)
                              -> ::std::os::raw::c_int>;
/// Output port flush
///
/// @param port
/// Handle to output port instance
/// @return
/// 0 on success, error code otherwise
pub type rte_port_out_op_flush =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Output port stats read
///
/// @param port
/// Handle to output port instance
/// @param stats
/// Handle to port_out stats struct to copy data
/// @param clear
/// Flag indicating that stats should be cleared after read
///
/// @return
/// Error code or 0 on success.
pub type rte_port_out_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_port_out_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/// Output port interface defining the output port operation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_out_ops {
    /// < Create
    pub f_create: rte_port_out_op_create,
    /// < Free
    pub f_free: rte_port_out_op_free,
    /// < Packet TX (single packet)
    pub f_tx: rte_port_out_op_tx,
    /// < Packet TX (packet burst)
    pub f_tx_bulk: rte_port_out_op_tx_bulk,
    /// < Flush
    pub f_flush: rte_port_out_op_flush,
    /// < Stats
    pub f_stats: rte_port_out_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_port_out_ops() {
    assert_eq!(::std::mem::size_of::<rte_port_out_ops>() , 48usize , concat !
               ( "Size of: " , stringify ! ( rte_port_out_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_port_out_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_port_out_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_create as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_free as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_tx as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_tx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_tx_bulk as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_tx_bulk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_flush as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_stats as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_out_ops ) ,
                "::" , stringify ! ( f_stats ) ));
}
impl Clone for rte_port_out_ops {
    fn clone(&self) -> Self { *self }
}
/// Lookup table statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_stats {
    pub n_pkts_in: u64,
    pub n_pkts_lookup_miss: u64,
}
#[test]
fn bindgen_test_layout_rte_table_stats() {
    assert_eq!(::std::mem::size_of::<rte_table_stats>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_table_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_table_stats>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_table_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_stats ) ,
                "::" , stringify ! ( n_pkts_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_stats ) ) . n_pkts_lookup_miss
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_stats ) ,
                "::" , stringify ! ( n_pkts_lookup_miss ) ));
}
impl Clone for rte_table_stats {
    fn clone(&self) -> Self { *self }
}
/// Lookup table create
///
/// @param params
/// Parameters for lookup table creation. The underlying data structure is
/// different for each lookup table type.
/// @param socket_id
/// CPU socket ID (e.g. for memory allocation purpose)
/// @param entry_size
/// Data size of each lookup table entry (measured in bytes)
/// @return
/// Handle to lookup table instance
pub type rte_table_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int,
                                               entry_size: u32)
                              -> *mut ::std::os::raw::c_void>;
/// Lookup table free
///
/// @param table
/// Handle to lookup table instance
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_free =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table entry add
///
/// @param table
/// Handle to lookup table instance
/// @param key
/// Lookup key
/// @param entry
/// Data to be associated with the current key. This parameter has to point to
/// a valid memory buffer where the first entry_size bytes (table create
/// parameter) are populated with the data.
/// @param key_found
/// After successful invocation, *key_found is set to a value different than 0
/// if the current key is already present in the table and to 0 if not. This
/// pointer has to be set to a valid memory location before the table entry add
/// function is called.
/// @param entry_ptr
/// After successful invocation, *entry_ptr stores the handle to the table
/// entry containing the data associated with the current key. This handle can
/// be used to perform further read-write accesses to this entry. This handle
/// is valid until the key is deleted from the table or the same key is
/// re-added to the table, typically to associate it with different data. This
/// pointer has to be set to a valid memory location before the function is
/// called.
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_entry_add =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               key:
                                                   *mut ::std::os::raw::c_void,
                                               entry:
                                                   *mut ::std::os::raw::c_void,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entry_ptr:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table entry delete
///
/// @param table
/// Handle to lookup table instance
/// @param key
/// Lookup key
/// @param key_found
/// After successful invocation, *key_found is set to a value different than 0
/// if the current key was present in the table before the delete operation
/// was performed and to 0 if not. This pointer has to be set to a valid
/// memory location before the table entry delete function is called.
/// @param entry
/// After successful invocation, if the key is found in the table (*key found
/// is different than 0 after function call is completed) and entry points to
/// a valid buffer (entry is set to a value different than NULL before the
/// function is called), then the first entry_size bytes (table create
/// parameter) in *entry store a copy of table entry that contained the data
/// associated with the current key before the key was deleted.
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_entry_delete =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               key:
                                                   *mut ::std::os::raw::c_void,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entry:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table entry add bulk
///
/// @param table
/// Handle to lookup table instance
/// @param key
/// Array containing lookup keys
/// @param entries
/// Array containing data to be associated with each key. Every item in the
/// array has to point to a valid memory buffer where the first entry_size
/// bytes (table create parameter) are populated with the data.
/// @param n_keys
/// Number of keys to add
/// @param key_found
/// After successful invocation, key_found for every item in the array is set
/// to a value different than 0 if the current key is already present in the
/// table and to 0 if not. This pointer has to be set to a valid memory
/// location before the table entry add function is called.
/// @param entries_ptr
/// After successful invocation, array *entries_ptr stores the handle to the
/// table entry containing the data associated with every key. This handle can
/// be used to perform further read-write accesses to this entry. This handle
/// is valid until the key is deleted from the table or the same key is
/// re-added to the table, typically to associate it with different data. This
/// pointer has to be set to a valid memory location before the function is
/// called.
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_entry_add_bulk =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               keys:
                                                   *mut *mut ::std::os::raw::c_void,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n_keys: u32,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entries_ptr:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table entry delete bulk
///
/// @param table
/// Handle to lookup table instance
/// @param key
/// Array containing lookup keys
/// @param n_keys
/// Number of keys to delete
/// @param key_found
/// After successful invocation, key_found for every item in the array is set
/// to a value different than 0if the current key was present in the table
/// before the delete operation was performed and to 0 if not. This pointer
/// has to be set to a valid memory location before the table entry delete
/// function is called.
/// @param entries
/// If entries pointer is NULL, this pointer is ignored for every entry found.
/// Else, after successful invocation, if specific key is found in the table
/// (key_found is different than 0 for this item after function call is
/// completed) and item of entry array points to a valid buffer (entry is set
/// to a value different than NULL before the function is called), then the
/// first entry_size bytes (table create parameter) in *entry store a copy of
/// table entry that contained the data associated with the current key before
/// the key was deleted.
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_entry_delete_bulk =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               keys:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n_keys: u32,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table lookup
///
/// @param table
/// Handle to lookup table instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param pkts_mask
/// 64-bit bitmask specifying which packets in the input burst are valid. When
/// pkts_mask bit n is set, then element n of pkts array is pointing to a
/// valid packet. Otherwise, element n of pkts array does not point to a valid
/// packet, therefore it will not be accessed.
/// @param lookup_hit_mask
/// Once the table lookup operation is completed, this 64-bit bitmask
/// specifies which of the valid packets in the input burst resulted in lookup
/// hit. For each valid input packet (pkts_mask bit n is set), the following
/// are true on lookup hit: lookup_hit_mask bit n is set, element n of entries
/// array is valid and it points to the lookup table entry that was hit. For
/// each valid input packet (pkts_mask bit n is set), the following are true
/// on lookup miss: lookup_hit_mask bit n is not set and element n of entries
/// array is not valid.
/// @param entries
/// Once the table lookup operation is completed, this array provides the
/// lookup table entries that were hit, as described above. It is required
/// that this array is always pre-allocated by the caller of this function
/// with exactly 64 elements. The implementation is allowed to speculatively
/// modify the elements of this array, so elements marked as invalid in
/// lookup_hit_mask once the table lookup operation is completed might have
/// been modified by this function.
/// @return
/// 0 on success, error code otherwise
pub type rte_table_op_lookup =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               lookup_hit_mask: *mut u64,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Lookup table stats read
///
/// @param table
/// Handle to lookup table instance
/// @param stats
/// Handle to table stats struct to copy data
/// @param clear
/// Flag indicating that stats should be cleared after read
///
/// @return
/// Error code or 0 on success.
pub type rte_table_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_table_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/// Lookup table interface defining the lookup table operation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_ops {
    /// < Create
    pub f_create: rte_table_op_create,
    /// < Free
    pub f_free: rte_table_op_free,
    /// < Entry add
    pub f_add: rte_table_op_entry_add,
    /// < Entry delete
    pub f_delete: rte_table_op_entry_delete,
    /// < Add entry bulk
    pub f_add_bulk: rte_table_op_entry_add_bulk,
    /// < Delete entry bulk
    pub f_delete_bulk: rte_table_op_entry_delete_bulk,
    /// < Lookup
    pub f_lookup: rte_table_op_lookup,
    /// < Stats
    pub f_stats: rte_table_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_table_ops() {
    assert_eq!(::std::mem::size_of::<rte_table_ops>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rte_table_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_table_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_table_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_create as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_free as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_add as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_delete as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_add_bulk as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_add_bulk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_delete_bulk as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_delete_bulk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_lookup as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_lookup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_stats as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_ops ) , "::"
                , stringify ! ( f_stats ) ));
}
impl Clone for rte_table_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline {
    _unused: [u8; 0],
}
/// Parameters for pipeline creation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_params {
    /// Pipeline name
    pub name: *const ::std::os::raw::c_char,
    /// CPU socket ID where memory for the pipeline and its elements (ports
    /// and tables) should be allocated
    pub socket_id: ::std::os::raw::c_int,
    /// Offset within packet meta-data to port_id to be used by action
    /// "Send packet to output port read from packet meta-data". Has to be
    /// 4-byte aligned.
    pub offset_port_id: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_params>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_pipeline_params ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pipeline_params ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . socket_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pipeline_params ) ,
                "::" , stringify ! ( socket_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . offset_port_id
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_pipeline_params ) ,
                "::" , stringify ! ( offset_port_id ) ));
}
impl Clone for rte_pipeline_params {
    fn clone(&self) -> Self { *self }
}
/// Pipeline port in stats.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_in_stats {
    /// Port in stats.
    pub stats: rte_port_in_stats,
    /// Number of packets dropped by action handler.
    pub n_pkts_dropped_by_ah: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_in_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_in_stats>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pipeline_port_in_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_in_stats>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_port_in_stats )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_stats ) ) . stats as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_stats ) , "::" , stringify ! ( stats )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_stats ) ) .
                n_pkts_dropped_by_ah as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_stats ) , "::" , stringify ! (
                n_pkts_dropped_by_ah ) ));
}
impl Clone for rte_pipeline_port_in_stats {
    fn clone(&self) -> Self { *self }
}
/// Pipeline port out stats.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_out_stats {
    /// Port out stats.
    pub stats: rte_port_out_stats,
    /// Number of packets dropped by action handler.
    pub n_pkts_dropped_by_ah: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_out_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_out_stats>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pipeline_port_out_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_out_stats>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_port_out_stats )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_stats ) ) . stats
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_stats ) , "::" , stringify ! ( stats )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_stats ) ) .
                n_pkts_dropped_by_ah as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_stats ) , "::" , stringify ! (
                n_pkts_dropped_by_ah ) ));
}
impl Clone for rte_pipeline_port_out_stats {
    fn clone(&self) -> Self { *self }
}
/// Pipeline table stats.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_stats {
    /// Table stats.
    pub stats: rte_table_stats,
    /// Number of packets dropped by lookup hit action handler.
    pub n_pkts_dropped_by_lkp_hit_ah: u64,
    /// Number of packets dropped by lookup miss action handler.
    pub n_pkts_dropped_by_lkp_miss_ah: u64,
    /// Number of packets dropped by pipeline in behalf of this
    /// table based on action specified in table entry.
    pub n_pkts_dropped_lkp_hit: u64,
    /// Number of packets dropped by pipeline in behalf of this
    /// table based on action specified in table entry.
    pub n_pkts_dropped_lkp_miss: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_stats>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pipeline_table_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_stats>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_table_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) . stats as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_stats ) , "::" , stringify ! ( stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_by_lkp_hit_ah as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_stats ) , "::" , stringify ! (
                n_pkts_dropped_by_lkp_hit_ah ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_by_lkp_miss_ah as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_stats ) , "::" , stringify ! (
                n_pkts_dropped_by_lkp_miss_ah ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_lkp_hit as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_stats ) , "::" , stringify ! (
                n_pkts_dropped_lkp_hit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_lkp_miss as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_stats ) , "::" , stringify ! (
                n_pkts_dropped_lkp_miss ) ));
}
impl Clone for rte_pipeline_table_stats {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Pipeline create
///
/// @param params
/// Parameters for pipeline creation
/// @return
/// Handle to pipeline instance on success or NULL otherwise
    pub fn rte_pipeline_create(params: *mut rte_pipeline_params)
     -> *mut rte_pipeline;
}
extern "C" {
    /// Pipeline free
///
/// @param p
/// Handle to pipeline instance
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_free(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline consistency check
///
/// @param p
/// Handle to pipeline instance
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_check(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline run
///
/// @param p
/// Handle to pipeline instance
/// @return
/// Number of packets read and processed
    pub fn rte_pipeline_run(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline flush
///
/// @param p
/// Handle to pipeline instance
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_flush(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// Reserved actions
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pipeline_action {
    RTE_PIPELINE_ACTION_DROP = 0,
    RTE_PIPELINE_ACTION_PORT = 1,
    RTE_PIPELINE_ACTION_PORT_META = 2,
    RTE_PIPELINE_ACTION_TABLE = 3,
    RTE_PIPELINE_ACTIONS = 4,
}
/// Head format for the table entry of any pipeline table. For any given
/// pipeline table, all table entries should have the same size and format. For
/// any given pipeline table, the table entry has to start with a head of this
/// structure, which contains the reserved actions and their associated
/// meta-data, and then optionally continues with user actions and their
/// associated meta-data. As all the currently defined reserved actions are
/// mutually exclusive, only one reserved action can be set per table entry.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_entry {
    /// Reserved action
    pub action: rte_pipeline_action,
    pub __bindgen_anon_1: rte_pipeline_table_entry__bindgen_ty_1,
    /// Start of table entry area for user defined actions and meta-data
    pub action_data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_entry__bindgen_ty_1 {
    /// Output port ID (meta-data for "Send packet to output port"
    /// action)
    pub port_id: __BindgenUnionField<u32>,
    /// Table ID (meta-data for "Send packet to table" action)
    pub table_id: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_entry__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_pipeline_table_entry__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_entry__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_pipeline_table_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry__bindgen_ty_1 )
                ) . port_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_entry__bindgen_ty_1 ) , "::" , stringify !
                ( port_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry__bindgen_ty_1 )
                ) . table_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_entry__bindgen_ty_1 ) , "::" , stringify !
                ( table_id ) ));
}
impl Clone for rte_pipeline_table_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_entry() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_entry>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pipeline_table_entry ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_entry>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_table_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry ) ) . action as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_entry ) , "::" , stringify ! ( action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry ) ) .
                action_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_entry ) , "::" , stringify ! ( action_data
                ) ));
}
impl Clone for rte_pipeline_table_entry {
    fn clone(&self) -> Self { *self }
}
/// Pipeline table action handler on lookup hit
///
/// The action handler can decide to drop packets by resetting the associated
/// packet bit in the pkts_mask parameter. In this case, the action handler is
/// required not to free the packet buffer, which will be freed eventually by
/// the pipeline.
///
/// @param p
/// Handle to pipeline instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param pkts_mask
/// 64-bit bitmask specifying which packets in the input burst are valid. When
/// pkts_mask bit n is set, then element n of pkts array is pointing to a
/// valid packet and element n of entries array is pointing to a valid table
/// entry associated with the packet, with the association typically done by
/// the table lookup operation. Otherwise, element n of pkts array and element
/// n of entries array will not be accessed.
/// @param entries
/// Set of table entries specified as array of up to 64 pointers to struct
/// rte_pipeline_table_entry
/// @param arg
/// Opaque parameter registered by the user at the pipeline table creation
/// time
/// @return
/// 0 on success, error code otherwise
pub type rte_pipeline_table_action_handler_hit =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               entries:
                                                   *mut *mut rte_pipeline_table_entry,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Pipeline table action handler on lookup miss
///
/// The action handler can decide to drop packets by resetting the associated
/// packet bit in the pkts_mask parameter. In this case, the action handler is
/// required not to free the packet buffer, which will be freed eventually by
/// the pipeline.
///
/// @param p
/// Handle to pipeline instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param pkts_mask
/// 64-bit bitmask specifying which packets in the input burst are valid. When
/// pkts_mask bit n is set, then element n of pkts array is pointing to a
/// valid packet. Otherwise, element n of pkts array will not be accessed.
/// @param entry
/// Single table entry associated with all the valid packets from the input
/// burst, specified as pointer to struct rte_pipeline_table_entry.
/// This entry is the pipeline table default entry that is associated by the
/// table lookup operation with the input packets that have resulted in lookup
/// miss.
/// @param arg
/// Opaque parameter registered by the user at the pipeline table creation
/// time
/// @return
/// 0 on success, error code otherwise
pub type rte_pipeline_table_action_handler_miss =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               entry:
                                                   *mut rte_pipeline_table_entry,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Parameters for pipeline table creation. Action handlers have to be either
/// both enabled or both disabled (they can be disabled by setting them to
/// NULL).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_params {
    /// Table operations (specific to each table type)
    pub ops: *mut rte_table_ops,
    /// Opaque param to be passed to the table create operation when
    /// invoked
    pub arg_create: *mut ::std::os::raw::c_void,
    /// Callback function to execute the user actions on input packets in
    /// case of lookup hit
    pub f_action_hit: rte_pipeline_table_action_handler_hit,
    /// Callback function to execute the user actions on input packets in
    /// case of lookup miss
    pub f_action_miss: rte_pipeline_table_action_handler_miss,
    /// Opaque parameter to be passed to lookup hit and/or lookup miss
    /// action handlers when invoked
    pub arg_ah: *mut ::std::os::raw::c_void,
    /// Memory size to be reserved per table entry for storing the user
    /// actions and their meta-data
    pub action_data_size: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_params>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pipeline_table_params ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_table_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) . ops as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                arg_create as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! ( arg_create
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                f_action_hit as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! (
                f_action_hit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                f_action_miss as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! (
                f_action_miss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) . arg_ah as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! ( arg_ah )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                action_data_size as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_pipeline_table_params ) , "::" , stringify ! (
                action_data_size ) ));
}
impl Clone for rte_pipeline_table_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Pipeline table create
///
/// @param p
/// Handle to pipeline instance
/// @param params
/// Parameters for pipeline table creation
/// @param table_id
/// Table ID. Valid only within the scope of table IDs of the current
/// pipeline. Only returned after a successful invocation.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_create(p: *mut rte_pipeline,
                                     params: *mut rte_pipeline_table_params,
                                     table_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table default entry add
///
/// The contents of the table default entry is updated with the provided actions
/// and meta-data. When the default entry is not configured (by using this
/// function), the built-in default entry has the action "Drop" and meta-data
/// set to all-zeros.
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param default_entry
/// New contents for the table default entry
/// @param default_entry_ptr
/// On successful invocation, pointer to the default table entry which can be
/// used for further read-write accesses to this table entry. This pointer
/// is valid until the default entry is deleted or re-added.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_default_entry_add(p: *mut rte_pipeline,
                                                table_id: u32,
                                                default_entry:
                                                    *mut rte_pipeline_table_entry,
                                                default_entry_ptr:
                                                    *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table default entry delete
///
/// The new contents of the table default entry is set to reserved action "Drop
/// the packet" with meta-data cleared (i.e. set to all-zeros).
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param entry
/// On successful invocation, when entry points to a valid buffer, the
/// previous contents of the table default entry (as it was just before the
/// delete operation) is copied to this buffer
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_default_entry_delete(p: *mut rte_pipeline,
                                                   table_id: u32,
                                                   entry:
                                                       *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table entry add
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param key
/// Table entry key
/// @param entry
/// New contents for the table entry identified by key
/// @param key_found
/// On successful invocation, set to TRUE (value different than 0) if key was
/// already present in the table before the add operation and to FALSE (value
/// 0) if not
/// @param entry_ptr
/// On successful invocation, pointer to the table entry associated with key.
/// This can be used for further read-write accesses to this table entry and
/// is valid until the key is deleted from the table or re-added (usually for
/// associating different actions and/or action meta-data to the current key)
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_entry_add(p: *mut rte_pipeline, table_id: u32,
                                        key: *mut ::std::os::raw::c_void,
                                        entry: *mut rte_pipeline_table_entry,
                                        key_found: *mut ::std::os::raw::c_int,
                                        entry_ptr:
                                            *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table entry delete
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param key
/// Table entry key
/// @param key_found
/// On successful invocation, set to TRUE (value different than 0) if key was
/// found in the table before the delete operation and to FALSE (value 0) if
/// not
/// @param entry
/// On successful invocation, when key is found in the table and entry points
/// to a valid buffer, the table entry contents (as it was before the delete
/// was performed) is copied to this buffer
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_entry_delete(p: *mut rte_pipeline,
                                           table_id: u32,
                                           key: *mut ::std::os::raw::c_void,
                                           key_found:
                                               *mut ::std::os::raw::c_int,
                                           entry:
                                               *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table entry add bulk
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param keys
/// Array containing table entry keys
/// @param entries
/// Array containung new contents for every table entry identified by key
/// @param n_keys
/// Number of keys to add
/// @param key_found
/// On successful invocation, key_found for every item in the array is set to
/// TRUE (value different than 0) if key was already present in the table
/// before the add operation and to FALSE (value 0) if not
/// @param entries_ptr
/// On successful invocation, array *entries_ptr stores pointer to every table
/// entry associated with key. This can be used for further read-write accesses
/// to this table entry and is valid until the key is deleted from the table or
/// re-added (usually for associating different actions and/or action meta-data
/// to the current key)
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_entry_add_bulk(p: *mut rte_pipeline,
                                             table_id: u32,
                                             keys:
                                                 *mut *mut ::std::os::raw::c_void,
                                             entries:
                                                 *mut *mut rte_pipeline_table_entry,
                                             n_keys: u32,
                                             key_found:
                                                 *mut ::std::os::raw::c_int,
                                             entries_ptr:
                                                 *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline table entry delete bulk
///
/// @param p
/// Handle to pipeline instance
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @param keys
/// Array containing table entry keys
/// @param n_keys
/// Number of keys to delete
/// @param key_found
/// On successful invocation, key_found for every item in the array is set to
/// TRUE (value different than 0) if key was found in the table before the
/// delete operation and to FALSE (value 0) if not
/// @param entries
/// If entries pointer is NULL, this pointer is ignored for every entry found.
/// Else, after successful invocation, if specific key is found in the table
/// and entry points to a valid buffer, the table entry contents (as it was
/// before the delete was performed) is copied to this buffer.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_entry_delete_bulk(p: *mut rte_pipeline,
                                                table_id: u32,
                                                keys:
                                                    *mut *mut ::std::os::raw::c_void,
                                                n_keys: u32,
                                                key_found:
                                                    *mut ::std::os::raw::c_int,
                                                entries:
                                                    *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read pipeline table stats.
///
/// This function reads table statistics identified by *table_id* of given
/// pipeline *p*.
///
/// @param p
/// Handle to pipeline instance.
/// @param table_id
/// Port ID what stats will be returned.
/// @param stats
/// Statistics buffer.
/// @param clear
/// If not 0 clear stats after reading.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_table_stats_read(p: *mut rte_pipeline, table_id: u32,
                                         stats: *mut rte_pipeline_table_stats,
                                         clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
/// Pipeline input port action handler
///
/// The action handler can decide to drop packets by resetting the associated
/// packet bit in the pkts_mask parameter. In this case, the action handler is
/// required not to free the packet buffer, which will be freed eventually by
/// the pipeline.
///
/// @param p
/// Handle to pipeline instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param n
/// Number of packets in the input burst. This parameter specifies that
/// elements 0 to (n-1) of pkts array are valid.
/// @param arg
/// Opaque parameter registered by the user at the pipeline table creation
/// time
/// @return
/// 0 on success, error code otherwise
pub type rte_pipeline_port_in_action_handler =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               n: u32,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Parameters for pipeline input port creation
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_in_params {
    /// Input port operations (specific to each table type)
    pub ops: *mut rte_port_in_ops,
    /// Opaque parameter to be passed to create operation when invoked
    pub arg_create: *mut ::std::os::raw::c_void,
    /// Callback function to execute the user actions on input packets.
    /// Disabled if set to NULL.
    pub f_action: rte_pipeline_port_in_action_handler,
    /// Opaque parameter to be passed to the action handler when invoked
    pub arg_ah: *mut ::std::os::raw::c_void,
    /// Recommended burst size for the RX operation(in number of pkts)
    pub burst_size: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_in_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_in_params>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pipeline_port_in_params ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_in_params>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_port_in_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) . ops as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_params ) , "::" , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                arg_create as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_params ) , "::" , stringify ! (
                arg_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                f_action as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_params ) , "::" , stringify ! ( f_action
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) . arg_ah
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_params ) , "::" , stringify ! ( arg_ah )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                burst_size as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_in_params ) , "::" , stringify ! (
                burst_size ) ));
}
impl Clone for rte_pipeline_port_in_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Pipeline input port create
///
/// @param p
/// Handle to pipeline instance
/// @param params
/// Parameters for pipeline input port creation
/// @param port_id
/// Input port ID. Valid only within the scope of input port IDs of the
/// current pipeline. Only returned after a successful invocation.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_in_create(p: *mut rte_pipeline,
                                       params:
                                           *mut rte_pipeline_port_in_params,
                                       port_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline input port connect to table
///
/// @param p
/// Handle to pipeline instance
/// @param port_id
/// Port ID (returned by previous invocation of pipeline input port create)
/// @param table_id
/// Table ID (returned by previous invocation of pipeline table create)
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_in_connect_to_table(p: *mut rte_pipeline,
                                                 port_id: u32, table_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline input port enable
///
/// @param p
/// Handle to pipeline instance
/// @param port_id
/// Port ID (returned by previous invocation of pipeline input port create)
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_in_enable(p: *mut rte_pipeline, port_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Pipeline input port disable
///
/// @param p
/// Handle to pipeline instance
/// @param port_id
/// Port ID (returned by previous invocation of pipeline input port create)
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_in_disable(p: *mut rte_pipeline, port_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read pipeline port in stats.
///
/// This function reads port in statistics identified by *port_id* of given
/// pipeline *p*.
///
/// @param p
/// Handle to pipeline instance.
/// @param port_id
/// Port ID what stats will be returned.
/// @param stats
/// Statistics buffer.
/// @param clear
/// If not 0 clear stats after reading.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_in_stats_read(p: *mut rte_pipeline, port_id: u32,
                                           stats:
                                               *mut rte_pipeline_port_in_stats,
                                           clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
/// Pipeline output port action handler
///
/// The action handler can decide to drop packets by resetting the associated
/// packet bit in the pkts_mask parameter. In this case, the action handler is
/// required not to free the packet buffer, which will be freed eventually by
/// the pipeline.
///
/// @param p
/// Handle to pipeline instance
/// @param pkts
/// Burst of input packets specified as array of up to 64 pointers to struct
/// rte_mbuf
/// @param pkts_mask
/// 64-bit bitmask specifying which packets in the input burst are valid. When
/// pkts_mask bit n is set, then element n of pkts array is pointing to a
/// valid packet. Otherwise, element n of pkts array will not be accessed.
/// @param arg
/// Opaque parameter registered by the user at the pipeline table creation
/// time
/// @return
/// 0 on success, error code otherwise
pub type rte_pipeline_port_out_action_handler =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/// Parameters for pipeline output port creation. The action handlers have to
/// be either both enabled or both disabled (by setting them to NULL). When
/// enabled, the pipeline selects between them at different moments, based on the
/// number of packets that have to be sent to the same output port.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_out_params {
    /// Output port operations (specific to each table type)
    pub ops: *mut rte_port_out_ops,
    /// Opaque parameter to be passed to create operation when invoked
    pub arg_create: *mut ::std::os::raw::c_void,
    /// Callback function executing the user actions on bust of input
    /// packets
    pub f_action: rte_pipeline_port_out_action_handler,
    /// Opaque parameter to be passed to the action handler when invoked
    pub arg_ah: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_out_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_out_params>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pipeline_port_out_params ) ));
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_out_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pipeline_port_out_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) . ops as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_params ) , "::" , stringify ! ( ops )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) .
                arg_create as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_params ) , "::" , stringify ! (
                arg_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) .
                f_action as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_params ) , "::" , stringify ! ( f_action
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) . arg_ah
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pipeline_port_out_params ) , "::" , stringify ! ( arg_ah )
                ));
}
impl Clone for rte_pipeline_port_out_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Pipeline output port create
///
/// @param p
/// Handle to pipeline instance
/// @param params
/// Parameters for pipeline output port creation
/// @param port_id
/// Output port ID. Valid only within the scope of output port IDs of the
/// current pipeline. Only returned after a successful invocation.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_out_create(p: *mut rte_pipeline,
                                        params:
                                            *mut rte_pipeline_port_out_params,
                                        port_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read pipeline port out stats.
///
/// This function reads port out statistics identified by *port_id* of given
/// pipeline *p*.
///
/// @param p
/// Handle to pipeline instance.
/// @param port_id
/// Port ID what stats will be returned.
/// @param stats
/// Statistics buffer.
/// @param clear
/// If not 0 clear stats after reading.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_out_stats_read(p: *mut rte_pipeline,
                                            port_id: u32,
                                            stats:
                                                *mut rte_pipeline_port_out_stats,
                                            clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Action handler packet insert to output port
///
/// This function can be called by any input/output port or table action handler
/// to send a packet out through one of the pipeline output ports. This packet is
/// generated by the action handler, i.e. this packet is not part of the burst of
/// packets read from one of the pipeline input ports and currently processed by
/// the pipeline (this packet is not an element of the pkts array input parameter
/// of the action handler).
///
/// @param p
/// Handle to pipeline instance
/// @param port_id
/// Output port ID (returned by previous invocation of pipeline output port
/// create) to send the packet specified by pkt
/// @param pkt
/// New packet generated by the action handler
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_port_out_packet_insert(p: *mut rte_pipeline,
                                               port_id: u32,
                                               pkt: *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Action handler packet hijack
///
/// This function can be called by any input/output port or table action handler
/// to hijack selected packets from the burst of packets read from one of the
/// pipeline input ports and currently processed by the pipeline. The hijacked
/// packets are removed from any further pipeline processing, with the action
/// handler now having the full ownership for these packets.
///
/// The action handler can further send the hijacked packets out through any
/// pipeline output port by calling the rte_pipeline_ah_port_out_packet_insert()
/// function. The action handler can also drop these packets by calling the
/// rte_pktmbuf_free() function, although a better alternative is provided by
/// the action handler using the rte_pipeline_ah_packet_drop() function.
///
/// @param p
/// Handle to pipeline instance
/// @param pkts_mask
/// 64-bit bitmask specifying which of the packets handed over for processing
/// to the action handler is to be hijacked by the action handler. When
/// pkts_mask bit n is set, then element n of the pkts array (input argument to
/// the action handler) is hijacked.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_ah_packet_hijack(p: *mut rte_pipeline, pkts_mask: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Action handler packet drop
///
/// This function is called by the pipeline action handlers (port in/out, table)
/// to drop the packets selected using packet mask.
///
/// This function can be called by any input/output port or table action handler
/// to drop selected packets from the burst of packets read from one of the
/// pipeline input ports and currently processed by the pipeline. The dropped
/// packets are removed from any further pipeline processing and the packet
/// buffers are eventually freed to their buffer pool.
///
/// This function updates the drop statistics counters correctly, therefore the
/// recommended approach for dropping packets by the action handlers is to call
/// this function as opposed to the action handler hijacking the packets first
/// and then dropping them invisibly to the pipeline (by using the
/// rte_pktmbuf_free() function).
///
/// @param p
/// Handle to pipeline instance
/// @param pkts_mask
/// 64-bit bitmask specifying which of the packets handed over for processing
/// to the action handler is to be dropped by the action handler. When
/// pkts_mask bit n is set, then element n of the pkts array (input argument to
/// the action handler) is dropped.
/// @return
/// 0 on success, error code otherwise
    pub fn rte_pipeline_ah_packet_drop(p: *mut rte_pipeline, pkts_mask: u64)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pmd_bnxt_mb_event_rsp {
    RTE_PMD_BNXT_MB_EVENT_NOOP_ACK = 0,
    RTE_PMD_BNXT_MB_EVENT_NOOP_NACK = 1,
    RTE_PMD_BNXT_MB_EVENT_PROCEED = 2,
    RTE_PMD_BNXT_MB_EVENT_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_bnxt_mb_event_param {
    pub vf_id: u16,
    pub retval: ::std::os::raw::c_int,
    pub msg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_pmd_bnxt_mb_event_param() {
    assert_eq!(::std::mem::size_of::<rte_pmd_bnxt_mb_event_param>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pmd_bnxt_mb_event_param ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_bnxt_mb_event_param>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pmd_bnxt_mb_event_param )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_bnxt_mb_event_param ) ) . vf_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_bnxt_mb_event_param ) , "::" , stringify ! ( vf_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_bnxt_mb_event_param ) ) . retval
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_bnxt_mb_event_param ) , "::" , stringify ! ( retval )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_bnxt_mb_event_param ) ) . msg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_bnxt_mb_event_param ) , "::" , stringify ! ( msg ) ));
}
impl Clone for rte_pmd_bnxt_mb_event_param {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Enable/Disable VF MAC anti spoof
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param on
/// 1 - Enable VF MAC anti spoof.
/// 0 - Disable VF MAC anti spoof.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_mac_anti_spoof(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the VF MAC address.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param mac_addr
/// VF MAC address.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* or *mac_addr* is invalid.
    pub fn rte_pmd_bnxt_set_vf_mac_addr(port: u8, vf: u16,
                                        mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan strip for all queues in a pool
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param on
/// 1 - Enable VF's vlan strip on RX queues.
/// 0 - Disable VF's vlan strip on RX queues.
///
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_vlan_stripq(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan insert
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param vlan_id
/// 0 - Disable VF's vlan insert.
/// n - Enable; n is inserted as the vlan id.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_vlan_insert(port: u8, vf: u16, vlan_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware VF VLAN filtering by an Ethernet device of
/// received VLAN packets tagged with a given VLAN Tag Identifier.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vlan
/// The VLAN Tag Identifier whose filtering must be enabled or disabled.
/// @param vf_mask
/// Bitmap listing which VFs participate in the VLAN filtering.
/// @param vlan_on
/// 1 - Enable VFs VLAN filtering.
/// 0 - Disable VFs VLAN filtering.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_vlan_filter(port: u8, vlan: u16, vf_mask: u64,
                                           vlan_on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable tx loopback
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - Enable tx loopback.
/// 0 - Disable tx loopback.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_tx_loopback(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// set all queues drop enable bit
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - set the queue drop enable bit for all pools.
/// 0 - reset the queue drop enable bit for all pools.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_all_queues_drop_en(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the VF rate limit.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param tx_rate
/// Tx rate for the VF
/// @param q_msk
/// Mask of the Tx queue
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* or *mac_addr* is invalid.
    pub fn rte_pmd_bnxt_set_vf_rate_limit(port: u8, vf: u16, tx_rate: u16,
                                          q_msk: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get VF's statistics
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to get.
/// @param stats
/// A pointer to a structure of type *rte_eth_stats* to be filled with
/// the values of device counters supported statistics:
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_get_vf_stats(port: u8, vf_id: u16,
                                     stats: *mut rte_eth_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Clear VF's statistics
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to get.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_reset_vf_stats(port: u8, vf_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF VLAN anti spoof
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param on
/// 1 - Enable VF VLAN anti spoof.
/// 0 - Disable VF VLAN anti spoof.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_vlan_anti_spoof(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set RX L2 Filtering mode of a VF of an Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param rx_mask
/// The RX mode mask
/// @param on
/// 1 - Enable a VF RX mode.
/// 0 - Disable a VF RX mode.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_rxmode(port: u8, vf: u16, rx_mask: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Returns the number of default RX queues on a VF
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @return
/// - Non-negative value - Number of default RX queues
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) if on a function without VFs
/// - (-ENOMEM) on an allocation failure
/// - (-1) firmware interface error
    pub fn rte_pmd_bnxt_get_vf_rx_status(port: u8, vf_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Queries the TX drop counter for the function
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to get.
/// @param count
/// Pointer to a uint64_t that will be populated with the counter value.
/// @return
/// - Positive Non-zero value - Error code from HWRM
/// - (-EINVAL) invalid vf_id specified.
/// - (-ENOTSUP) Ethernet device is not a PF
    pub fn rte_pmd_bnxt_get_vf_tx_drop_count(port: u8, vf_id: u16,
                                             count: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Programs the MAC address for the function specified
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac_addr
/// The MAC address to be programmed in the filter.
/// @param vf_id
/// VF on which to get.
/// @return
/// - Positive Non-zero value - Error code from HWRM
/// - (-EINVAL) invalid vf_id specified.
/// - (-ENOTSUP) Ethernet device is not a PF
/// - (-ENOMEM) on an allocation failure
    pub fn rte_pmd_bnxt_mac_addr_add(port: u8, mac_addr: *mut ether_addr,
                                     vf_id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF statistics retention
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param on
/// 1 - Prevent VF statistics from automatically resetting
/// 0 - Allow VF statistics to automatically reset
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_bnxt_set_vf_persist_stats(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// Response sent back to i40e driver from user app after callback
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pmd_i40e_mb_event_rsp {
    RTE_PMD_I40E_MB_EVENT_NOOP_ACK = 0,
    RTE_PMD_I40E_MB_EVENT_NOOP_NACK = 1,
    RTE_PMD_I40E_MB_EVENT_PROCEED = 2,
    RTE_PMD_I40E_MB_EVENT_MAX = 3,
}
/// Data sent to the user application when the callback is executed.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_mb_event_param {
    /// < Virtual Function number
    pub vfid: u16,
    /// < VF to PF message type, see virtchnl_ops
    pub msg_type: u16,
    /// < return value
    pub retval: u16,
    /// < pointer to message
    pub msg: *mut ::std::os::raw::c_void,
    /// < length of the message
    pub msglen: u16,
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_mb_event_param() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_mb_event_param>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_mb_event_param ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_mb_event_param>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_mb_event_param )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_mb_event_param ) ) . vfid as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_mb_event_param ) , "::" , stringify ! ( vfid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_mb_event_param ) ) .
                msg_type as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_mb_event_param ) , "::" , stringify ! ( msg_type
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_mb_event_param ) ) . retval
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_mb_event_param ) , "::" , stringify ! ( retval )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_mb_event_param ) ) . msg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_mb_event_param ) , "::" , stringify ! ( msg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_mb_event_param ) ) . msglen
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_mb_event_param ) , "::" , stringify ! ( msglen )
                ));
}
impl Clone for rte_pmd_i40e_mb_event_param {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Option of package processing.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pmd_i40e_package_op {
    RTE_PMD_I40E_PKG_OP_UNDEFINED = 0,
    RTE_PMD_I40E_PKG_OP_WR_ADD = 1,
    RTE_PMD_I40E_PKG_OP_WR_DEL = 2,
    RTE_PMD_I40E_PKG_OP_WR_ONLY = 3,
    RTE_PMD_I40E_PKG_OP_MAX = 32,
}
#[repr(u32)]
/// Types of package information.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pmd_i40e_package_info {
    RTE_PMD_I40E_PKG_INFO_UNDEFINED = 0,
    RTE_PMD_I40E_PKG_INFO_GLOBAL_HEADER = 1,
    RTE_PMD_I40E_PKG_INFO_GLOBAL_NOTES_SIZE = 2,
    RTE_PMD_I40E_PKG_INFO_GLOBAL_NOTES = 3,
    RTE_PMD_I40E_PKG_INFO_GLOBAL_MAX = 1024,
    RTE_PMD_I40E_PKG_INFO_HEADER = 1025,
    RTE_PMD_I40E_PKG_INFO_DEVID_NUM = 1026,
    RTE_PMD_I40E_PKG_INFO_DEVID_LIST = 1027,
    RTE_PMD_I40E_PKG_INFO_MAX = 4294967295,
}
/// Version for dynamic device personalization.
/// Version in "major.minor.update.draft" format.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_ddp_version {
    pub major: u8,
    pub minor: u8,
    pub update: u8,
    pub draft: u8,
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_ddp_version() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_ddp_version>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_ddp_version ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_ddp_version>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_ddp_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_version ) ) . major as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_version ) , "::" , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_version ) ) . minor as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_version ) , "::" , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_version ) ) . update as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_version ) , "::" , stringify ! ( update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_version ) ) . draft as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_version ) , "::" , stringify ! ( draft ) ));
}
impl Clone for rte_pmd_i40e_ddp_version {
    fn clone(&self) -> Self { *self }
}
/// Device ID for dynamic device personalization.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_ddp_device_id {
    pub vendor_dev_id: u32,
    pub sub_vendor_dev_id: u32,
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_ddp_device_id() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_ddp_device_id>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_ddp_device_id ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_ddp_device_id>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_ddp_device_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_device_id ) ) .
                vendor_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_device_id ) , "::" , stringify ! (
                vendor_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ddp_device_id ) ) .
                sub_vendor_dev_id as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ddp_device_id ) , "::" , stringify ! (
                sub_vendor_dev_id ) ));
}
impl Clone for rte_pmd_i40e_ddp_device_id {
    fn clone(&self) -> Self { *self }
}
/// Profile information in profile info list.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_profile_info {
    pub track_id: u32,
    pub version: rte_pmd_i40e_ddp_version,
    pub owner: u8,
    pub reserved: [u8; 7usize],
    pub name: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_profile_info() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_profile_info>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_profile_info ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_profile_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_profile_info )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_info ) ) . track_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_info ) , "::" , stringify ! ( track_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_info ) ) . version
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_info ) , "::" , stringify ! ( version )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_info ) ) . owner as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_info ) , "::" , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_info ) ) . reserved
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_info ) , "::" , stringify ! ( reserved )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_info ) ) . name as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_info ) , "::" , stringify ! ( name ) ));
}
impl Clone for rte_pmd_i40e_profile_info {
    fn clone(&self) -> Self { *self }
}
/// Profile information list returned from HW.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_profile_list {
    pub p_count: u32,
    pub p_info: [rte_pmd_i40e_profile_info; 1usize],
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_profile_list() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_profile_list>() , 52usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_profile_list ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_profile_list>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_profile_list )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_list ) ) . p_count
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_list ) , "::" , stringify ! ( p_count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_profile_list ) ) . p_info as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_profile_list ) , "::" , stringify ! ( p_info )
                ));
}
impl Clone for rte_pmd_i40e_profile_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_i40e_ptype_mapping {
    /// < hardware defined packet type
    pub hw_ptype: u16,
    /// < software defined packet type
    pub sw_ptype: u32,
}
#[test]
fn bindgen_test_layout_rte_pmd_i40e_ptype_mapping() {
    assert_eq!(::std::mem::size_of::<rte_pmd_i40e_ptype_mapping>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_pmd_i40e_ptype_mapping ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_i40e_ptype_mapping>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_pmd_i40e_ptype_mapping )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ptype_mapping ) ) . hw_ptype
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ptype_mapping ) , "::" , stringify ! ( hw_ptype )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_i40e_ptype_mapping ) ) . sw_ptype
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_i40e_ptype_mapping ) , "::" , stringify ! ( sw_ptype )
                ));
}
impl Clone for rte_pmd_i40e_ptype_mapping {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Notify VF when PF link status changes.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* invalid.
    pub fn rte_pmd_i40e_ping_vfs(port: u8, vf: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF MAC anti spoofing.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to set MAC anti spoofing.
/// @param on
/// 1 - Enable VFs MAC anti spoofing.
/// 0 - Disable VFs MAC anti spoofing.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_mac_anti_spoof(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF VLAN anti spoofing.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to set VLAN anti spoofing.
/// @param on
/// 1 - Enable VFs VLAN anti spoofing.
/// 0 - Disable VFs VLAN anti spoofing.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_vlan_anti_spoof(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable TX loopback on all the PF and VFs.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - Enable TX loopback.
/// 0 - Disable TX loopback.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_tx_loopback(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF unicast promiscuous mode.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to set.
/// @param on
/// 1 - Enable.
/// 0 - Disable.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_unicast_promisc(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF multicast promiscuous mode.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to set.
/// @param on
/// 1 - Enable.
/// 0 - Disable.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_multicast_promisc(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the VF MAC address.
///
/// PF should set MAC address before VF initialized, if PF sets the MAC
/// address after VF initialized, new MAC address won't be effective until
/// VF reinitialize.
///
/// This will remove all existing MAC filters.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF id.
/// @param mac_addr
/// VF MAC address.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* or *mac_addr* is invalid.
    pub fn rte_pmd_i40e_set_vf_mac_addr(port: u8, vf_id: u16,
                                        mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan strip for all queues in a pool
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param on
/// 1 - Enable VF's vlan strip on RX queues.
/// 0 - Disable VF's vlan strip on RX queues.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_vlan_stripq(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan insert
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param vlan_id
/// 0 - Disable VF's vlan insert.
/// n - Enable; n is inserted as the vlan id.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_vlan_insert(port: u8, vf_id: u16, vlan_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf broadcast mode
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param on
/// 0 - Disable broadcast.
/// 1 - Enable broadcast.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_broadcast(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan tag
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param on
/// 0 - Disable VF's vlan tag.
/// n - Enable VF's vlan tag.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_set_vf_vlan_tag(port: u8, vf_id: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF VLAN filter
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vlan_id
/// ID specifying VLAN
/// @param vf_mask
/// Mask to filter VF's
/// @param on
/// 0 - Disable VF's VLAN filter.
/// 1 - Enable VF's VLAN filter.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_i40e_set_vf_vlan_filter(port: u8, vlan_id: u16,
                                           vf_mask: u64, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get VF's statistics
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to get.
/// @param stats
/// A pointer to a structure of type *rte_eth_stats* to be filled with
/// the values of device counters for the following set of statistics:
/// - *ipackets* with the total of successfully received packets.
/// - *opackets* with the total of successfully transmitted packets.
/// - *ibytes*   with the total of successfully received bytes.
/// - *obytes*   with the total of successfully transmitted bytes.
/// - *ierrors*  with the total of erroneous received packets.
/// - *oerrors*  with the total of failed transmitted packets.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_get_vf_stats(port: u8, vf_id: u16,
                                     stats: *mut rte_eth_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Clear VF's statistics
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// VF on which to get.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_reset_vf_stats(port: u8, vf_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set VF's max bandwidth.
///
/// Per VF bandwidth limitation and per TC bandwidth limitation cannot
/// be enabled in parallel. If per TC bandwidth is enabled, this function
/// will disable it.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param bw
/// Bandwidth for this VF.
/// The value should be an absolute bandwidth in Mbps.
/// The bandwidth is a L2 bandwidth counting the bytes of ethernet packets.
/// Not count the bytes added by physical layer.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_i40e_set_vf_max_bw(port: u8, vf_id: u16, bw: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set all the TCs' bandwidth weight on a specific VF.
///
/// The bw_weight means the percentage occupied by the TC.
/// It can be taken as the relative min bandwidth setting.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param tc_num
/// Number of TCs.
/// @param bw_weight
/// An array of relative bandwidth weight for all the TCs.
/// The summary of the bw_weight should be 100.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_i40e_set_vf_tc_bw_alloc(port: u8, vf_id: u16, tc_num: u8,
                                           bw_weight: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a specific TC's max bandwidth on a specific VF.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf_id
/// ID specifying VF.
/// @param tc_no
/// Number specifying TC.
/// @param bw
/// Max bandwidth for this TC.
/// The value should be an absolute bandwidth in Mbps.
/// The bandwidth is a L2 bandwidth counting the bytes of ethernet packets.
/// Not count the bytes added by physical layer.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_i40e_set_vf_tc_max_bw(port: u8, vf_id: u16, tc_no: u8,
                                         bw: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set some TCs to strict priority mode on a physical port.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param tc_map
/// A bit map for the TCs.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_i40e_set_tc_strict_prio(port: u8, tc_map: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Load/Unload a ddp package
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param buff
/// buffer of package.
/// @param size
/// size of buffer.
/// @param op
/// Operation of package processing
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-EEXIST) if profile exists.
/// - (-EACCES) if profile does not exist.
/// - (-ENOTSUP) if operation not supported.
    pub fn rte_pmd_i40e_process_ddp_package(port: u8, buff: *mut u8,
                                            size: u32,
                                            op: rte_pmd_i40e_package_op)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// rte_pmd_i40e_get_ddp_info - Get profile's info
/// @param pkg
/// buffer of package.
/// @param pkg_size
/// package buffer size
/// @param info
/// buffer for response
/// @param size
/// response buffer size
/// @param type
/// type of information requested
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if information type not supported by the profile.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_get_ddp_info(pkg: *mut u8, pkg_size: u32,
                                     info: *mut u8, size: u32,
                                     type_: rte_pmd_i40e_package_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// rte_pmd_i40e_get_ddp_list - Get loaded profile list
/// @param port
/// port id
/// @param buff
/// buffer for response
/// @param size
/// buffer size
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_i40e_get_ddp_list(port: u8, buff: *mut u8, size: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update hardware defined ptype to software defined packet type
/// mapping table.
///
/// @param port
/// pointer to port identifier of the device.
/// @param mapping_items
/// the base address of the mapping items array.
/// @param count
/// number of mapping items.
/// @param exclusive
/// the flag indicate different ptype mapping update method.
/// -(0) only overwrite referred PTYPE mapping,
/// keep other PTYPEs mapping unchanged.
/// -(!0) overwrite referred PTYPE mapping,
/// set other PTYPEs maps to PTYPE_UNKNOWN.
    pub fn rte_pmd_i40e_ptype_mapping_update(port: u8,
                                             mapping_items:
                                                 *mut rte_pmd_i40e_ptype_mapping,
                                             count: u16, exclusive: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset hardware defined ptype to software defined ptype
/// mapping table to default.
///
/// @param port
/// pointer to port identifier of the device
    pub fn rte_pmd_i40e_ptype_mapping_reset(port: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get hardware defined ptype to software defined ptype
/// mapping items.
///
/// @param port
/// pointer to port identifier of the device.
/// @param mapping_items
/// the base address of the array to store returned items.
/// @param size
/// the size of the input array.
/// @param count
/// the place to store the number of returned items.
/// @param valid_only
/// -(0) return full mapping table.
/// -(!0) only return mapping items which packet_type != RTE_PTYPE_UNKNOWN.
    pub fn rte_pmd_i40e_ptype_mapping_get(port: u8,
                                          mapping_items:
                                              *mut rte_pmd_i40e_ptype_mapping,
                                          size: u16, count: *mut u16,
                                          valid_only: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Replace a specific or a group of software defined ptypes
/// with a new one
///
/// @param port
/// pointer to port identifier of the device
/// @param target
/// the packet type to be replaced
/// @param mask
/// -(0) target represent a specific software defined ptype.
/// -(!0) target is a mask to represent a group of software defined ptypes.
/// @param pkt_type
/// the new packet type to overwrite
    pub fn rte_pmd_i40e_ptype_mapping_replace(port: u8, target: u32, mask: u8,
                                              pkt_type: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Notify VF when PF link status changes.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* invalid.
    pub fn rte_pmd_ixgbe_ping_vf(port: u8, vf: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the VF MAC address.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param mac_addr
/// VF MAC address.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if *vf* or *mac_addr* is invalid.
    pub fn rte_pmd_ixgbe_set_vf_mac_addr(port: u8, vf: u16,
                                         mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF VLAN anti spoofing.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF on which to set VLAN anti spoofing.
/// @param on
/// 1 - Enable VFs VLAN anti spoofing.
/// 0 - Disable VFs VLAN anti spoofing.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_vlan_anti_spoof(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable VF MAC anti spoofing.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF on which to set MAC anti spoofing.
/// @param on
/// 1 - Enable VFs MAC anti spoofing.
/// 0 - Disable VFs MAC anti spoofing.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_mac_anti_spoof(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan insert
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param vlan_id
/// 0 - Disable VF's vlan insert.
/// n - Enable; n is inserted as the vlan id.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_vlan_insert(port: u8, vf: u16, vlan_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable tx loopback
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - Enable tx loopback.
/// 0 - Disable tx loopback.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_tx_loopback(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// set all queues drop enable bit
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param on
/// 1 - set the queue drop enable bit for all pools.
/// 0 - reset the queue drop enable bit for all pools.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_all_queues_drop_en(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// set drop enable bit in the VF split rx control register
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param on
/// 1 - set the drop enable bit in the split rx control register.
/// 0 - reset the drop enable bit in the split rx control register.
///
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_split_drop_en(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable vf vlan strip for all queues in a pool
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// ID specifying VF.
/// @param on
/// 1 - Enable VF's vlan strip on RX queues.
/// 0 - Disable VF's vlan strip on RX queues.
///
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_vlan_stripq(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable MACsec offload.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param en
/// 1 - Enable encryption (encrypt and add integrity signature).
/// 0 - Disable encryption (only add integrity signature).
/// @param rp
/// 1 - Enable replay protection.
/// 0 - Disable replay protection.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
    pub fn rte_pmd_ixgbe_macsec_enable(port: u8, en: u8, rp: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disable MACsec offload.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
    pub fn rte_pmd_ixgbe_macsec_disable(port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure Tx SC (Secure Connection).
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac
/// The MAC address on the local side.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
    pub fn rte_pmd_ixgbe_macsec_config_txsc(port: u8, mac: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure Rx SC (Secure Connection).
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param mac
/// The MAC address on the remote side.
/// @param pi
/// The PI (port identifier) on the remote side.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
    pub fn rte_pmd_ixgbe_macsec_config_rxsc(port: u8, mac: *mut u8, pi: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable Tx SA (Secure Association).
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param idx
/// The SA to be enabled (0 or 1).
/// @param an
/// The association number on the local side.
/// @param pn
/// The packet number on the local side.
/// @param key
/// The key on the local side.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_macsec_select_txsa(port: u8, idx: u8, an: u8,
                                            pn: u32, key: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable Rx SA (Secure Association).
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param idx
/// The SA to be enabled (0 or 1)
/// @param an
/// The association number on the remote side.
/// @param pn
/// The packet number on the remote side.
/// @param key
/// The key on the remote side.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_macsec_select_rxsa(port: u8, idx: u8, an: u8,
                                            pn: u32, key: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set RX L2 Filtering mode of a VF of an Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param rx_mask
/// The RX mode mask, which is one or more of accepting Untagged Packets,
/// packets that match the PFUTA table, Broadcast and Multicast Promiscuous.
/// ETH_VMDQ_ACCEPT_UNTAG,ETH_VMDQ_ACCEPT_HASH_UC,
/// ETH_VMDQ_ACCEPT_BROADCAST and ETH_VMDQ_ACCEPT_MULTICAST will be used
/// in rx_mode.
/// @param on
/// 1 - Enable a VF RX mode.
/// 0 - Disable a VF RX mode.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_rxmode(port: u8, vf: u16, rx_mask: u16,
                                       on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable or disable a VF traffic receive of an Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param on
/// 1 - Enable a VF traffic receive.
/// 0 - Disable a VF traffic receive.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_rx(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable or disable a VF traffic transmit of the Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param on
/// 1 - Enable a VF traffic transmit.
/// 0 - Disable a VF traffic transmit.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port_id* invalid.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_tx(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware VF VLAN filtering by an Ethernet device of
/// received VLAN packets tagged with a given VLAN Tag Identifier.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vlan
/// The VLAN Tag Identifier whose filtering must be enabled or disabled.
/// @param vf_mask
/// Bitmap listing which VFs participate in the VLAN filtering.
/// @param vlan_on
/// 1 - Enable VFs VLAN filtering.
/// 0 - Disable VFs VLAN filtering.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_vlan_filter(port: u8, vlan: u16, vf_mask: u64,
                                            vlan_on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the rate limitation for a vf on an Ethernet device.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param vf
/// VF id.
/// @param tx_rate
/// The tx rate allocated from the total link speed for this VF id.
/// @param q_msk
/// The queue mask which need to set the rate.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support this feature.
/// - (-ENODEV) if *port_id* invalid.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_set_vf_rate_limit(port: u8, vf: u16, tx_rate: u16,
                                           q_msk: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set all the TCs' bandwidth weight.
///
/// The bw_weight means the percentage occupied by the TC.
/// It can be taken as the relative min bandwidth setting.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param tc_num
/// Number of TCs.
/// @param bw_weight
/// An array of relative bandwidth weight for all the TCs.
/// The summary of the bw_weight should be 100.
/// @return
/// - (0) if successful.
/// - (-ENODEV) if *port* invalid.
/// - (-EINVAL) if bad parameter.
/// - (-ENOTSUP) not supported by firmware.
    pub fn rte_pmd_ixgbe_set_tc_bw_alloc(port: u8, tc_num: u8,
                                         bw_weight: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize bypass logic. This function needs to be called before
/// executing any other bypass API.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_init(port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return bypass state.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param state
/// The return bypass state.
/// - (1) Normal mode
/// - (2) Bypass mode
/// - (3) Isolate mode
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_state_show(port: u8, state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set bypass state
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param new_state
/// The current bypass state.
/// - (1) Normal mode
/// - (2) Bypass mode
/// - (3) Isolate mode
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_state_set(port: u8, new_state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return bypass state when given event occurs.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param event
/// The bypass event
/// - (1) Main power on (power button is pushed)
/// - (2) Auxiliary power on (power supply is being plugged)
/// - (3) Main power off (system shutdown and power supply is left plugged in)
/// - (4) Auxiliary power off (power supply is being unplugged)
/// - (5) Display or set the watchdog timer
/// @param state
/// The bypass state when given event occurred.
/// - (1) Normal mode
/// - (2) Bypass mode
/// - (3) Isolate mode
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_event_show(port: u8, event: u32,
                                           state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set bypass state when given event occurs.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param event
/// The bypass event
/// - (1) Main power on (power button is pushed)
/// - (2) Auxiliary power on (power supply is being plugged)
/// - (3) Main power off (system shutdown and power supply is left plugged in)
/// - (4) Auxiliary power off (power supply is being unplugged)
/// - (5) Display or set the watchdog timer
/// @param state
/// The assigned state when given event occurs.
/// - (1) Normal mode
/// - (2) Bypass mode
/// - (3) Isolate mode
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_event_store(port: u8, event: u32, state: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set bypass watchdog timeout count.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param timeout
/// The timeout to be set.
/// - (0) 0 seconds (timer is off)
/// - (1) 1.5 seconds
/// - (2) 2 seconds
/// - (3) 3 seconds
/// - (4) 4 seconds
/// - (5) 8 seconds
/// - (6) 16 seconds
/// - (7) 32 seconds
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_wd_timeout_store(port: u8, timeout: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get bypass firmware version.
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param ver
/// The firmware version
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_ver_show(port: u8, ver: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return bypass watchdog timeout in seconds
///
/// @param port
/// The port identifier of the Ethernet device.
/// @param wd_timeout
/// The return watchdog timeout. "0" represents timer expired
/// - (0) 0 seconds (timer is off)
/// - (1) 1.5 seconds
/// - (2) 2 seconds
/// - (3) 3 seconds
/// - (4) 4 seconds
/// - (5) 8 seconds
/// - (6) 16 seconds
/// - (7) 32 seconds
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_wd_timeout_show(port: u8,
                                                wd_timeout: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset bypass watchdog timer
///
/// @param port
/// The port identifier of the Ethernet device.
/// @return
/// - (0) if successful.
/// - (-ENOTSUP) if hardware doesn't support.
/// - (-EINVAL) if bad parameter.
    pub fn rte_pmd_ixgbe_bypass_wd_reset(port: u8) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// Response sent back to ixgbe driver from user app after callback
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pmd_ixgbe_mb_event_rsp {
    RTE_PMD_IXGBE_MB_EVENT_NOOP_ACK = 0,
    RTE_PMD_IXGBE_MB_EVENT_NOOP_NACK = 1,
    RTE_PMD_IXGBE_MB_EVENT_PROCEED = 2,
    RTE_PMD_IXGBE_MB_EVENT_MAX = 3,
}
/// Data sent to the user application when the callback is executed.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pmd_ixgbe_mb_event_param {
    /// < Virtual Function number
    pub vfid: u16,
    /// < VF to PF message type, defined in ixgbe_mbx.h
    pub msg_type: u16,
    /// < return value
    pub retval: u16,
    /// < pointer to message
    pub msg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_pmd_ixgbe_mb_event_param() {
    assert_eq!(::std::mem::size_of::<rte_pmd_ixgbe_mb_event_param>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_pmd_ixgbe_mb_event_param ) ));
    assert_eq! (::std::mem::align_of::<rte_pmd_ixgbe_mb_event_param>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_pmd_ixgbe_mb_event_param )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_ixgbe_mb_event_param ) ) . vfid
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_ixgbe_mb_event_param ) , "::" , stringify ! ( vfid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_ixgbe_mb_event_param ) ) .
                msg_type as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_ixgbe_mb_event_param ) , "::" , stringify ! ( msg_type
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_ixgbe_mb_event_param ) ) . retval
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_ixgbe_mb_event_param ) , "::" , stringify ! ( retval )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pmd_ixgbe_mb_event_param ) ) . msg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_pmd_ixgbe_mb_event_param ) , "::" , stringify ! ( msg )
                ));
}
impl Clone for rte_pmd_ixgbe_mb_event_param {
    fn clone(&self) -> Self { *self }
}
pub const RTE_PMD_IXGBE_BYPASS_MODE_NONE: _bindgen_ty_26 =
    _bindgen_ty_26::RTE_PMD_IXGBE_BYPASS_MODE_NONE;
pub const RTE_PMD_IXGBE_BYPASS_MODE_NORMAL: _bindgen_ty_26 =
    _bindgen_ty_26::RTE_PMD_IXGBE_BYPASS_MODE_NORMAL;
pub const RTE_PMD_IXGBE_BYPASS_MODE_BYPASS: _bindgen_ty_26 =
    _bindgen_ty_26::RTE_PMD_IXGBE_BYPASS_MODE_BYPASS;
pub const RTE_PMD_IXGBE_BYPASS_MODE_ISOLATE: _bindgen_ty_26 =
    _bindgen_ty_26::RTE_PMD_IXGBE_BYPASS_MODE_ISOLATE;
pub const RTE_PMD_IXGBE_BYPASS_MODE_NUM: _bindgen_ty_26 =
    _bindgen_ty_26::RTE_PMD_IXGBE_BYPASS_MODE_NUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    RTE_PMD_IXGBE_BYPASS_MODE_NONE = 0,
    RTE_PMD_IXGBE_BYPASS_MODE_NORMAL = 1,
    RTE_PMD_IXGBE_BYPASS_MODE_BYPASS = 2,
    RTE_PMD_IXGBE_BYPASS_MODE_ISOLATE = 3,
    RTE_PMD_IXGBE_BYPASS_MODE_NUM = 4,
}
pub const RTE_PMD_IXGBE_BYPASS_EVENT_NONE: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_NONE;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_START: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_START;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_OS_ON: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_START;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_POWER_ON: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_POWER_ON;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_OS_OFF: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_OS_OFF;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_POWER_OFF: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_POWER_OFF;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_TIMEOUT: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_TIMEOUT;
pub const RTE_PMD_IXGBE_BYPASS_EVENT_NUM: _bindgen_ty_27 =
    _bindgen_ty_27::RTE_PMD_IXGBE_BYPASS_EVENT_NUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    RTE_PMD_IXGBE_BYPASS_EVENT_NONE = 0,
    RTE_PMD_IXGBE_BYPASS_EVENT_START = 1,
    RTE_PMD_IXGBE_BYPASS_EVENT_POWER_ON = 2,
    RTE_PMD_IXGBE_BYPASS_EVENT_OS_OFF = 3,
    RTE_PMD_IXGBE_BYPASS_EVENT_POWER_OFF = 4,
    RTE_PMD_IXGBE_BYPASS_EVENT_TIMEOUT = 5,
    RTE_PMD_IXGBE_BYPASS_EVENT_NUM = 6,
}
pub const RTE_PMD_IXGBE_BYPASS_TMT_OFF: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_OFF;
pub const RTE_PMD_IXGBE_BYPASS_TMT_1_5_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_1_5_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_2_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_2_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_3_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_3_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_4_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_4_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_8_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_8_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_16_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_16_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_32_SEC: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_32_SEC;
pub const RTE_PMD_IXGBE_BYPASS_TMT_NUM: _bindgen_ty_28 =
    _bindgen_ty_28::RTE_PMD_IXGBE_BYPASS_TMT_NUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 {
    RTE_PMD_IXGBE_BYPASS_TMT_OFF = 0,
    RTE_PMD_IXGBE_BYPASS_TMT_1_5_SEC = 1,
    RTE_PMD_IXGBE_BYPASS_TMT_2_SEC = 2,
    RTE_PMD_IXGBE_BYPASS_TMT_3_SEC = 3,
    RTE_PMD_IXGBE_BYPASS_TMT_4_SEC = 4,
    RTE_PMD_IXGBE_BYPASS_TMT_8_SEC = 5,
    RTE_PMD_IXGBE_BYPASS_TMT_16_SEC = 6,
    RTE_PMD_IXGBE_BYPASS_TMT_32_SEC = 7,
    RTE_PMD_IXGBE_BYPASS_TMT_NUM = 8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octeontx_ssovf_info {
    pub domain: u16,
    pub total_ssovfs: u8,
    pub total_ssowvfs: u8,
}
#[test]
fn bindgen_test_layout_octeontx_ssovf_info() {
    assert_eq!(::std::mem::size_of::<octeontx_ssovf_info>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( octeontx_ssovf_info ) ));
    assert_eq! (::std::mem::align_of::<octeontx_ssovf_info>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( octeontx_ssovf_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_ssovf_info ) ) . domain as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_ssovf_info ) ,
                "::" , stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_ssovf_info ) ) . total_ssovfs as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_ssovf_info ) ,
                "::" , stringify ! ( total_ssovfs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_ssovf_info ) ) . total_ssowvfs
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_ssovf_info ) ,
                "::" , stringify ! ( total_ssowvfs ) ));
}
impl Clone for octeontx_ssovf_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum octeontx_ssovf_type { OCTEONTX_SSO_GROUP = 0, OCTEONTX_SSO_HWS = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct octeontx_mbox_hdr {
    pub vfid: u16,
    pub coproc: u8,
    pub msg: u8,
    pub res_code: u8,
}
#[test]
fn bindgen_test_layout_octeontx_mbox_hdr() {
    assert_eq!(::std::mem::size_of::<octeontx_mbox_hdr>() , 6usize , concat !
               ( "Size of: " , stringify ! ( octeontx_mbox_hdr ) ));
    assert_eq! (::std::mem::align_of::<octeontx_mbox_hdr>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( octeontx_mbox_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_mbox_hdr ) ) . vfid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_mbox_hdr ) ,
                "::" , stringify ! ( vfid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_mbox_hdr ) ) . coproc as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_mbox_hdr ) ,
                "::" , stringify ! ( coproc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_mbox_hdr ) ) . msg as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_mbox_hdr ) ,
                "::" , stringify ! ( msg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const octeontx_mbox_hdr ) ) . res_code as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( octeontx_mbox_hdr ) ,
                "::" , stringify ! ( res_code ) ));
}
impl Clone for octeontx_mbox_hdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn octeontx_ssovf_info(info: *mut octeontx_ssovf_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn octeontx_ssovf_bar(arg1: octeontx_ssovf_type, id: u8, bar: u8)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn octeontx_ssovf_mbox_send(hdr: *mut octeontx_mbox_hdr,
                                    txdata: *mut ::std::os::raw::c_void,
                                    txlen: u16,
                                    rxdata: *mut ::std::os::raw::c_void,
                                    rxlen: u16) -> ::std::os::raw::c_int;
}
/// ethdev_reader port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ethdev_reader_params {
    /// NIC RX port ID
    pub port_id: u8,
    /// NIC RX queue ID
    pub queue_id: u16,
}
#[test]
fn bindgen_test_layout_rte_port_ethdev_reader_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ethdev_reader_params>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( rte_port_ethdev_reader_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ethdev_reader_params>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( rte_port_ethdev_reader_params
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_reader_params ) ) .
                port_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_reader_params ) , "::" , stringify ! ( port_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_reader_params ) ) .
                queue_id as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_reader_params ) , "::" , stringify ! (
                queue_id ) ));
}
impl Clone for rte_port_ethdev_reader_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ethdev_reader_ops"]
    pub static mut rte_port_ethdev_reader_ops: rte_port_in_ops;
}
/// ethdev_writer port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ethdev_writer_params {
    /// NIC RX port ID
    pub port_id: u8,
    /// NIC RX queue ID
    pub queue_id: u16,
    /// Recommended burst size to NIC TX queue. The actual burst size can be
    /// bigger or smaller than this value.
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_ethdev_writer_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ethdev_writer_params>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( rte_port_ethdev_writer_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ethdev_writer_params>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_port_ethdev_writer_params
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_params ) ) .
                port_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_params ) , "::" , stringify ! ( port_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_params ) ) .
                queue_id as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_params ) , "::" , stringify ! (
                queue_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_params ) ) .
                tx_burst_sz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
}
impl Clone for rte_port_ethdev_writer_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ethdev_writer_ops"]
    pub static mut rte_port_ethdev_writer_ops: rte_port_out_ops;
}
/// ethdev_writer_nodrop port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ethdev_writer_nodrop_params {
    /// NIC RX port ID
    pub port_id: u8,
    /// NIC RX queue ID
    pub queue_id: u16,
    /// Recommended burst size to NIC TX queue. The actual burst size can be
    /// bigger or smaller than this value.
    pub tx_burst_sz: u32,
    /// Maximum number of retries, 0 for no limit
    pub n_retries: u32,
}
#[test]
fn bindgen_test_layout_rte_port_ethdev_writer_nodrop_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ethdev_writer_nodrop_params>() ,
               12usize , concat ! (
               "Size of: " , stringify ! (
               rte_port_ethdev_writer_nodrop_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ethdev_writer_nodrop_params>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_ethdev_writer_nodrop_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_nodrop_params ) )
                . port_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_nodrop_params ) , "::" , stringify ! (
                port_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_nodrop_params ) )
                . queue_id as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_nodrop_params ) , "::" , stringify ! (
                queue_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_nodrop_params ) )
                . tx_burst_sz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_nodrop_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ethdev_writer_nodrop_params ) )
                . n_retries as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ethdev_writer_nodrop_params ) , "::" , stringify ! (
                n_retries ) ));
}
impl Clone for rte_port_ethdev_writer_nodrop_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ethdev_writer_nodrop_ops"]
    pub static mut rte_port_ethdev_writer_nodrop_ops: rte_port_out_ops;
}
/// fd_reader port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_fd_reader_params {
    /// File descriptor
    pub fd: ::std::os::raw::c_int,
    /// Maximum Transfer Unit (MTU)
    pub mtu: u32,
    /// Pre-initialized buffer pool
    pub mempool: *mut rte_mempool,
}
#[test]
fn bindgen_test_layout_rte_port_fd_reader_params() {
    assert_eq!(::std::mem::size_of::<rte_port_fd_reader_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_port_fd_reader_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_fd_reader_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_port_fd_reader_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_reader_params ) ) . fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_reader_params ) , "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_reader_params ) ) . mtu as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_reader_params ) , "::" , stringify ! ( mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_reader_params ) ) . mempool
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_reader_params ) , "::" , stringify ! ( mempool )
                ));
}
impl Clone for rte_port_fd_reader_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_fd_reader_ops"]
    pub static mut rte_port_fd_reader_ops: rte_port_in_ops;
}
/// fd_writer port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_fd_writer_params {
    /// File descriptor
    pub fd: ::std::os::raw::c_int,
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_fd_writer_params() {
    assert_eq!(::std::mem::size_of::<rte_port_fd_writer_params>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_port_fd_writer_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_fd_writer_params>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_port_fd_writer_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_writer_params ) ) . fd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_writer_params ) , "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_writer_params ) ) .
                tx_burst_sz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_writer_params ) , "::" , stringify ! ( tx_burst_sz
                ) ));
}
impl Clone for rte_port_fd_writer_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_fd_writer_ops"]
    pub static mut rte_port_fd_writer_ops: rte_port_out_ops;
}
/// fd_writer_nodrop port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_fd_writer_nodrop_params {
    /// File descriptor
    pub fd: ::std::os::raw::c_int,
    pub tx_burst_sz: u32,
    /// Maximum number of retries, 0 for no limit
    pub n_retries: u32,
}
#[test]
fn bindgen_test_layout_rte_port_fd_writer_nodrop_params() {
    assert_eq!(::std::mem::size_of::<rte_port_fd_writer_nodrop_params>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( rte_port_fd_writer_nodrop_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_fd_writer_nodrop_params>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_fd_writer_nodrop_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_writer_nodrop_params ) ) . fd
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_writer_nodrop_params ) , "::" , stringify ! ( fd )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_writer_nodrop_params ) ) .
                tx_burst_sz as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_writer_nodrop_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_fd_writer_nodrop_params ) ) .
                n_retries as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_fd_writer_nodrop_params ) , "::" , stringify ! (
                n_retries ) ));
}
impl Clone for rte_port_fd_writer_nodrop_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_fd_writer_nodrop_ops"]
    pub static mut rte_port_fd_writer_nodrop_ops: rte_port_out_ops;
}
/// ring_reader_ipv4_frag port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ring_reader_frag_params {
    /// Underlying single consumer ring that has to be pre-initialized.
    pub ring: *mut rte_ring,
    /// Maximum Transfer Unit (MTU). Maximum IP packet size (in bytes).
    pub mtu: u32,
    /// Size of application dependent meta-data stored per each input packet
    /// that has to be copied to each of the fragments originating from the
    /// same input IP datagram.
    pub metadata_size: u32,
    /// Pre-initialized buffer pool used for allocating direct buffers for
    /// the output fragments.
    pub pool_direct: *mut rte_mempool,
    /// Pre-initialized buffer pool used for allocating indirect buffers for
    /// the output fragments.
    pub pool_indirect: *mut rte_mempool,
}
#[test]
fn bindgen_test_layout_rte_port_ring_reader_frag_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ring_reader_frag_params>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( rte_port_ring_reader_frag_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_ring_reader_frag_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_ring_reader_frag_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_frag_params ) ) .
                ring as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_frag_params ) , "::" , stringify ! ( ring
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_frag_params ) ) .
                mtu as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_frag_params ) , "::" , stringify ! ( mtu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_frag_params ) ) .
                metadata_size as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_frag_params ) , "::" , stringify ! (
                metadata_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_frag_params ) ) .
                pool_direct as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_frag_params ) , "::" , stringify ! (
                pool_direct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_frag_params ) ) .
                pool_indirect as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_frag_params ) , "::" , stringify ! (
                pool_indirect ) ));
}
impl Clone for rte_port_ring_reader_frag_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ring_reader_ipv4_frag_ops"]
    pub static mut rte_port_ring_reader_ipv4_frag_ops: rte_port_in_ops;
}
extern "C" {
    #[link_name = "rte_port_ring_reader_ipv6_frag_ops"]
    pub static mut rte_port_ring_reader_ipv6_frag_ops: rte_port_in_ops;
}
/// kni_reader port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_kni_reader_params {
    /// KNI interface reference
    pub kni: *mut rte_kni,
}
#[test]
fn bindgen_test_layout_rte_port_kni_reader_params() {
    assert_eq!(::std::mem::size_of::<rte_port_kni_reader_params>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_port_kni_reader_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_kni_reader_params>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_port_kni_reader_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_reader_params ) ) . kni as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_reader_params ) , "::" , stringify ! ( kni ) ));
}
impl Clone for rte_port_kni_reader_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_kni_reader_ops"]
    pub static mut rte_port_kni_reader_ops: rte_port_in_ops;
}
/// kni_writer port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_kni_writer_params {
    /// KNI interface reference
    pub kni: *mut rte_kni,
    /// Burst size to KNI interface.
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_kni_writer_params() {
    assert_eq!(::std::mem::size_of::<rte_port_kni_writer_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_port_kni_writer_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_kni_writer_params>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_port_kni_writer_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_writer_params ) ) . kni as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_writer_params ) , "::" , stringify ! ( kni ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_writer_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_writer_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
}
impl Clone for rte_port_kni_writer_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_kni_writer_ops"]
    pub static mut rte_port_kni_writer_ops: rte_port_out_ops;
}
/// kni_writer_nodrop port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_kni_writer_nodrop_params {
    /// KNI interface reference
    pub kni: *mut rte_kni,
    /// Burst size to KNI interface.
    pub tx_burst_sz: u32,
    /// Maximum number of retries, 0 for no limit
    pub n_retries: u32,
}
#[test]
fn bindgen_test_layout_rte_port_kni_writer_nodrop_params() {
    assert_eq!(::std::mem::size_of::<rte_port_kni_writer_nodrop_params>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_port_kni_writer_nodrop_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_kni_writer_nodrop_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_kni_writer_nodrop_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_writer_nodrop_params ) ) .
                kni as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_writer_nodrop_params ) , "::" , stringify ! ( kni
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_writer_nodrop_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_writer_nodrop_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_kni_writer_nodrop_params ) ) .
                n_retries as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_kni_writer_nodrop_params ) , "::" , stringify ! (
                n_retries ) ));
}
impl Clone for rte_port_kni_writer_nodrop_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_kni_writer_nodrop_ops"]
    pub static mut rte_port_kni_writer_nodrop_ops: rte_port_out_ops;
}
/// ring_writer_ipv4_ras port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ring_writer_ras_params {
    /// Underlying single consumer ring that has to be pre-initialized.
    pub ring: *mut rte_ring,
    /// Recommended burst size to ring. The actual burst size can be bigger
    /// or smaller than this value.
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_ring_writer_ras_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ring_writer_ras_params>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_port_ring_writer_ras_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_ring_writer_ras_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_ring_writer_ras_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_ras_params ) ) .
                ring as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_ras_params ) , "::" , stringify ! ( ring
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_ras_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_ras_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
}
impl Clone for rte_port_ring_writer_ras_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ring_writer_ipv4_ras_ops"]
    pub static mut rte_port_ring_writer_ipv4_ras_ops: rte_port_out_ops;
}
extern "C" {
    #[link_name = "rte_port_ring_writer_ipv6_ras_ops"]
    pub static mut rte_port_ring_writer_ipv6_ras_ops: rte_port_out_ops;
}
/// ring_reader port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ring_reader_params {
    /// Underlying consumer ring that has to be pre-initialized
    pub ring: *mut rte_ring,
}
#[test]
fn bindgen_test_layout_rte_port_ring_reader_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ring_reader_params>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_port_ring_reader_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ring_reader_params>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_port_ring_reader_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_reader_params ) ) . ring as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_reader_params ) , "::" , stringify ! ( ring )
                ));
}
impl Clone for rte_port_ring_reader_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ring_reader_ops"]
    pub static mut rte_port_ring_reader_ops: rte_port_in_ops;
}
/// ring_writer port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ring_writer_params {
    /// Underlying producer ring that has to be pre-initialized
    pub ring: *mut rte_ring,
    /// Recommended burst size to ring. The actual burst size can be
    /// bigger or smaller than this value.
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_ring_writer_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ring_writer_params>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_port_ring_writer_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ring_writer_params>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( rte_port_ring_writer_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_params ) ) . ring as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_params ) , "::" , stringify ! ( ring )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
}
impl Clone for rte_port_ring_writer_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ring_writer_ops"]
    pub static mut rte_port_ring_writer_ops: rte_port_out_ops;
}
/// ring_writer_nodrop port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_ring_writer_nodrop_params {
    /// Underlying producer ring that has to be pre-initialized
    pub ring: *mut rte_ring,
    /// Recommended burst size to ring. The actual burst size can be
    /// bigger or smaller than this value.
    pub tx_burst_sz: u32,
    /// Maximum number of retries, 0 for no limit
    pub n_retries: u32,
}
#[test]
fn bindgen_test_layout_rte_port_ring_writer_nodrop_params() {
    assert_eq!(::std::mem::size_of::<rte_port_ring_writer_nodrop_params>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rte_port_ring_writer_nodrop_params
               ) ));
    assert_eq! (::std::mem::align_of::<rte_port_ring_writer_nodrop_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_port_ring_writer_nodrop_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_nodrop_params ) ) .
                ring as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_nodrop_params ) , "::" , stringify ! (
                ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_nodrop_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_nodrop_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_ring_writer_nodrop_params ) ) .
                n_retries as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_ring_writer_nodrop_params ) , "::" , stringify ! (
                n_retries ) ));
}
impl Clone for rte_port_ring_writer_nodrop_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_ring_writer_nodrop_ops"]
    pub static mut rte_port_ring_writer_nodrop_ops: rte_port_out_ops;
}
extern "C" {
    #[link_name = "rte_port_ring_multi_reader_ops"]
    pub static mut rte_port_ring_multi_reader_ops: rte_port_in_ops;
}
extern "C" {
    #[link_name = "rte_port_ring_multi_writer_ops"]
    pub static mut rte_port_ring_multi_writer_ops: rte_port_out_ops;
}
extern "C" {
    #[link_name = "rte_port_ring_multi_writer_nodrop_ops"]
    pub static mut rte_port_ring_multi_writer_nodrop_ops: rte_port_out_ops;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_subport_params {
    /// < Rate (measured in bytes per second)
    pub tb_rate: u32,
    /// < Size (measured in credits)
    pub tb_size: u32,
    pub tc_rate: [u32; 4usize],
    pub tc_period: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_subport_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_subport_params>() , 28usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_sched_subport_params ) ));
    assert_eq! (::std::mem::align_of::<rte_sched_subport_params>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_sched_subport_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tb_rate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_sched_subport_params ) , "::" , stringify ! ( tb_rate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tb_size as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_sched_subport_params ) , "::" , stringify ! ( tb_size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tc_rate as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_sched_subport_params ) , "::" , stringify ! ( tc_rate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tc_period
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_sched_subport_params ) , "::" , stringify ! ( tc_period )
                ));
}
impl Clone for rte_sched_subport_params {
    fn clone(&self) -> Self { *self }
}
/// Subport statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_subport_stats {
    pub n_pkts_tc: [u32; 4usize],
    pub n_pkts_tc_dropped: [u32; 4usize],
    pub n_bytes_tc: [u32; 4usize],
    pub n_bytes_tc_dropped: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_sched_subport_stats() {
    assert_eq!(::std::mem::size_of::<rte_sched_subport_stats>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_sched_subport_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_sched_subport_stats>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_sched_subport_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) . n_pkts_tc
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_subport_stats
                ) , "::" , stringify ! ( n_pkts_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) .
                n_pkts_tc_dropped as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_sched_subport_stats
                ) , "::" , stringify ! ( n_pkts_tc_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) . n_bytes_tc
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_subport_stats
                ) , "::" , stringify ! ( n_bytes_tc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) .
                n_bytes_tc_dropped as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_sched_subport_stats
                ) , "::" , stringify ! ( n_bytes_tc_dropped ) ));
}
impl Clone for rte_sched_subport_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_pipe_params {
    /// < Rate (measured in bytes per second)
    pub tb_rate: u32,
    /// < Size (measured in credits)
    pub tb_size: u32,
    pub tc_rate: [u32; 4usize],
    pub tc_period: u32,
    /// < WRR weights
    pub wrr_weights: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_sched_pipe_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_pipe_params>() , 44usize ,
               concat ! ( "Size of: " , stringify ! ( rte_sched_pipe_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_sched_pipe_params>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_sched_pipe_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tb_rate as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_pipe_params )
                , "::" , stringify ! ( tb_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tb_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_pipe_params )
                , "::" , stringify ! ( tb_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tc_rate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_pipe_params )
                , "::" , stringify ! ( tc_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tc_period as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_pipe_params )
                , "::" , stringify ! ( tc_period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . wrr_weights
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_pipe_params )
                , "::" , stringify ! ( wrr_weights ) ));
}
impl Clone for rte_sched_pipe_params {
    fn clone(&self) -> Self { *self }
}
/// Queue statistics
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_queue_stats {
    /// < Packets successfully written
    pub n_pkts: u32,
    /// < Packets dropped
    pub n_pkts_dropped: u32,
    /// < Bytes successfully written
    pub n_bytes: u32,
    /// < Bytes dropped
    pub n_bytes_dropped: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_queue_stats() {
    assert_eq!(::std::mem::size_of::<rte_sched_queue_stats>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_sched_queue_stats )
               ));
    assert_eq! (::std::mem::align_of::<rte_sched_queue_stats>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_sched_queue_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) . n_pkts as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_queue_stats )
                , "::" , stringify ! ( n_pkts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) .
                n_pkts_dropped as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_queue_stats )
                , "::" , stringify ! ( n_pkts_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) . n_bytes as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_queue_stats )
                , "::" , stringify ! ( n_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) .
                n_bytes_dropped as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_queue_stats )
                , "::" , stringify ! ( n_bytes_dropped ) ));
}
impl Clone for rte_sched_queue_stats {
    fn clone(&self) -> Self { *self }
}
/// Port configuration parameters.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_port_params {
    /// < String to be associated
    pub name: *const ::std::os::raw::c_char,
    /// < CPU socket ID
    pub socket: ::std::os::raw::c_int,
    /// < Output port rate
    /// (measured in bytes per second)
    pub rate: u32,
    /// < Maximum Ethernet frame size
    /// (measured in bytes).
    /// Should not include the framing overhead.
    pub mtu: u32,
    /// < Framing overhead per packet
    /// (measured in bytes)
    pub frame_overhead: u32,
    /// < Number of subports
    pub n_subports_per_port: u32,
    /// < Number of pipes per subport
    pub n_pipes_per_subport: u32,
    pub qsize: [u16; 4usize],
    pub pipe_profiles: *mut rte_sched_pipe_params,
    /// < Profiles in the pipe profile table
    pub n_pipe_profiles: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_port_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_port_params>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( rte_sched_port_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_sched_port_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_sched_port_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . socket as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . rate as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . mtu as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                frame_overhead as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( frame_overhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_subports_per_port as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( n_subports_per_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_pipes_per_subport as * const _ as usize } , 28usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( n_pipes_per_subport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . qsize as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( qsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . pipe_profiles
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( pipe_profiles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_pipe_profiles as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_sched_port_params )
                , "::" , stringify ! ( n_pipe_profiles ) ));
}
impl Clone for rte_sched_port_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_port {
    _unused: [u8; 0],
}
extern "C" {
    /// Hierarchical scheduler port configuration
///
/// @param params
/// Port scheduler configuration parameter structure
/// @return
/// Handle to port scheduler instance upon success or NULL otherwise.
    pub fn rte_sched_port_config(params: *mut rte_sched_port_params)
     -> *mut rte_sched_port;
}
extern "C" {
    /// Hierarchical scheduler port free
///
/// @param port
/// Handle to port scheduler instance
    pub fn rte_sched_port_free(port: *mut rte_sched_port);
}
extern "C" {
    /// Hierarchical scheduler subport configuration
///
/// @param port
/// Handle to port scheduler instance
/// @param subport_id
/// Subport ID
/// @param params
/// Subport configuration parameters
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_sched_subport_config(port: *mut rte_sched_port,
                                    subport_id: u32,
                                    params: *mut rte_sched_subport_params)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hierarchical scheduler pipe configuration
///
/// @param port
/// Handle to port scheduler instance
/// @param subport_id
/// Subport ID
/// @param pipe_id
/// Pipe ID within subport
/// @param pipe_profile
/// ID of port-level pre-configured pipe profile
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_sched_pipe_config(port: *mut rte_sched_port, subport_id: u32,
                                 pipe_id: u32, pipe_profile: i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hierarchical scheduler memory footprint size per port
///
/// @param params
/// Port scheduler configuration parameter structure
/// @return
/// Memory footprint size in bytes upon success, 0 otherwise
    pub fn rte_sched_port_get_memory_footprint(params:
                                                   *mut rte_sched_port_params)
     -> u32;
}
extern "C" {
    /// Hierarchical scheduler subport statistics read
///
/// @param port
/// Handle to port scheduler instance
/// @param subport_id
/// Subport ID
/// @param stats
/// Pointer to pre-allocated subport statistics structure where the statistics
/// counters should be stored
/// @param tc_ov
/// Pointer to pre-allocated 4-entry array where the oversubscription status for
/// each of the 4 subport traffic classes should be stored.
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_sched_subport_read_stats(port: *mut rte_sched_port,
                                        subport_id: u32,
                                        stats: *mut rte_sched_subport_stats,
                                        tc_ov: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hierarchical scheduler queue statistics read
///
/// @param port
/// Handle to port scheduler instance
/// @param queue_id
/// Queue ID within port scheduler
/// @param stats
/// Pointer to pre-allocated subport statistics structure where the statistics
/// counters should be stored
/// @param qlen
/// Pointer to pre-allocated variable where the current queue length
/// should be stored.
/// @return
/// 0 upon success, error code otherwise
    pub fn rte_sched_queue_read_stats(port: *mut rte_sched_port,
                                      queue_id: u32,
                                      stats: *mut rte_sched_queue_stats,
                                      qlen: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Scheduler hierarchy path write to packet descriptor. Typically
/// called by the packet classification stage.
///
/// @param pkt
/// Packet descriptor handle
/// @param subport
/// Subport ID
/// @param pipe
/// Pipe ID within subport
/// @param traffic_class
/// Traffic class ID within pipe (0 .. 3)
/// @param queue
/// Queue ID within pipe traffic class (0 .. 3)
/// @param color
/// Packet color set
    pub fn rte_sched_port_pkt_write(pkt: *mut rte_mbuf, subport: u32,
                                    pipe: u32, traffic_class: u32, queue: u32,
                                    color: rte_meter_color);
}
extern "C" {
    /// Scheduler hierarchy path read from packet descriptor (struct
/// rte_mbuf). Typically called as part of the hierarchical scheduler
/// enqueue operation. The subport, pipe, traffic class and queue
/// parameters need to be pre-allocated by the caller.
///
/// @param pkt
/// Packet descriptor handle
/// @param subport
/// Subport ID
/// @param pipe
/// Pipe ID within subport
/// @param traffic_class
/// Traffic class ID within pipe (0 .. 3)
/// @param queue
/// Queue ID within pipe traffic class (0 .. 3)
///
    pub fn rte_sched_port_pkt_read_tree_path(pkt: *const rte_mbuf,
                                             subport: *mut u32,
                                             pipe: *mut u32,
                                             traffic_class: *mut u32,
                                             queue: *mut u32);
}
extern "C" {
    pub fn rte_sched_port_pkt_read_color(pkt: *const rte_mbuf)
     -> rte_meter_color;
}
extern "C" {
    /// Hierarchical scheduler port enqueue. Writes up to n_pkts to port
/// scheduler and returns the number of packets actually written. For
/// each packet, the port scheduler queue to write the packet to is
/// identified by reading the hierarchy path from the packet
/// descriptor; if the queue is full or congested and the packet is not
/// written to the queue, then the packet is automatically dropped
/// without any action required from the caller.
///
/// @param port
/// Handle to port scheduler instance
/// @param pkts
/// Array storing the packet descriptor handles
/// @param n_pkts
/// Number of packets to enqueue from the pkts array into the port scheduler
/// @return
/// Number of packets successfully enqueued
    pub fn rte_sched_port_enqueue(port: *mut rte_sched_port,
                                  pkts: *mut *mut rte_mbuf, n_pkts: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hierarchical scheduler port dequeue. Reads up to n_pkts from the
/// port scheduler and stores them in the pkts array and returns the
/// number of packets actually read.  The pkts array needs to be
/// pre-allocated by the caller with at least n_pkts entries.
///
/// @param port
/// Handle to port scheduler instance
/// @param pkts
/// Pre-allocated packet descriptor array where the packets dequeued
/// from the port
/// scheduler should be stored
/// @param n_pkts
/// Number of packets to dequeue from the port scheduler
/// @return
/// Number of packets successfully dequeued and placed in the pkts array
    pub fn rte_sched_port_dequeue(port: *mut rte_sched_port,
                                  pkts: *mut *mut rte_mbuf, n_pkts: u32)
     -> ::std::os::raw::c_int;
}
/// sched_reader port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_sched_reader_params {
    /// Underlying pre-initialized rte_sched_port
    pub sched: *mut rte_sched_port,
}
#[test]
fn bindgen_test_layout_rte_port_sched_reader_params() {
    assert_eq!(::std::mem::size_of::<rte_port_sched_reader_params>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( rte_port_sched_reader_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_sched_reader_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_port_sched_reader_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_sched_reader_params ) ) . sched
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_sched_reader_params ) , "::" , stringify ! ( sched )
                ));
}
impl Clone for rte_port_sched_reader_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_sched_reader_ops"]
    pub static mut rte_port_sched_reader_ops: rte_port_in_ops;
}
/// sched_writer port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_sched_writer_params {
    /// Underlying pre-initialized rte_sched_port
    pub sched: *mut rte_sched_port,
    /// Recommended burst size. The actual burst size can be bigger or
    /// smaller than this value.
    pub tx_burst_sz: u32,
}
#[test]
fn bindgen_test_layout_rte_port_sched_writer_params() {
    assert_eq!(::std::mem::size_of::<rte_port_sched_writer_params>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rte_port_sched_writer_params ) ));
    assert_eq! (::std::mem::align_of::<rte_port_sched_writer_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_port_sched_writer_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_sched_writer_params ) ) . sched
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_sched_writer_params ) , "::" , stringify ! ( sched )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_sched_writer_params ) ) .
                tx_burst_sz as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_port_sched_writer_params ) , "::" , stringify ! (
                tx_burst_sz ) ));
}
impl Clone for rte_port_sched_writer_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_sched_writer_ops"]
    pub static mut rte_port_sched_writer_ops: rte_port_out_ops;
}
/// source port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_source_params {
    /// Pre-initialized buffer pool
    pub mempool: *mut rte_mempool,
    /// The full path of the pcap file to read packets from
    pub file_name: *const ::std::os::raw::c_char,
    /// The number of bytes to be read from each packet in the
    /// pcap file. If this value is 0, the whole packet is read;
    /// if it is bigger than packet size, the generated packets
    /// will contain the whole packet
    pub n_bytes_per_pkt: u32,
}
#[test]
fn bindgen_test_layout_rte_port_source_params() {
    assert_eq!(::std::mem::size_of::<rte_port_source_params>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( rte_port_source_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_source_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_port_source_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_source_params ) ) . mempool as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_source_params
                ) , "::" , stringify ! ( mempool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_source_params ) ) . file_name as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_source_params
                ) , "::" , stringify ! ( file_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_source_params ) ) .
                n_bytes_per_pkt as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_source_params
                ) , "::" , stringify ! ( n_bytes_per_pkt ) ));
}
impl Clone for rte_port_source_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_source_ops"]
    pub static mut rte_port_source_ops: rte_port_in_ops;
}
/// sink port parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_sink_params {
    /// The full path of the pcap file to write the packets to
    pub file_name: *const ::std::os::raw::c_char,
    /// The maximum number of packets write to the pcap file.
    /// If this value is 0, the "infinite" write will be carried
    /// out.
    pub max_n_pkts: u32,
}
#[test]
fn bindgen_test_layout_rte_port_sink_params() {
    assert_eq!(::std::mem::size_of::<rte_port_sink_params>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rte_port_sink_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_port_sink_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_port_sink_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_sink_params ) ) . file_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_sink_params )
                , "::" , stringify ! ( file_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_sink_params ) ) . max_n_pkts as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_port_sink_params )
                , "::" , stringify ! ( max_n_pkts ) ));
}
impl Clone for rte_port_sink_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_port_sink_ops"]
    pub static mut rte_port_sink_ops: rte_port_out_ops;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum power_management_env {
    PM_ENV_NOT_SET = 0,
    PM_ENV_ACPI_CPUFREQ = 1,
    PM_ENV_KVM_VM = 2,
}
extern "C" {
    /// Set the default power management implementation. If this is not called prior
/// to rte_power_init(), then auto-detect of the environment will take place.
/// It is not thread safe.
///
/// @param env
/// env. The environment in which to initialise Power Management for.
///
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_power_set_env(env: power_management_env)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unset the global environment configuration.
/// This can only be called after all threads have completed.
    pub fn rte_power_unset_env();
}
extern "C" {
    /// Get the default power management implementation.
///
/// @return
/// power_management_env The configured environment.
    pub fn rte_power_get_env() -> power_management_env;
}
extern "C" {
    /// Initialize power management for a specific lcore. If rte_power_set_env() has
/// not been called then an auto-detect of the environment will start and
/// initialise the corresponding resources.
///
/// @param lcore_id
/// lcore id.
///
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_power_init(lcore_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Exit power management on a specific lcore. This will call the environment
/// dependent exit function.
///
/// @param lcore_id
/// lcore id.
///
/// @return
/// - 0 on success.
/// - Negative on error.
    pub fn rte_power_exit(lcore_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
/// Get the available frequencies of a specific lcore.
/// Function pointer definition. Review each environments
/// specific documentation for usage.
///
/// @param lcore_id
/// lcore id.
/// @param freqs
/// The buffer array to save the frequencies.
/// @param num
/// The number of frequencies to get.
///
/// @return
/// The number of available frequencies.
pub type rte_power_freqs_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint,
                                               freqs: *mut u32, num: u32)
                              -> u32>;
extern "C" {
    #[link_name = "rte_power_freqs"]
    pub static mut rte_power_freqs: rte_power_freqs_t;
}
/// Return the current index of available frequencies of a specific lcore.
/// Function pointer definition. Review each environments
/// specific documentation for usage.
///
/// @param lcore_id
/// lcore id.
///
/// @return
/// The current index of available frequencies.
pub type rte_power_get_freq_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint)
                              -> u32>;
extern "C" {
    #[link_name = "rte_power_get_freq"]
    pub static mut rte_power_get_freq: rte_power_get_freq_t;
}
/// Set the new frequency for a specific lcore by indicating the index of
/// available frequencies.
/// Function pointer definition. Review each environments
/// specific documentation for usage.
///
/// @param lcore_id
/// lcore id.
/// @param index
/// The index of available frequencies.
///
/// @return
/// - 1 on success with frequency changed.
/// - 0 on success without frequency changed.
/// - Negative on error.
pub type rte_power_set_freq_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint,
                                               index: u32)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "rte_power_set_freq"]
    pub static mut rte_power_set_freq: rte_power_set_freq_t;
}
/// Function pointer definition for generic frequency change functions. Review
/// each environments specific documentation for usage.
///
/// @param lcore_id
/// lcore id.
///
/// @return
/// - 1 on success with frequency changed.
/// - 0 on success without frequency changed.
/// - Negative on error.
pub type rte_power_freq_change_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "rte_power_freq_up"]
    pub static mut rte_power_freq_up: rte_power_freq_change_t;
}
extern "C" {
    #[link_name = "rte_power_freq_down"]
    pub static mut rte_power_freq_down: rte_power_freq_change_t;
}
extern "C" {
    #[link_name = "rte_power_freq_max"]
    pub static mut rte_power_freq_max: rte_power_freq_change_t;
}
extern "C" {
    #[link_name = "rte_power_freq_min"]
    pub static mut rte_power_freq_min: rte_power_freq_change_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_reciprocal {
    pub m: u32,
    pub sh1: u8,
    pub sh2: u8,
}
#[test]
fn bindgen_test_layout_rte_reciprocal() {
    assert_eq!(::std::mem::size_of::<rte_reciprocal>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_reciprocal ) ));
    assert_eq! (::std::mem::align_of::<rte_reciprocal>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_reciprocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . m as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_reciprocal ) , "::"
                , stringify ! ( m ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . sh1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_reciprocal ) , "::"
                , stringify ! ( sh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . sh2 as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_reciprocal ) , "::"
                , stringify ! ( sh2 ) ));
}
impl Clone for rte_reciprocal {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rte_reciprocal_value(d: u32) -> rte_reciprocal;
}
extern "C" {
    #[link_name = "rte_red_rand_val"]
    pub static mut rte_red_rand_val: u32;
}
extern "C" {
    #[link_name = "rte_red_rand_seed"]
    pub static mut rte_red_rand_seed: u32;
}
extern "C" {
    #[link_name = "rte_red_log2_1_minus_Wq"]
    pub static mut rte_red_log2_1_minus_Wq: [u16; 12usize];
}
extern "C" {
    #[link_name = "rte_red_pow2_frac_inv"]
    pub static mut rte_red_pow2_frac_inv: [u16; 16usize];
}
/// RED configuration parameters passed by user
///
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red_params {
    /// < Minimum threshold for queue (max_th)
    pub min_th: u16,
    /// < Maximum threshold for queue (max_th)
    pub max_th: u16,
    /// < Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv)
    pub maxp_inv: u16,
    /// < Negated log2 of queue weight (wq = 1 / (2 ^ wq_log2))
    pub wq_log2: u16,
}
#[test]
fn bindgen_test_layout_rte_red_params() {
    assert_eq!(::std::mem::size_of::<rte_red_params>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rte_red_params ) ));
    assert_eq! (::std::mem::align_of::<rte_red_params>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rte_red_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . min_th as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_params ) , "::"
                , stringify ! ( min_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . max_th as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_params ) , "::"
                , stringify ! ( max_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . maxp_inv as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_params ) , "::"
                , stringify ! ( maxp_inv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . wq_log2 as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_params ) , "::"
                , stringify ! ( wq_log2 ) ));
}
impl Clone for rte_red_params {
    fn clone(&self) -> Self { *self }
}
/// RED configuration parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red_config {
    /// < min_th scaled in fixed-point format
    pub min_th: u32,
    /// < max_th scaled in fixed-point format
    pub max_th: u32,
    /// < Precomputed constant value used for pa calculation (scaled in fixed-point format)
    pub pa_const: u32,
    /// < maxp_inv
    pub maxp_inv: u8,
    /// < wq_log2
    pub wq_log2: u8,
}
#[test]
fn bindgen_test_layout_rte_red_config() {
    assert_eq!(::std::mem::size_of::<rte_red_config>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_red_config ) ));
    assert_eq! (::std::mem::align_of::<rte_red_config>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_red_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . min_th as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_config ) , "::"
                , stringify ! ( min_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . max_th as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_config ) , "::"
                , stringify ! ( max_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . pa_const as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_config ) , "::"
                , stringify ! ( pa_const ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . maxp_inv as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_config ) , "::"
                , stringify ! ( maxp_inv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . wq_log2 as * const _
                as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red_config ) , "::"
                , stringify ! ( wq_log2 ) ));
}
impl Clone for rte_red_config {
    fn clone(&self) -> Self { *self }
}
/// RED run-time data
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red {
    /// < Average queue size (avg), scaled in fixed-point format
    pub avg: u32,
    /// < Number of packets since last marked packet (count)
    pub count: u32,
    /// < Start of the queue idle time (q_time)
    pub q_time: u64,
}
#[test]
fn bindgen_test_layout_rte_red() {
    assert_eq!(::std::mem::size_of::<rte_red>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rte_red ) ));
    assert_eq! (::std::mem::align_of::<rte_red>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . avg as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red ) , "::" ,
                stringify ! ( avg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . count as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . q_time as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_red ) , "::" ,
                stringify ! ( q_time ) ));
}
impl Clone for rte_red {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// @brief Initialises run-time data
///
/// @param red [in,out] data pointer to RED runtime data
///
/// @return Operation status
/// @retval 0 success
/// @retval !0 error
    pub fn rte_red_rt_data_init(red: *mut rte_red) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Configures a single RED configuration parameter structure.
///
/// @param red_cfg [in,out] config pointer to a RED configuration parameter structure
/// @param wq_log2 [in]  log2 of the filter weight, valid range is:
/// RTE_RED_WQ_LOG2_MIN <= wq_log2 <= RTE_RED_WQ_LOG2_MAX
/// @param min_th [in] queue minimum threshold in number of packets
/// @param max_th [in] queue maximum threshold in number of packets
/// @param maxp_inv [in] inverse maximum mark probability
///
/// @return Operation status
/// @retval 0 success
/// @retval !0 error
    pub fn rte_red_config_init(red_cfg: *mut rte_red_config, wq_log2: u16,
                               min_th: u16, max_th: u16, maxp_inv: u16)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_reorder_buffer {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a new reorder buffer instance
///
/// Allocate memory and initialize a new reorder buffer in that
/// memory, returning the reorder buffer pointer to the user
///
/// @param name
/// The name to be given to the reorder buffer instance.
/// @param socket_id
/// The NUMA node on which the memory for the reorder buffer
/// instance is to be reserved.
/// @param size
/// Max number of elements that can be stored in the reorder buffer
/// @return
/// The initialized reorder buffer instance, or NULL on error
/// On error case, rte_errno will be set appropriately:
/// - ENOMEM - no appropriate memory area found in which to create memzone
/// - EINVAL - invalid parameters
    pub fn rte_reorder_create(name: *const ::std::os::raw::c_char,
                              socket_id: ::std::os::raw::c_uint,
                              size: ::std::os::raw::c_uint)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /// Initializes given reorder buffer instance
///
/// @param b
/// Reorder buffer instance to initialize
/// @param bufsize
/// Size of the reorder buffer
/// @param name
/// The name to be given to the reorder buffer
/// @param size
/// Number of elements that can be stored in reorder buffer
/// @return
/// The initialized reorder buffer instance, or NULL on error
/// On error case, rte_errno will be set appropriately:
/// - EINVAL - invalid parameters
    pub fn rte_reorder_init(b: *mut rte_reorder_buffer,
                            bufsize: ::std::os::raw::c_uint,
                            name: *const ::std::os::raw::c_char,
                            size: ::std::os::raw::c_uint)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /// Find an existing reorder buffer instance
/// and return a pointer to it.
///
/// @param name
/// Name of the reorder buffer instacne as passed to rte_reorder_create()
/// @return
/// Pointer to reorder buffer instance or NULL if object not found with rte_errno
/// set appropriately. Possible rte_errno values include:
/// - ENOENT - required entry not available to return.
/// reorder instance list
    pub fn rte_reorder_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /// Reset the given reorder buffer instance with initial values.
///
/// @param b
/// Reorder buffer instance which has to be reset
    pub fn rte_reorder_reset(b: *mut rte_reorder_buffer);
}
extern "C" {
    /// Free reorder buffer instance.
///
/// @param b
/// reorder buffer instance
/// @return
/// None
    pub fn rte_reorder_free(b: *mut rte_reorder_buffer);
}
extern "C" {
    /// Insert given mbuf in reorder buffer in its correct position
///
/// The given mbuf is to be reordered relative to other mbufs in the system.
/// The mbuf must contain a sequence number which is then used to place
/// the buffer in the correct position in the reorder buffer. Reordered
/// packets can later be taken from the buffer using the rte_reorder_drain()
/// API.
///
/// @param b
/// Reorder buffer where the mbuf has to be inserted.
/// @param mbuf
/// mbuf of packet that needs to be inserted in reorder buffer.
/// @return
/// 0 on success
/// -1 on error
/// On error case, rte_errno will be set appropriately:
/// - ENOSPC - Cannot move existing mbufs from reorder buffer to accommodate
/// ealry mbuf, but it can be accommodated by performing drain and then insert.
/// - ERANGE - Too early or late mbuf which is vastly out of range of expected
/// window should be ingnored without any handling.
    pub fn rte_reorder_insert(b: *mut rte_reorder_buffer, mbuf: *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Fetch reordered buffers
///
/// Returns a set of in-order buffers from the reorder buffer structure. Gaps
/// may be present in the sequence numbers of the mbuf if packets have been
/// delayed too long before reaching the reorder window, or have been previously
/// dropped by the system.
///
/// @param b
/// Reorder buffer instance from which packets are to be drained
/// @param mbufs
/// array of mbufs where reordered packets will be inserted from reorder buffer
/// @param max_mbufs
/// the number of elements in the mbufs array.
/// @return
/// number of mbuf pointers written to mbufs. 0 <= N < max_mbufs.
    pub fn rte_reorder_drain(b: *mut rte_reorder_buffer,
                             mbufs: *mut *mut rte_mbuf,
                             max_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
/// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// The specification of a service.
///
/// This struct contains metadata about the service itself, the callback
/// function to run one iteration of the service, a userdata pointer, flags etc.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_service_spec {
    /// The name of the service. This should be used by the application to
    /// understand what purpose this service provides.
    pub name: [::std::os::raw::c_char; 32usize],
    /// The callback to invoke to run one iteration of the service.
    pub callback: rte_service_func,
    /// The userdata pointer provided to the service callback.
    pub callback_userdata: *mut ::std::os::raw::c_void,
    /// Flags to indicate the capabilities of this service. See defines in
    /// the public header file for values of RTE_SERVICE_CAP_*
    pub capabilities: u32,
    /// NUMA socket ID that this service is affinitized to
    pub socket_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_service_spec() {
    assert_eq!(::std::mem::size_of::<rte_service_spec>() , 56usize , concat !
               ( "Size of: " , stringify ! ( rte_service_spec ) ));
    assert_eq! (::std::mem::align_of::<rte_service_spec>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_service_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_service_spec ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_service_spec ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_service_spec ) ) . callback as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_service_spec ) ,
                "::" , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_service_spec ) ) . callback_userdata
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_service_spec ) ,
                "::" , stringify ! ( callback_userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_service_spec ) ) . capabilities as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_service_spec ) ,
                "::" , stringify ! ( capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_service_spec ) ) . socket_id as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_service_spec ) ,
                "::" , stringify ! ( socket_id ) ));
}
impl Clone for rte_service_spec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Return the number of services registered.
///
/// The number of services registered can be passed to *rte_service_get_by_id*,
/// enabling the application to retrieve the specification of each service.
///
/// @return The number of services registered.
    pub fn rte_service_get_count() -> u32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Return the specification of a service by integer id.
///
/// This function provides the specification of a service. This can be used by
/// the application to understand what the service represents. The service
/// must not be modified by the application directly, only passed to the various
/// rte_service_* functions.
///
/// @param id The integer id of the service to retrieve
/// @retval non-zero A valid pointer to the service_spec
/// @retval NULL Invalid *id* provided.
    pub fn rte_service_get_by_id(id: u32) -> *mut rte_service_spec;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Return the specification of a service by name.
///
/// This function provides the specification of a service using the service name
/// as lookup key. This can be used by the application to understand what the
/// service represents. The service must not be modified by the application
/// directly, only passed to the various rte_service_* functions.
///
/// @param name The name of the service to retrieve
/// @retval non-zero A valid pointer to the service_spec
/// @retval NULL Invalid *name* provided.
    pub fn rte_service_get_by_name(name: *const ::std::os::raw::c_char)
     -> *mut rte_service_spec;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Return the name of the service.
///
/// @return A pointer to the name of the service. The returned pointer remains
/// in ownership of the service, and the application must not free it.
    pub fn rte_service_get_name(service: *const rte_service_spec)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Check if a service has a specific capability.
///
/// This function returns if *service* has implements *capability*.
/// See RTE_SERVICE_CAP_* defines for a list of valid capabilities.
/// @retval 1 Capability supported by this service instance
/// @retval 0 Capability not supported by this service instance
    pub fn rte_service_probe_capability(service: *const rte_service_spec,
                                        capability: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Enable a core to run a service.
///
/// Each core can be added or removed from running specific services. This
/// functions adds *lcore* to the set of cores that will run *service*.
///
/// If multiple cores are enabled on a service, an atomic is used to ensure that
/// only one cores runs the service at a time. The exception to this is when
/// a service indicates that it is multi-thread safe by setting the capability
/// called RTE_SERVICE_CAP_MT_SAFE. With the multi-thread safe capability set,
/// the service function can be run on multiple threads at the same time.
///
/// @retval 0 lcore added successfully
/// @retval -EINVAL An invalid service or lcore was provided.
    pub fn rte_service_enable_on_lcore(service: *mut rte_service_spec,
                                       lcore: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Disable a core to run a service.
///
/// Each core can be added or removed from running specific services. This
/// functions removes *lcore* to the set of cores that will run *service*.
///
/// @retval 0 Lcore removed successfully
/// @retval -EINVAL An invalid service or lcore was provided.
    pub fn rte_service_disable_on_lcore(service: *mut rte_service_spec,
                                        lcore: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Return if an lcore is enabled for the service.
///
/// This function allows the application to query if *lcore* is currently set to
/// run *service*.
///
/// @retval 1 Lcore enabled on this lcore
/// @retval 0 Lcore disabled on this lcore
/// @retval -EINVAL An invalid service or lcore was provided.
    pub fn rte_service_get_enabled_on_lcore(service: *mut rte_service_spec,
                                            lcore: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Enable *service* to run.
///
/// This function switches on a service during runtime.
/// @retval 0 The service was successfully started
    pub fn rte_service_start(service: *mut rte_service_spec) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Disable *service*.
///
/// Switch off a service, so it is not run until it is *rte_service_start* is
/// called on it.
/// @retval 0 Service successfully switched off
    pub fn rte_service_stop(service: *mut rte_service_spec) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Returns if *service* is currently running.
///
/// This function returns true if the service has been started using
/// *rte_service_start*, AND a service core is mapped to the service. This
/// function can be used to ensure that the service will be run.
///
/// @retval 1 Service is currently running, and has a service lcore mapped
/// @retval 0 Service is currently stopped, or no service lcore is mapped
/// @retval -EINVAL Invalid service pointer provided
    pub fn rte_service_is_running(service: *const rte_service_spec) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Start a service core.
///
/// Starting a core makes the core begin polling. Any services assigned to it
/// will be run as fast as possible.
///
/// @retval 0 Success
/// @retval -EINVAL Failed to start core. The *lcore_id* passed in is not
/// currently assigned to be a service core.
    pub fn rte_service_lcore_start(lcore_id: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Stop a service core.
///
/// Stopping a core makes the core become idle, but remains  assigned as a
/// service core.
///
/// @retval 0 Success
/// @retval -EINVAL Invalid *lcore_id* provided
/// @retval -EALREADY Already stopped core
/// @retval -EBUSY Failed to stop core, as it would cause a service to not
/// be run, as this is the only core currently running the service.
/// The application must stop the service first, and then stop the
/// lcore.
    pub fn rte_service_lcore_stop(lcore_id: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Adds lcore to the list of service cores.
///
/// This functions can be used at runtime in order to modify the service core
/// mask.
///
/// @retval 0 Success
/// @retval -EBUSY lcore is busy, and not available for service core duty
/// @retval -EALREADY lcore is already added to the service core list
/// @retval -EINVAL Invalid lcore provided
    pub fn rte_service_lcore_add(lcore: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Removes lcore from the list of service cores.
///
/// This can fail if the core is not stopped, see *rte_service_core_stop*.
///
/// @retval 0 Success
/// @retval -EBUSY Lcore is not stopped, stop service core before removing.
/// @retval -EINVAL failed to add lcore to service core mask.
    pub fn rte_service_lcore_del(lcore: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Retrieve the number of service cores currently available.
///
/// This function returns the integer count of service cores available. The
/// service core count can be used in mapping logic when creating mappings
/// from service cores to services.
///
/// See *rte_service_lcore_list* for details on retrieving the lcore_id of each
/// service core.
///
/// @return The number of service cores currently configured.
    pub fn rte_service_lcore_count() -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Resets all service core mappings. This does not remove the service cores
/// from duty, just unmaps all services / cores, and stops() the service cores.
/// The runstate of services is not modified.
///
/// @retval 0 Success
    pub fn rte_service_lcore_reset_all() -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Enable or disable statistics collection for *service*.
///
/// This function enables per core, per-service cycle count collection.
/// @param service The service to enable statistics gathering on.
/// @param enable Zero to disable statistics, non-zero to enable.
/// @retval 0 Success
/// @retval -EINVAL Invalid service pointer passed
    pub fn rte_service_set_stats_enable(service: *mut rte_service_spec,
                                        enable: i32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Retrieve the list of currently enabled service cores.
///
/// This function fills in an application supplied array, with each element
/// indicating the lcore_id of a service core.
///
/// Adding and removing service cores can be performed using
/// *rte_service_lcore_add* and *rte_service_lcore_del*.
/// @param [out] array An array of at least *rte_service_lcore_count* items.
/// If statically allocating the buffer, use RTE_MAX_LCORE.
/// @param [out] n The size of *array*.
/// @retval >=0 Number of service cores that have been populated in the array
/// @retval -ENOMEM The provided array is not large enough to fill in the
/// service core list. No items have been populated, call this function
/// with a size of at least *rte_service_core_count* items.
    pub fn rte_service_lcore_list(array: *mut u32, n: u32) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Dumps any information available about the service. If service is NULL,
/// dumps info for all services.
    pub fn rte_service_dump(f: *mut FILE, service: *mut rte_service_spec)
     -> i32;
}
/// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Signature of callback function to run a service.
pub type rte_service_func =
    ::std::option::Option<unsafe extern "C" fn(args:
                                                   *mut ::std::os::raw::c_void)
                              -> i32>;
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Register a new service.
///
/// A service represents a component that the requires CPU time periodically to
/// achieve its purpose.
///
/// For example the eventdev SW PMD requires CPU cycles to perform its
/// scheduling. This can be achieved by registering it as a service, and the
/// application can then assign CPU resources to it using
/// *rte_service_set_coremask*.
///
/// @param spec The specification of the service to register
/// @retval 0 Successfully registered the service.
/// -EINVAL Attempted to register an invalid service (eg, no callback
/// set)
    pub fn rte_service_register(spec: *const rte_service_spec) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Unregister a service.
///
/// The service being removed must be stopped before calling this function.
///
/// @retval 0 The service was successfully unregistered.
/// @retval -EBUSY The service is currently running, stop the service before
/// calling unregister. No action has been taken.
    pub fn rte_service_unregister(service: *mut rte_service_spec) -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Private function to allow EAL to initialized default mappings.
///
/// This function iterates all the services, and maps then to the available
/// cores. Based on the capabilities of the services, they are set to run on the
/// available cores in a round-robin manner.
///
/// @retval 0 Success
/// @retval -ENOTSUP No service lcores in use
/// @retval -EINVAL Error while iterating over services
/// @retval -ENODEV Error in enabling service lcore on a service
/// @retval -ENOEXEC Error when starting services
    pub fn rte_service_start_with_defaults() -> i32;
}
extern "C" {
    /// @warning
/// @b EXPERIMENTAL: this API may change without prior notice
///
/// Initialize the service library.
///
/// In order to use the service library, it must be initialized. EAL initializes
/// the library at startup.
///
/// @retval 0 Success
/// @retval -EALREADY Service library is already initialized
    pub fn rte_service_init() -> i32;
}
/// ACL table parameters
#[repr(C)]
pub struct rte_table_acl_params {
    /// Name
    pub name: *const ::std::os::raw::c_char,
    /// Maximum number of ACL rules in the table
    pub n_rules: u32,
    /// Number of fields in the ACL rule specification
    pub n_rule_fields: u32,
    /// Format specification of the fields of the ACL rule
    pub field_format: [rte_acl_field_def; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_params>() , 528usize ,
               concat ! ( "Size of: " , stringify ! ( rte_table_acl_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_acl_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_acl_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_acl_params )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . n_rules as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_acl_params )
                , "::" , stringify ! ( n_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . n_rule_fields
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_acl_params )
                , "::" , stringify ! ( n_rule_fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . field_format
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_acl_params )
                , "::" , stringify ! ( field_format ) ));
}
/// ACL rule specification for entry add operation
#[repr(C)]
pub struct rte_table_acl_rule_add_params {
    /// ACL rule priority, with 0 as the highest priority
    pub priority: i32,
    /// Values for the fields of the ACL rule to be added to the table
    pub field_value: [rte_acl_field; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_rule_add_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_rule_add_params>() ,
               1032usize , concat ! (
               "Size of: " , stringify ! ( rte_table_acl_rule_add_params ) ));
    assert_eq! (::std::mem::align_of::<rte_table_acl_rule_add_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_table_acl_rule_add_params
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_add_params ) ) .
                priority as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_acl_rule_add_params ) , "::" , stringify ! (
                priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_add_params ) ) .
                field_value as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_acl_rule_add_params ) , "::" , stringify ! (
                field_value ) ));
}
/// ACL rule specification for entry delete operation
#[repr(C)]
pub struct rte_table_acl_rule_delete_params {
    /// Values for the fields of the ACL rule to be deleted from table
    pub field_value: [rte_acl_field; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_rule_delete_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_rule_delete_params>() ,
               1024usize , concat ! (
               "Size of: " , stringify ! ( rte_table_acl_rule_delete_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_acl_rule_delete_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_table_acl_rule_delete_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_delete_params ) ) .
                field_value as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_acl_rule_delete_params ) , "::" , stringify ! (
                field_value ) ));
}
extern "C" {
    #[link_name = "rte_table_acl_ops"]
    pub static mut rte_table_acl_ops: rte_table_ops;
}
/// Array table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_array_params {
    /// Number of array entries. Has to be a power of two.
    pub n_entries: u32,
    /// Byte offset within input packet meta-data where lookup key (i.e. the
    /// array entry index) is located.
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_array_params() {
    assert_eq!(::std::mem::size_of::<rte_table_array_params>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rte_table_array_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_array_params>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_array_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_params ) ) . n_entries as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_array_params
                ) , "::" , stringify ! ( n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_params ) ) . offset as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_array_params
                ) , "::" , stringify ! ( offset ) ));
}
impl Clone for rte_table_array_params {
    fn clone(&self) -> Self { *self }
}
/// Array table key format
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_array_key {
    /// Array entry index
    pub pos: u32,
}
#[test]
fn bindgen_test_layout_rte_table_array_key() {
    assert_eq!(::std::mem::size_of::<rte_table_array_key>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( rte_table_array_key ) ));
    assert_eq! (::std::mem::align_of::<rte_table_array_key>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_array_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_key ) ) . pos as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_array_key ) ,
                "::" , stringify ! ( pos ) ));
}
impl Clone for rte_table_array_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_array_ops"]
    pub static mut rte_table_array_ops: rte_table_ops;
}
/// Hash function
pub type rte_table_hash_op_hash =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *mut ::std::os::raw::c_void,
                                               key_size: u32, seed: u64)
                              -> u64>;
/// Hash tables with configurable key size
///
/// /
/// /** Extendible bucket hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_ext_params {
    /// Key size (number of bytes)
    pub key_size: u32,
    /// Maximum number of keys
    pub n_keys: u32,
    /// Number of hash table buckets. Each bucket stores up to 4 keys.
    pub n_buckets: u32,
    /// Number of hash table bucket extensions. Each bucket extension has
    /// space for 4 keys and each bucket can have 0, 1 or more extensions.
    pub n_buckets_ext: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed value for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_ext_params>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_table_hash_ext_params ) ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_ext_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_hash_ext_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . key_size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( key_size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . n_keys as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( n_keys )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . n_buckets
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( n_buckets )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                n_buckets_ext as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! (
                n_buckets_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . f_hash as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( f_hash )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . seed as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( seed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                signature_offset as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                key_offset as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_ext_params ) , "::" , stringify ! ( key_offset
                ) ));
}
impl Clone for rte_table_hash_ext_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_ext_ops"]
    pub static mut rte_table_hash_ext_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_ext_dosig_ops"]
    pub static mut rte_table_hash_ext_dosig_ops: rte_table_ops;
}
/// LRU hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_lru_params {
    /// Key size (number of bytes)
    pub key_size: u32,
    /// Maximum number of keys
    pub n_keys: u32,
    /// Number of hash table buckets. Each bucket stores up to 4 keys.
    pub n_buckets: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed value for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_lru_params>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_table_hash_lru_params ) ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_lru_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_hash_lru_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . key_size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( key_size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . n_keys as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( n_keys )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . n_buckets
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( n_buckets )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . f_hash as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( f_hash )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . seed as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( seed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) .
                signature_offset as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) .
                key_offset as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_lru_params ) , "::" , stringify ! ( key_offset
                ) ));
}
impl Clone for rte_table_hash_lru_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_lru_ops"]
    pub static mut rte_table_hash_lru_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_lru_dosig_ops"]
    pub static mut rte_table_hash_lru_dosig_ops: rte_table_ops;
}
/// 8-byte key hash tables
///
/// /
/// /** LRU hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key8_lru_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
    /// Bit-mask to be AND-ed to the key on lookup
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key8_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key8_lru_params>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key8_lru_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key8_lru_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_table_hash_key8_lru_params
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! ( f_hash
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) . seed
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! ( seed )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! (
                key_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                key_mask as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_lru_params ) , "::" , stringify ! (
                key_mask ) ));
}
impl Clone for rte_table_hash_key8_lru_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key8_lru_ops"]
    pub static mut rte_table_hash_key8_lru_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_key8_lru_dosig_ops"]
    pub static mut rte_table_hash_key8_lru_dosig_ops: rte_table_ops;
}
/// Extendible bucket hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key8_ext_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Number of entries (and keys) for hash table bucket extensions. Each
    /// bucket is extended in increments of 4 keys.
    pub n_entries_ext: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
    /// Bit-mask to be AND-ed to the key on lookup
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key8_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key8_ext_params>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key8_ext_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key8_ext_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_table_hash_key8_ext_params
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! (
                n_entries_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! ( f_hash
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) . seed
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! ( seed )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! (
                key_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                key_mask as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key8_ext_params ) , "::" , stringify ! (
                key_mask ) ));
}
impl Clone for rte_table_hash_key8_ext_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key8_ext_ops"]
    pub static mut rte_table_hash_key8_ext_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_key8_ext_dosig_ops"]
    pub static mut rte_table_hash_key8_ext_dosig_ops: rte_table_ops;
}
/// 16-byte key hash tables
///
/// /
/// /** LRU hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key16_lru_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
    /// Bit-mask to be AND-ed to the key on lookup
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key16_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key16_lru_params>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key16_lru_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key16_lru_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_table_hash_key16_lru_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! (
                f_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                seed as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! ( seed
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! (
                key_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                key_mask as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_lru_params ) , "::" , stringify ! (
                key_mask ) ));
}
impl Clone for rte_table_hash_key16_lru_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key16_lru_ops"]
    pub static mut rte_table_hash_key16_lru_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_key16_lru_dosig_ops"]
    pub static mut rte_table_hash_key16_lru_dosig_ops: rte_table_ops;
}
/// Extendible bucket hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key16_ext_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Number of entries (and keys) for hash table bucket extensions. Each
    /// bucket is extended in increments of 4 keys.
    pub n_entries_ext: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
    /// Bit-mask to be AND-ed to the key on lookup
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key16_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key16_ext_params>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key16_ext_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key16_ext_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_table_hash_key16_ext_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                n_entries_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                f_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                seed as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! ( seed
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                key_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                key_mask as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key16_ext_params ) , "::" , stringify ! (
                key_mask ) ));
}
impl Clone for rte_table_hash_key16_ext_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key16_ext_ops"]
    pub static mut rte_table_hash_key16_ext_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_hash_key16_ext_dosig_ops"]
    pub static mut rte_table_hash_key16_ext_dosig_ops: rte_table_ops;
}
/// 32-byte key hash tables
///
/// /
/// /** LRU hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key32_lru_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key32_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key32_lru_params>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key32_lru_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key32_lru_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_table_hash_key32_lru_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_lru_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_lru_params ) , "::" , stringify ! (
                f_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                seed as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_lru_params ) , "::" , stringify ! ( seed
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_lru_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_lru_params ) , "::" , stringify ! (
                key_offset ) ));
}
impl Clone for rte_table_hash_key32_lru_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key32_lru_ops"]
    pub static mut rte_table_hash_key32_lru_ops: rte_table_ops;
}
/// Extendible bucket hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key32_ext_params {
    /// Maximum number of entries (and keys) in the table
    pub n_entries: u32,
    /// Number of entries (and keys) for hash table bucket extensions. Each
    /// bucket is extended in increments of 4 keys.
    pub n_entries_ext: u32,
    /// Hash function
    pub f_hash: rte_table_hash_op_hash,
    /// Seed for the hash function
    pub seed: u64,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key32_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key32_ext_params>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_key32_ext_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_key32_ext_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_table_hash_key32_ext_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! (
                n_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! (
                n_entries_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! (
                f_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                seed as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! ( seed
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_key32_ext_params ) , "::" , stringify ! (
                key_offset ) ));
}
impl Clone for rte_table_hash_key32_ext_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_key32_ext_ops"]
    pub static mut rte_table_hash_key32_ext_ops: rte_table_ops;
}
/// Cuckoo hash table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_cuckoo_params {
    /// Key size (number of bytes
    pub key_size: u32,
    /// Maximum number of hash table entries
    pub n_keys: u32,
    /// Hash function used to calculate hash
    pub f_hash: rte_table_hash_op_hash,
    /// Seed value or Init value used by f_hash
    pub seed: u32,
    /// Byte offset within packet meta-data where the 4-byte key signature
    /// is located. Valid for pre-computed key signature tables, ignored for
    /// do-sig tables.
    pub signature_offset: u32,
    /// Byte offset within packet meta-data where the key is located
    pub key_offset: u32,
    /// Hash table name
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_table_hash_cuckoo_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_cuckoo_params>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( rte_table_hash_cuckoo_params ) ));
    assert_eq! (::std::mem::align_of::<rte_table_hash_cuckoo_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rte_table_hash_cuckoo_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                key_size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! ( key_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . n_keys
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! ( n_keys )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . f_hash
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! ( f_hash )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . seed
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! ( seed )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                signature_offset as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! (
                signature_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                key_offset as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! (
                key_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . name
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_hash_cuckoo_params ) , "::" , stringify ! ( name )
                ));
}
impl Clone for rte_table_hash_cuckoo_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_hash_cuckoo_dosig_ops"]
    pub static mut rte_table_hash_cuckoo_dosig_ops: rte_table_ops;
}
/// LPM table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_params {
    /// Table name
    pub name: *const ::std::os::raw::c_char,
    /// Maximum number of LPM rules (i.e. IP routes)
    pub n_rules: u32,
    pub number_tbl8s: u32,
    pub flags: ::std::os::raw::c_int,
    /// Number of bytes at the start of the table entry that uniquely
    /// identify the entry. Cannot be bigger than table entry size.
    pub entry_unique_size: u32,
    /// Byte offset within input packet meta-data where lookup key (i.e.
    /// the destination IP address) is located.
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_params() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_params>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rte_table_lpm_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_lpm_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_lpm_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . n_rules as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( n_rules ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . number_tbl8s
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( number_tbl8s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) .
                entry_unique_size as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( entry_unique_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_params )
                , "::" , stringify ! ( offset ) ));
}
impl Clone for rte_table_lpm_params {
    fn clone(&self) -> Self { *self }
}
/// LPM table rule (i.e. route), specified as IP prefix. While the key used by
/// the lookup operation is the destination IP address (read from the input packet
/// meta-data), the entry add and entry delete operations work with LPM rules, with
/// each rule covering for a multitude of lookup keys (destination IP addresses)
/// that share the same data (next hop).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_key {
    /// IP address
    pub ip: u32,
    /// IP address depth. The most significant "depth" bits of the IP
    /// address specify the network part of the IP address, while the rest of
    /// the bits specify the host part of the address and are ignored for the
    /// purpose of route specification.
    pub depth: u8,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_key() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_key>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_table_lpm_key ) ));
    assert_eq! (::std::mem::align_of::<rte_table_lpm_key>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( rte_table_lpm_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_key ) ) . ip as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_key ) ,
                "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_key ) ) . depth as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_key ) ,
                "::" , stringify ! ( depth ) ));
}
impl Clone for rte_table_lpm_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_lpm_ops"]
    pub static mut rte_table_lpm_ops: rte_table_ops;
}
/// LPM table parameters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_ipv6_params {
    /// Table name
    pub name: *const ::std::os::raw::c_char,
    /// Maximum number of LPM rules (i.e. IP routes)
    pub n_rules: u32,
    pub number_tbl8s: u32,
    /// Number of bytes at the start of the table entry that uniquely
    /// identify the entry. Cannot be bigger than table entry size.
    pub entry_unique_size: u32,
    /// Byte offset within input packet meta-data where lookup key (i.e.
    /// the destination IP address) is located.
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_ipv6_params() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_ipv6_params>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_table_lpm_ipv6_params ) ));
    assert_eq! (::std::mem::align_of::<rte_table_lpm_ipv6_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_lpm_ipv6_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_params ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_lpm_ipv6_params ) , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_params ) ) . n_rules
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_lpm_ipv6_params ) , "::" , stringify ! ( n_rules )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_params ) ) .
                number_tbl8s as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_lpm_ipv6_params ) , "::" , stringify ! (
                number_tbl8s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_params ) ) .
                entry_unique_size as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                rte_table_lpm_ipv6_params ) , "::" , stringify ! (
                entry_unique_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_params ) ) . offset as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_table_lpm_ipv6_params ) , "::" , stringify ! ( offset )
                ));
}
impl Clone for rte_table_lpm_ipv6_params {
    fn clone(&self) -> Self { *self }
}
/// LPM table rule (i.e. route), specified as IP prefix. While the key used by
/// the lookup operation is the destination IP address (read from the input packet
/// meta-data), the entry add and entry delete operations work with LPM rules, with
/// each rule covering for a multitude of lookup keys (destination IP addresses)
/// that share the same data (next hop).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_ipv6_key {
    /// IP address
    pub ip: [u8; 16usize],
    /// IP address depth. The most significant "depth" bits of the IP
    /// address specify the network part of the IP address, while the rest of
    /// the bits specify the host part of the address and are ignored for the
    /// purpose of route specification.
    pub depth: u8,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_ipv6_key() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_ipv6_key>() , 17usize ,
               concat ! ( "Size of: " , stringify ! ( rte_table_lpm_ipv6_key )
               ));
    assert_eq! (::std::mem::align_of::<rte_table_lpm_ipv6_key>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_table_lpm_ipv6_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_key ) ) . ip as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_ipv6_key
                ) , "::" , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_ipv6_key ) ) . depth as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_table_lpm_ipv6_key
                ) , "::" , stringify ! ( depth ) ));
}
impl Clone for rte_table_lpm_ipv6_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "rte_table_lpm_ipv6_ops"]
    pub static mut rte_table_lpm_ipv6_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_table_stub_ops"]
    pub static mut rte_table_stub_ops: rte_table_ops;
}
extern "C" {
    #[link_name = "rte_thash_ipv6_bswap_mask"]
    pub static rte_thash_ipv6_bswap_mask: __m128i;
}
/// IPv4 tuple
/// addresses and ports/sctp_tag have to be CPU byte order
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv4_tuple {
    pub src_addr: u32,
    pub dst_addr: u32,
    pub __bindgen_anon_1: rte_ipv4_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv4_tuple__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1>,
    pub sctp_tag: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub dport: u16,
    pub sport: u16,
}
#[test]
fn bindgen_test_layout_rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 )
                ) . dport as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( dport ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 )
                ) . sport as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( sport ) ));
}
impl Clone for rte_ipv4_tuple__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_ipv4_tuple__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_ipv4_tuple__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( rte_ipv4_tuple__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv4_tuple__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_ipv4_tuple__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv4_tuple__bindgen_ty_1 ) ) .
                sctp_tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv4_tuple__bindgen_ty_1 ) , "::" , stringify ! ( sctp_tag
                ) ));
}
impl Clone for rte_ipv4_tuple__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_ipv4_tuple() {
    assert_eq!(::std::mem::size_of::<rte_ipv4_tuple>() , 12usize , concat ! (
               "Size of: " , stringify ! ( rte_ipv4_tuple ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv4_tuple>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_ipv4_tuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv4_tuple ) ) . src_addr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ipv4_tuple ) , "::"
                , stringify ! ( src_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv4_tuple ) ) . dst_addr as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ipv4_tuple ) , "::"
                , stringify ! ( dst_addr ) ));
}
impl Clone for rte_ipv4_tuple {
    fn clone(&self) -> Self { *self }
}
/// IPv6 tuple
/// Addresses have to be filled by rte_thash_load_v6_addr()
/// ports/sctp_tag have to be CPU byte order
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv6_tuple {
    pub src_addr: [u8; 16usize],
    pub dst_addr: [u8; 16usize],
    pub __bindgen_anon_1: rte_ipv6_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv6_tuple__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1>,
    pub sctp_tag: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub dport: u16,
    pub sport: u16,
}
#[test]
fn bindgen_test_layout_rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 )
                ) . dport as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( dport ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 )
                ) . sport as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( sport ) ));
}
impl Clone for rte_ipv6_tuple__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_ipv6_tuple__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_ipv6_tuple__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( rte_ipv6_tuple__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv6_tuple__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( rte_ipv6_tuple__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv6_tuple__bindgen_ty_1 ) ) .
                sctp_tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_ipv6_tuple__bindgen_ty_1 ) , "::" , stringify ! ( sctp_tag
                ) ));
}
impl Clone for rte_ipv6_tuple__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_ipv6_tuple() {
    assert_eq!(::std::mem::size_of::<rte_ipv6_tuple>() , 36usize , concat ! (
               "Size of: " , stringify ! ( rte_ipv6_tuple ) ));
    assert_eq! (::std::mem::align_of::<rte_ipv6_tuple>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rte_ipv6_tuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv6_tuple ) ) . src_addr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ipv6_tuple ) , "::"
                , stringify ! ( src_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ipv6_tuple ) ) . dst_addr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_ipv6_tuple ) , "::"
                , stringify ! ( dst_addr ) ));
}
impl Clone for rte_ipv6_tuple {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rte_thash_tuple {
    pub v4: __BindgenUnionField<rte_ipv4_tuple>,
    pub v6: __BindgenUnionField<rte_ipv6_tuple>,
    pub bindgen_union_field: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_rte_thash_tuple() {
    assert_eq!(::std::mem::size_of::<rte_thash_tuple>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_thash_tuple ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_thash_tuple ) ) . v4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_thash_tuple ) ,
                "::" , stringify ! ( v4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_thash_tuple ) ) . v6 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_thash_tuple ) ,
                "::" , stringify ! ( v6 ) ));
}
impl Clone for rte_thash_tuple {
    fn clone(&self) -> Self { *self }
}
/// Structure to hold the parameters of a running cycle counter to assist
/// in converting cycles to nanoseconds.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timecounter {
    /// Last cycle counter value read.
    pub cycle_last: u64,
    /// Nanoseconds count.
    pub nsec: u64,
    /// Bitmask separating nanosecond and sub-nanoseconds.
    pub nsec_mask: u64,
    /// Sub-nanoseconds count.
    pub nsec_frac: u64,
    /// Bitmask for two's complement subtraction of non-64 bit counters.
    pub cc_mask: u64,
    /// Cycle to nanosecond divisor (power of two).
    pub cc_shift: u32,
}
#[test]
fn bindgen_test_layout_rte_timecounter() {
    assert_eq!(::std::mem::size_of::<rte_timecounter>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rte_timecounter ) ));
    assert_eq! (::std::mem::align_of::<rte_timecounter>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rte_timecounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . cycle_last as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( cycle_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . nsec as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( nsec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . nsec_mask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( nsec_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . nsec_frac as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( nsec_frac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . cc_mask as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( cc_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timecounter ) ) . cc_shift as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timecounter ) ,
                "::" , stringify ! ( cc_shift ) ));
}
impl Clone for rte_timecounter {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Timer type: Periodic or single (one-shot).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_timer_type { SINGLE = 0, PERIODICAL = 1, }
/// Timer status: A union of the state (stopped, pending, running,
/// config) and an owner (the id of the lcore that owns the timer).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer_status {
    pub __bindgen_anon_1: __BindgenUnionField<rte_timer_status__bindgen_ty_1>,
    /// < To atomic-set status + owner.
    pub u32: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer_status__bindgen_ty_1 {
    /// < Stop, pending, running, config.
    pub state: u16,
    /// < The lcore that owns the timer.
    pub owner: i16,
}
#[test]
fn bindgen_test_layout_rte_timer_status__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_timer_status__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( rte_timer_status__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_timer_status__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( rte_timer_status__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status__bindgen_ty_1 ) ) .
                state as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_timer_status__bindgen_ty_1 ) , "::" , stringify ! ( state
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status__bindgen_ty_1 ) ) .
                owner as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_timer_status__bindgen_ty_1 ) , "::" , stringify ! ( owner
                ) ));
}
impl Clone for rte_timer_status__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_timer_status() {
    assert_eq!(::std::mem::size_of::<rte_timer_status>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rte_timer_status ) ));
    assert_eq! (::std::mem::align_of::<rte_timer_status>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( rte_timer_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status ) ) . u32 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer_status ) ,
                "::" , stringify ! ( u32 ) ));
}
impl Clone for rte_timer_status {
    fn clone(&self) -> Self { *self }
}
/// A structure describing a timer in RTE.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer {
    /// < Time when timer expire.
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    /// < Status of timer.
    pub status: rte_timer_status,
    /// < Period of timer (0 if not periodic).
    pub period: u64,
    /// < Callback function.
    pub f: rte_timer_cb_t,
    /// < Argument to callback function.
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_timer() {
    assert_eq!(::std::mem::size_of::<rte_timer>() , 120usize , concat ! (
               "Size of: " , stringify ! ( rte_timer ) ));
    assert_eq! (::std::mem::align_of::<rte_timer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . expire as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( expire ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . sl_next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( sl_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . status as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . period as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . f as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . arg as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_timer ) , "::" ,
                stringify ! ( arg ) ));
}
impl Clone for rte_timer {
    fn clone(&self) -> Self { *self }
}
/// Callback function type for timer expiry.
pub type rte_timer_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_timer,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Initialize the timer library.
///
/// Initializes internal variables (list, locks and so on) for the RTE
/// timer library.
    pub fn rte_timer_subsystem_init();
}
extern "C" {
    /// Initialize a timer handle.
///
/// The rte_timer_init() function initializes the timer handle *tim*
/// for use. No operations can be performed on a timer before it is
/// initialized.
///
/// @param tim
/// The timer to initialize.
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    /// Reset and start the timer associated with the timer handle.
///
/// The rte_timer_reset() function resets and starts the timer
/// associated with the timer handle *tim*. When the timer expires after
/// *ticks* HPET cycles, the function specified by *fct* will be called
/// with the argument *arg* on core *tim_lcore*.
///
/// If the timer associated with the timer handle is already running
/// (in the RUNNING state), the function will fail. The user has to check
/// the return value of the function to see if there is a chance that the
/// timer is in the RUNNING state.
///
/// If the timer is being configured on another core (the CONFIG state),
/// it will also fail.
///
/// If the timer is pending or stopped, it will be rescheduled with the
/// new parameters.
///
/// @param tim
/// The timer handle.
/// @param ticks
/// The number of cycles (see rte_get_hpet_hz()) before the callback
/// function is called.
/// @param type
/// The type can be either:
/// - PERIODICAL: The timer is automatically reloaded after execution
/// (returns to the PENDING state)
/// - SINGLE: The timer is one-shot, that is, the timer goes to a
/// STOPPED state after execution.
/// @param tim_lcore
/// The ID of the lcore where the timer callback function has to be
/// executed. If tim_lcore is LCORE_ID_ANY, the timer library will
/// launch it on a different core for each call (round-robin).
/// @param fct
/// The callback function of the timer.
/// @param arg
/// The user argument of the callback function.
/// @return
/// - 0: Success; the timer is scheduled.
/// - (-1): Timer is in the RUNNING or CONFIG state.
    pub fn rte_timer_reset(tim: *mut rte_timer, ticks: u64,
                           type_: rte_timer_type,
                           tim_lcore: ::std::os::raw::c_uint,
                           fct: rte_timer_cb_t,
                           arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Loop until rte_timer_reset() succeeds.
///
/// Reset and start the timer associated with the timer handle. Always
/// succeed. See rte_timer_reset() for details.
///
/// @param tim
/// The timer handle.
/// @param ticks
/// The number of cycles (see rte_get_hpet_hz()) before the callback
/// function is called.
/// @param type
/// The type can be either:
/// - PERIODICAL: The timer is automatically reloaded after execution
/// (returns to the PENDING state)
/// - SINGLE: The timer is one-shot, that is, the timer goes to a
/// STOPPED state after execution.
/// @param tim_lcore
/// The ID of the lcore where the timer callback function has to be
/// executed. If tim_lcore is LCORE_ID_ANY, the timer library will
/// launch it on a different core for each call (round-robin).
/// @param fct
/// The callback function of the timer.
/// @param arg
/// The user argument of the callback function.
    pub fn rte_timer_reset_sync(tim: *mut rte_timer, ticks: u64,
                                type_: rte_timer_type,
                                tim_lcore: ::std::os::raw::c_uint,
                                fct: rte_timer_cb_t,
                                arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Stop a timer.
///
/// The rte_timer_stop() function stops the timer associated with the
/// timer handle *tim*. It may fail if the timer is currently running or
/// being configured.
///
/// If the timer is pending or stopped (for instance, already expired),
/// the function will succeed. The timer handle tim must have been
/// initialized using rte_timer_init(), otherwise, undefined behavior
/// will occur.
///
/// This function can be called safely from a timer callback. If it
/// succeeds, the timer is not referenced anymore by the timer library
/// and the timer structure can be freed (even in the callback
/// function).
///
/// @param tim
/// The timer handle.
/// @return
/// - 0: Success; the timer is stopped.
/// - (-1): The timer is in the RUNNING or CONFIG state.
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Loop until rte_timer_stop() succeeds.
///
/// After a call to this function, the timer identified by *tim* is
/// stopped. See rte_timer_stop() for details.
///
/// @param tim
/// The timer handle.
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    /// Test if a timer is pending.
///
/// The rte_timer_pending() function tests the PENDING status
/// of the timer handle *tim*. A PENDING timer is one that has been
/// scheduled and whose function has not yet been called.
///
/// @param tim
/// The timer handle.
/// @return
/// - 0: The timer is not pending.
/// - 1: The timer is pending.
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Manage the timer list and execute callback functions.
///
/// This function must be called periodically from EAL lcores
/// main_loop(). It browses the list of pending timers and runs all
/// timers that are expired.
///
/// The precision of the timer depends on the call frequency of this
/// function. However, the more often the function is called, the more
/// CPU resources it will use.
    pub fn rte_timer_manage();
}
extern "C" {
    /// Dump statistics about timers.
///
/// @param f
/// A pointer to a file for output
    pub fn rte_timer_dump_stats(f: *mut FILE);
}
#[repr(u32)]
/// Color
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tm_color {
    RTE_TM_GREEN = 0,
    RTE_TM_YELLOW = 1,
    RTE_TM_RED = 2,
    RTE_TM_COLORS = 3,
}
#[repr(u32)]
/// Node statistics counter type
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tm_stats_type {
    RTE_TM_STATS_N_PKTS = 1,
    RTE_TM_STATS_N_BYTES = 2,
    RTE_TM_STATS_N_PKTS_GREEN_DROPPED = 4,
    RTE_TM_STATS_N_PKTS_YELLOW_DROPPED = 8,
    RTE_TM_STATS_N_PKTS_RED_DROPPED = 16,
    RTE_TM_STATS_N_BYTES_GREEN_DROPPED = 32,
    RTE_TM_STATS_N_BYTES_YELLOW_DROPPED = 64,
    RTE_TM_STATS_N_BYTES_RED_DROPPED = 128,
    RTE_TM_STATS_N_PKTS_QUEUED = 256,
    RTE_TM_STATS_N_BYTES_QUEUED = 512,
}
/// Node statistics counters
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_stats {
    /// Number of packets scheduled from current node.
    pub n_pkts: u64,
    /// Number of bytes scheduled from current node.
    pub n_bytes: u64,
    pub leaf: rte_tm_node_stats__bindgen_ty_1,
}
/// Statistics counters for leaf nodes only.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_stats__bindgen_ty_1 {
    /// Number of packets dropped by current leaf node per each
    /// color.
    pub n_pkts_dropped: [u64; 3usize],
    /// Number of bytes dropped by current leaf node per each
    /// color.
    pub n_bytes_dropped: [u64; 3usize],
    /// Number of packets currently waiting in the packet queue of
    /// current leaf node.
    pub n_pkts_queued: u64,
    /// Number of bytes currently waiting in the packet queue of
    /// current leaf node.
    pub n_bytes_queued: u64,
}
#[test]
fn bindgen_test_layout_rte_tm_node_stats__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_stats__bindgen_ty_1>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( rte_tm_node_stats__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_stats__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_stats__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats__bindgen_ty_1 ) ) .
                n_pkts_dropped as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_stats__bindgen_ty_1 ) , "::" , stringify ! (
                n_pkts_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats__bindgen_ty_1 ) ) .
                n_bytes_dropped as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_stats__bindgen_ty_1 ) , "::" , stringify ! (
                n_bytes_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats__bindgen_ty_1 ) ) .
                n_pkts_queued as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_stats__bindgen_ty_1 ) , "::" , stringify ! (
                n_pkts_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats__bindgen_ty_1 ) ) .
                n_bytes_queued as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_stats__bindgen_ty_1 ) , "::" , stringify ! (
                n_bytes_queued ) ));
}
impl Clone for rte_tm_node_stats__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_stats() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_stats>() , 80usize , concat !
               ( "Size of: " , stringify ! ( rte_tm_node_stats ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_tm_node_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats ) ) . n_pkts as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_stats ) ,
                "::" , stringify ! ( n_pkts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats ) ) . n_bytes as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_stats ) ,
                "::" , stringify ! ( n_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_stats ) ) . leaf as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_stats ) ,
                "::" , stringify ! ( leaf ) ));
}
impl Clone for rte_tm_node_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Traffic manager dynamic updates
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tm_dynamic_update_type {
    RTE_TM_UPDATE_NODE_PARENT_KEEP_LEVEL = 1,
    RTE_TM_UPDATE_NODE_PARENT_CHANGE_LEVEL = 2,
    RTE_TM_UPDATE_NODE_ADD_DELETE = 4,
    RTE_TM_UPDATE_NODE_SUSPEND_RESUME = 8,
    RTE_TM_UPDATE_NODE_WFQ_WEIGHT_MODE = 16,
    RTE_TM_UPDATE_NODE_N_SP_PRIORITIES = 32,
    RTE_TM_UPDATE_NODE_CMAN = 64,
    RTE_TM_UPDATE_NODE_STATS = 128,
}
/// Traffic manager capabilities
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_capabilities {
    /// Maximum number of nodes.
    pub n_nodes_max: u32,
    /// Maximum number of levels (i.e. number of nodes connecting the root
    /// node with any leaf node, including the root and the leaf).
    pub n_levels_max: u32,
    /// When non-zero, this flag indicates that all the non-leaf nodes
    /// (with the exception of the root node) have identical capability set.
    pub non_leaf_nodes_identical: ::std::os::raw::c_int,
    /// When non-zero, this flag indicates that all the leaf nodes have
    /// identical capability set.
    pub leaf_nodes_identical: ::std::os::raw::c_int,
    /// Maximum number of shapers, either private or shared. In case the
    /// implementation does not share any resources between private and
    /// shared shapers, it is typically equal to the sum of
    /// *shaper_private_n_max* and *shaper_shared_n_max*. The
    /// value of zero indicates that traffic shaping is not supported.
    pub shaper_n_max: u32,
    /// Maximum number of private shapers. Indicates the maximum number of
    /// nodes that can concurrently have their private shaper enabled. The
    /// value of zero indicates that private shapers are not supported.
    pub shaper_private_n_max: u32,
    /// Maximum number of private shapers that support dual rate shaping.
    /// Indicates the maximum number of nodes that can concurrently have
    /// their private shaper enabled with dual rate support. Only valid when
    /// private shapers are supported. The value of zero indicates that dual
    /// rate shaping is not available for private shapers. The maximum value
    /// is *shaper_private_n_max*.
    pub shaper_private_dual_rate_n_max: ::std::os::raw::c_int,
    /// Minimum committed/peak rate (bytes per second) for any private
    /// shaper. Valid only when private shapers are supported.
    pub shaper_private_rate_min: u64,
    /// Maximum committed/peak rate (bytes per second) for any private
    /// shaper. Valid only when private shapers are supported.
    pub shaper_private_rate_max: u64,
    /// Maximum number of shared shapers. The value of zero indicates that
    /// shared shapers are not supported.
    pub shaper_shared_n_max: u32,
    /// Maximum number of nodes that can share the same shared shaper.
    /// Only valid when shared shapers are supported.
    pub shaper_shared_n_nodes_per_shaper_max: u32,
    /// Maximum number of shared shapers a node can be part of. This
    /// parameter indicates that there is at least one node that can be
    /// configured with this many shared shapers, which might not be true for
    /// all the nodes. Only valid when shared shapers are supported, in which
    /// case it ranges from 1 to *shaper_shared_n_max*.
    pub shaper_shared_n_shapers_per_node_max: u32,
    /// Maximum number of shared shapers that can be configured with dual
    /// rate shaping. The value of zero indicates that dual rate shaping
    /// support is not available for shared shapers.
    pub shaper_shared_dual_rate_n_max: u32,
    /// Minimum committed/peak rate (bytes per second) for any shared
    /// shaper. Only valid when shared shapers are supported.
    pub shaper_shared_rate_min: u64,
    /// Maximum committed/peak rate (bytes per second) for any shared
    /// shaper. Only valid when shared shapers are supported.
    pub shaper_shared_rate_max: u64,
    /// Minimum value allowed for packet length adjustment for any private
    /// or shared shaper.
    pub shaper_pkt_length_adjust_min: ::std::os::raw::c_int,
    /// Maximum value allowed for packet length adjustment for any private
    /// or shared shaper.
    pub shaper_pkt_length_adjust_max: ::std::os::raw::c_int,
    /// Maximum number of children nodes. This parameter indicates that
    /// there is at least one non-leaf node that can be configured with this
    /// many children nodes, which might not be true for all the non-leaf
    /// nodes.
    pub sched_n_children_max: u32,
    /// Maximum number of supported priority levels. This parameter
    /// indicates that there is at least one non-leaf node that can be
    /// configured with this many priority levels for managing its children
    /// nodes, which might not be true for all the non-leaf nodes. The value
    /// of zero is invalid. The value of 1 indicates that only priority 0 is
    /// supported, which essentially means that Strict Priority (SP)
    /// algorithm is not supported.
    pub sched_sp_n_priorities_max: u32,
    /// Maximum number of sibling nodes that can have the same priority at
    /// any given time, i.e. maximum size of the WFQ sibling node group. This
    /// parameter indicates there is at least one non-leaf node that meets
    /// this condition, which might not be true for all the non-leaf nodes.
    /// The value of zero is invalid. The value of 1 indicates that WFQ
    /// algorithm is not supported. The maximum value is
    /// *sched_n_children_max*.
    pub sched_wfq_n_children_per_group_max: u32,
    /// Maximum number of priority levels that can have more than one child
    /// node at any given time, i.e. maximum number of WFQ sibling node
    /// groups that have two or more members. This parameter indicates there
    /// is at least one non-leaf node that meets this condition, which might
    /// not be true for all the non-leaf nodes. The value of zero states that
    /// WFQ algorithm is not supported. The value of 1 indicates that
    /// (*sched_sp_n_priorities_max* - 1) priority levels have at most one
    /// child node, so there can be only one priority level with two or
    /// more sibling nodes making up a WFQ group. The maximum value is:
    /// min(floor(*sched_n_children_max* / 2), *sched_sp_n_priorities_max*).
    pub sched_wfq_n_groups_max: u32,
    /// Maximum WFQ weight. The value of 1 indicates that all sibling nodes
    /// with same priority have the same WFQ weight, so WFQ is reduced to FQ.
    pub sched_wfq_weight_max: u32,
    /// Head drop algorithm support. When non-zero, this parameter
    /// indicates that there is at least one leaf node that supports the head
    /// drop algorithm, which might not be true for all the leaf nodes.
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    /// Maximum number of WRED contexts, either private or shared. In case
    /// the implementation does not share any resources between private and
    /// shared WRED contexts, it is typically equal to the sum of
    /// *cman_wred_context_private_n_max* and
    /// *cman_wred_context_shared_n_max*. The value of zero indicates that
    /// WRED is not supported.
    pub cman_wred_context_n_max: u32,
    /// Maximum number of private WRED contexts. Indicates the maximum
    /// number of leaf nodes that can concurrently have their private WRED
    /// context enabled. The value of zero indicates that private WRED
    /// contexts are not supported.
    pub cman_wred_context_private_n_max: u32,
    /// Maximum number of shared WRED contexts. The value of zero
    /// indicates that shared WRED contexts are not supported.
    pub cman_wred_context_shared_n_max: u32,
    /// Maximum number of leaf nodes that can share the same WRED context.
    /// Only valid when shared WRED contexts are supported.
    pub cman_wred_context_shared_n_nodes_per_context_max: u32,
    /// Maximum number of shared WRED contexts a leaf node can be part of.
    /// This parameter indicates that there is at least one leaf node that
    /// can be configured with this many shared WRED contexts, which might
    /// not be true for all the leaf nodes. Only valid when shared WRED
    /// contexts are supported, in which case it ranges from 1 to
    /// *cman_wred_context_shared_n_max*.
    pub cman_wred_context_shared_n_contexts_per_node_max: u32,
    /// Support for VLAN DEI packet marking (per color).
    pub mark_vlan_dei_supported: [::std::os::raw::c_int; 3usize],
    /// Support for IPv4/IPv6 ECN marking of TCP packets (per color).
    pub mark_ip_ecn_tcp_supported: [::std::os::raw::c_int; 3usize],
    /// Support for IPv4/IPv6 ECN marking of SCTP packets (per color).
    pub mark_ip_ecn_sctp_supported: [::std::os::raw::c_int; 3usize],
    /// Support for IPv4/IPv6 DSCP packet marking (per color).
    pub mark_ip_dscp_supported: [::std::os::raw::c_int; 3usize],
    /// Set of supported dynamic update operations.
    /// @see enum rte_tm_dynamic_update_type
    pub dynamic_update_mask: u64,
    /// Set of supported statistics counter types.
    /// @see enum rte_tm_stats_type
    pub stats_mask: u64,
}
#[test]
fn bindgen_test_layout_rte_tm_capabilities() {
    assert_eq!(::std::mem::size_of::<rte_tm_capabilities>() , 200usize ,
               concat ! ( "Size of: " , stringify ! ( rte_tm_capabilities )
               ));
    assert_eq! (::std::mem::align_of::<rte_tm_capabilities>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tm_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) . n_nodes_max as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( n_nodes_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) . n_levels_max as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( n_levels_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                non_leaf_nodes_identical as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( non_leaf_nodes_identical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                leaf_nodes_identical as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( leaf_nodes_identical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) . shaper_n_max as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_private_n_max as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_private_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_private_dual_rate_n_max as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_private_dual_rate_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_private_rate_min as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_private_rate_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_private_rate_max as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_private_rate_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_n_max as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_n_nodes_per_shaper_max as * const _ as usize } ,
                52usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_n_nodes_per_shaper_max )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_n_shapers_per_node_max as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_n_shapers_per_node_max )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_dual_rate_n_max as * const _ as usize } ,
                60usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_dual_rate_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_rate_min as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_rate_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_shared_rate_max as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_shared_rate_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_pkt_length_adjust_min as * const _ as usize } , 80usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_pkt_length_adjust_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                shaper_pkt_length_adjust_max as * const _ as usize } , 84usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( shaper_pkt_length_adjust_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                sched_n_children_max as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( sched_n_children_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                sched_sp_n_priorities_max as * const _ as usize } , 92usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( sched_sp_n_priorities_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                sched_wfq_n_children_per_group_max as * const _ as usize } ,
                96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( sched_wfq_n_children_per_group_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                sched_wfq_n_groups_max as * const _ as usize } , 100usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( sched_wfq_n_groups_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                sched_wfq_weight_max as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( sched_wfq_weight_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_head_drop_supported as * const _ as usize } , 108usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( cman_head_drop_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_wred_context_n_max as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( cman_wred_context_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_wred_context_private_n_max as * const _ as usize } ,
                116usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( cman_wred_context_private_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_wred_context_shared_n_max as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( cman_wred_context_shared_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_wred_context_shared_n_nodes_per_context_max as * const _
                as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! (
                cman_wred_context_shared_n_nodes_per_context_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                cman_wred_context_shared_n_contexts_per_node_max as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! (
                cman_wred_context_shared_n_contexts_per_node_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                mark_vlan_dei_supported as * const _ as usize } , 132usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( mark_vlan_dei_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                mark_ip_ecn_tcp_supported as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( mark_ip_ecn_tcp_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                mark_ip_ecn_sctp_supported as * const _ as usize } , 156usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( mark_ip_ecn_sctp_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                mark_ip_dscp_supported as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( mark_ip_dscp_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) .
                dynamic_update_mask as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( dynamic_update_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_capabilities ) ) . stats_mask as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_capabilities ) ,
                "::" , stringify ! ( stats_mask ) ));
}
impl Clone for rte_tm_capabilities {
    fn clone(&self) -> Self { *self }
}
/// Traffic manager level capabilities
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_level_capabilities {
    /// Maximum number of nodes for the current hierarchy level.
    pub n_nodes_max: u32,
    /// Maximum number of non-leaf nodes for the current hierarchy level.
    /// The value of 0 indicates that current level only supports leaf
    /// nodes. The maximum value is *n_nodes_max*.
    pub n_nodes_nonleaf_max: u32,
    /// Maximum number of leaf nodes for the current hierarchy level. The
    /// value of 0 indicates that current level only supports non-leaf
    /// nodes. The maximum value is *n_nodes_max*.
    pub n_nodes_leaf_max: u32,
    /// When non-zero, this flag indicates that all the non-leaf nodes on
    /// this level have identical capability set. Valid only when
    /// *n_nodes_nonleaf_max* is non-zero.
    pub non_leaf_nodes_identical: ::std::os::raw::c_int,
    /// When non-zero, this flag indicates that all the leaf nodes on this
    /// level have identical capability set. Valid only when
    /// *n_nodes_leaf_max* is non-zero.
    pub leaf_nodes_identical: ::std::os::raw::c_int,
    pub __bindgen_anon_1: rte_tm_level_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_level_capabilities__bindgen_ty_1 {
    pub nonleaf: __BindgenUnionField<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1>,
    pub leaf: __BindgenUnionField<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 7usize],
}
/// Items valid only for the non-leaf nodes on this level.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 {
    /// Private shaper support. When non-zero, it indicates
    /// there is at least one non-leaf node on this level
    /// with private shaper support, which may not be the
    /// case for all the non-leaf nodes on this level.
    pub shaper_private_supported: ::std::os::raw::c_int,
    /// Dual rate support for private shaper. Valid only
    /// when private shaper is supported for the non-leaf
    /// nodes on the current level. When non-zero, it
    /// indicates there is at least one non-leaf node on this
    /// level with dual rate private shaper support, which
    /// may not be the case for all the non-leaf nodes on
    /// this level.
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    /// Minimum committed/peak rate (bytes per second) for
    /// private shapers of the non-leaf nodes of this level.
    /// Valid only when private shaper is supported on this
    /// level.
    pub shaper_private_rate_min: u64,
    /// Maximum committed/peak rate (bytes per second) for
    /// private shapers of the non-leaf nodes on this level.
    /// Valid only when private shaper is supported on this
    /// level.
    pub shaper_private_rate_max: u64,
    /// Maximum number of shared shapers that any non-leaf
    /// node on this level can be part of. The value of zero
    /// indicates that shared shapers are not supported by
    /// the non-leaf nodes on this level. When non-zero, it
    /// indicates there is at least one non-leaf node on this
    /// level that meets this condition, which may not be the
    /// case for all the non-leaf nodes on this level.
    pub shaper_shared_n_max: u32,
    /// Maximum number of children nodes. This parameter
    /// indicates that there is at least one non-leaf node on
    /// this level that can be configured with this many
    /// children nodes, which might not be true for all the
    /// non-leaf nodes on this level.
    pub sched_n_children_max: u32,
    /// Maximum number of supported priority levels. This
    /// parameter indicates that there is at least one
    /// non-leaf node on this level that can be configured
    /// with this many priority levels for managing its
    /// children nodes, which might not be true for all the
    /// non-leaf nodes on this level. The value of zero is
    /// invalid. The value of 1 indicates that only priority
    /// 0 is supported, which essentially means that Strict
    /// Priority (SP) algorithm is not supported on this
    /// level.
    pub sched_sp_n_priorities_max: u32,
    /// Maximum number of sibling nodes that can have the
    /// same priority at any given time, i.e. maximum size of
    /// the WFQ sibling node group. This parameter indicates
    /// there is at least one non-leaf node on this level
    /// that meets this condition, which may not be true for
    /// all the non-leaf nodes on this level. The value of
    /// zero is invalid. The value of 1 indicates that WFQ
    /// algorithm is not supported on this level. The maximum
    /// value is *sched_n_children_max*.
    pub sched_wfq_n_children_per_group_max: u32,
    /// Maximum number of priority levels that can have
    /// more than one child node at any given time, i.e.
    /// maximum number of WFQ sibling node groups that
    /// have two or more members. This parameter indicates
    /// there is at least one non-leaf node on this level
    /// that meets this condition, which might not be true
    /// for all the non-leaf nodes. The value of zero states
    /// that WFQ algorithm is not supported on this level.
    /// The value of 1 indicates that
    /// (*sched_sp_n_priorities_max* - 1) priority levels on
    /// this level have at most one child node, so there can
    /// be only one priority level with two or more sibling
    /// nodes making up a WFQ group on this level. The
    /// maximum value is:
    /// min(floor(*sched_n_children_max* / 2),
    /// *sched_sp_n_priorities_max*).
    pub sched_wfq_n_groups_max: u32,
    /// Maximum WFQ weight. The value of 1 indicates that
    /// all sibling nodes on this level with same priority
    /// have the same WFQ weight, so on this level WFQ is
    /// reduced to FQ.
    pub sched_wfq_weight_max: u32,
    /// Mask of statistics counter types supported by the
    /// non-leaf nodes on this level. Every supported
    /// statistics counter type is supported by at least one
    /// non-leaf node on this level, which may not be true
    /// for all the non-leaf nodes on this level.
    /// @see enum rte_tm_stats_type
    pub stats_mask: u64,
}
#[test]
fn bindgen_test_layout_rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1>()
               , 56usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                shaper_private_supported as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( shaper_private_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                shaper_private_dual_rate_supported as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( shaper_private_dual_rate_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                shaper_private_rate_min as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( shaper_private_rate_min ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                shaper_private_rate_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( shaper_private_rate_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                shaper_shared_n_max as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( shaper_shared_n_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_n_children_max as * const _ as usize } , 28usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_n_children_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_sp_n_priorities_max as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_sp_n_priorities_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_n_children_per_group_max as * const _ as usize } ,
                36usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_n_children_per_group_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_n_groups_max as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_n_groups_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_weight_max as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_weight_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                stats_mask as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( stats_mask ) ));
}
impl Clone for rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/// Items valid only for the leaf nodes on this level.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 {
    /// Private shaper support. When non-zero, it indicates
    /// there is at least one leaf node on this level with
    /// private shaper support, which may not be the case for
    /// all the leaf nodes on this level.
    pub shaper_private_supported: ::std::os::raw::c_int,
    /// Dual rate support for private shaper. Valid only
    /// when private shaper is supported for the leaf nodes
    /// on this level. When non-zero, it indicates there is
    /// at least one leaf node on this level with dual rate
    /// private shaper support, which may not be the case for
    /// all the leaf nodes on this level.
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    /// Minimum committed/peak rate (bytes per second) for
    /// private shapers of the leaf nodes of this level.
    /// Valid only when private shaper is supported for the
    /// leaf nodes on this level.
    pub shaper_private_rate_min: u64,
    /// Maximum committed/peak rate (bytes per second) for
    /// private shapers of the leaf nodes on this level.
    /// Valid only when private shaper is supported for the
    /// leaf nodes on this level.
    pub shaper_private_rate_max: u64,
    /// Maximum number of shared shapers that any leaf node
    /// on this level can be part of. The value of zero
    /// indicates that shared shapers are not supported by
    /// the leaf nodes on this level. When non-zero, it
    /// indicates there is at least one leaf node on this
    /// level that meets this condition, which may not be the
    /// case for all the leaf nodes on this level.
    pub shaper_shared_n_max: u32,
    /// Head drop algorithm support. When non-zero, this
    /// parameter indicates that there is at least one leaf
    /// node on this level that supports the head drop
    /// algorithm, which might not be true for all the leaf
    /// nodes on this level.
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    /// Private WRED context support. When non-zero, it
    /// indicates there is at least one node on this level
    /// with private WRED context support, which may not be
    /// true for all the leaf nodes on this level.
    pub cman_wred_context_private_supported: ::std::os::raw::c_int,
    /// Maximum number of shared WRED contexts that any
    /// leaf node on this level can be part of. The value of
    /// zero indicates that shared WRED contexts are not
    /// supported by the leaf nodes on this level. When
    /// non-zero, it indicates there is at least one leaf
    /// node on this level that meets this condition, which
    /// may not be the case for all the leaf nodes on this
    /// level.
    pub cman_wred_context_shared_n_max: u32,
    /// Mask of statistics counter types supported by the
    /// leaf nodes on this level. Every supported statistics
    /// counter type is supported by at least one leaf node
    /// on this level, which may not be true for all the leaf
    /// nodes on this level.
    /// @see enum rte_tm_stats_type
    pub stats_mask: u64,
}
#[test]
fn bindgen_test_layout_rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                shaper_private_supported as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( shaper_private_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                shaper_private_dual_rate_supported as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( shaper_private_dual_rate_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                shaper_private_rate_min as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( shaper_private_rate_min ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                shaper_private_rate_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( shaper_private_rate_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                shaper_shared_n_max as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( shaper_shared_n_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_head_drop_supported as * const _ as usize } , 28usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_head_drop_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_wred_context_private_supported as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_wred_context_private_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_wred_context_shared_n_max as * const _ as usize } ,
                36usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_wred_context_shared_n_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                stats_mask as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( stats_mask ) ));
}
impl Clone for rte_tm_level_capabilities__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_level_capabilities__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_level_capabilities__bindgen_ty_1>()
               , 56usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_level_capabilities__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_level_capabilities__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities__bindgen_ty_1 )
                ) . nonleaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1 ) , "::" , stringify !
                ( nonleaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities__bindgen_ty_1 )
                ) . leaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities__bindgen_ty_1 ) , "::" , stringify !
                ( leaf ) ));
}
impl Clone for rte_tm_level_capabilities__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_level_capabilities() {
    assert_eq!(::std::mem::size_of::<rte_tm_level_capabilities>() , 80usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_tm_level_capabilities ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_level_capabilities>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tm_level_capabilities )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities ) ) .
                n_nodes_max as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities ) , "::" , stringify ! ( n_nodes_max
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities ) ) .
                n_nodes_nonleaf_max as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities ) , "::" , stringify ! (
                n_nodes_nonleaf_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities ) ) .
                n_nodes_leaf_max as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities ) , "::" , stringify ! (
                n_nodes_leaf_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities ) ) .
                non_leaf_nodes_identical as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities ) , "::" , stringify ! (
                non_leaf_nodes_identical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_level_capabilities ) ) .
                leaf_nodes_identical as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_level_capabilities ) , "::" , stringify ! (
                leaf_nodes_identical ) ));
}
impl Clone for rte_tm_level_capabilities {
    fn clone(&self) -> Self { *self }
}
/// Traffic manager node capabilities
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_capabilities {
    /// Private shaper support for the current node.
    pub shaper_private_supported: ::std::os::raw::c_int,
    /// Dual rate shaping support for private shaper of current node.
    /// Valid only when private shaper is supported by the current node.
    pub shaper_private_dual_rate_supported: ::std::os::raw::c_int,
    /// Minimum committed/peak rate (bytes per second) for private
    /// shaper of current node. Valid only when private shaper is supported
    /// by the current node.
    pub shaper_private_rate_min: u64,
    /// Maximum committed/peak rate (bytes per second) for private
    /// shaper of current node. Valid only when private shaper is supported
    /// by the current node.
    pub shaper_private_rate_max: u64,
    /// Maximum number of shared shapers the current node can be part of.
    /// The value of zero indicates that shared shapers are not supported by
    /// the current node.
    pub shaper_shared_n_max: u32,
    pub __bindgen_anon_1: rte_tm_node_capabilities__bindgen_ty_1,
    /// Mask of statistics counter types supported by the current node.
    /// @see enum rte_tm_stats_type
    pub stats_mask: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_capabilities__bindgen_ty_1 {
    pub nonleaf: __BindgenUnionField<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1>,
    pub leaf: __BindgenUnionField<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 5usize],
}
/// Items valid only for non-leaf nodes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 {
    /// Maximum number of children nodes.
    pub sched_n_children_max: u32,
    /// Maximum number of supported priority levels. The
    /// value of zero is invalid. The value of 1 indicates
    /// that only priority 0 is supported, which essentially
    /// means that Strict Priority (SP) algorithm is not
    /// supported.
    pub sched_sp_n_priorities_max: u32,
    /// Maximum number of sibling nodes that can have the
    /// same priority at any given time, i.e. maximum size
    /// of the WFQ sibling node group. The value of zero
    /// is invalid. The value of 1 indicates that WFQ
    /// algorithm is not supported. The maximum value is
    /// *sched_n_children_max*.
    pub sched_wfq_n_children_per_group_max: u32,
    /// Maximum number of priority levels that can have
    /// more than one child node at any given time, i.e.
    /// maximum number of WFQ sibling node groups that have
    /// two or more members. The value of zero states that
    /// WFQ algorithm is not supported. The value of 1
    /// indicates that (*sched_sp_n_priorities_max* - 1)
    /// priority levels have at most one child node, so there
    /// can be only one priority level with two or more
    /// sibling nodes making up a WFQ group. The maximum
    /// value is: min(floor(*sched_n_children_max* / 2),
    /// *sched_sp_n_priorities_max*).
    pub sched_wfq_n_groups_max: u32,
    /// Maximum WFQ weight. The value of 1 indicates that
    /// all sibling nodes with same priority have the same
    /// WFQ weight, so WFQ is reduced to FQ.
    pub sched_wfq_weight_max: u32,
}
#[test]
fn bindgen_test_layout_rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1>()
               , 20usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_n_children_max as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_n_children_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_sp_n_priorities_max as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_sp_n_priorities_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_n_children_per_group_max as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_n_children_per_group_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_n_groups_max as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_n_groups_max ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) ) .
                sched_wfq_weight_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( sched_wfq_weight_max ) ));
}
impl Clone for rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/// Items valid only for leaf nodes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 {
    /// Head drop algorithm support for current node.
    pub cman_head_drop_supported: ::std::os::raw::c_int,
    /// Private WRED context support for current node.
    pub cman_wred_context_private_supported: ::std::os::raw::c_int,
    /// Maximum number of shared WRED contexts the current
    /// node can be part of. The value of zero indicates that
    /// shared WRED contexts are not supported by the current
    /// node.
    pub cman_wred_context_shared_n_max: u32,
}
#[test]
fn bindgen_test_layout_rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_head_drop_supported as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_head_drop_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_wred_context_private_supported as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_wred_context_private_supported ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) ) .
                cman_wred_context_shared_n_max as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 ) , "::"
                , stringify ! ( cman_wred_context_shared_n_max ) ));
}
impl Clone for rte_tm_node_capabilities__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_capabilities__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_capabilities__bindgen_ty_1>()
               , 20usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_capabilities__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_capabilities__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities__bindgen_ty_1 )
                ) . nonleaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1 ) , "::" , stringify !
                ( nonleaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities__bindgen_ty_1 )
                ) . leaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities__bindgen_ty_1 ) , "::" , stringify !
                ( leaf ) ));
}
impl Clone for rte_tm_node_capabilities__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_capabilities() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_capabilities>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( rte_tm_node_capabilities ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_capabilities>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tm_node_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) .
                shaper_private_supported as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! (
                shaper_private_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) .
                shaper_private_dual_rate_supported as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! (
                shaper_private_dual_rate_supported ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) .
                shaper_private_rate_min as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! (
                shaper_private_rate_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) .
                shaper_private_rate_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! (
                shaper_private_rate_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) .
                shaper_shared_n_max as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! (
                shaper_shared_n_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_capabilities ) ) . stats_mask
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_capabilities ) , "::" , stringify ! ( stats_mask )
                ));
}
impl Clone for rte_tm_node_capabilities {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Congestion management (CMAN) mode
///
/// This is used for controlling the admission of packets into a packet queue or
/// group of packet queues on congestion. On request of writing a new packet
/// into the current queue while the queue is full, the *tail drop* algorithm
/// drops the new packet while leaving the queue unmodified, as opposed to *head
/// drop* algorithm, which drops the packet at the head of the queue (the oldest
/// packet waiting in the queue) and admits the new packet at the tail of the
/// queue.
///
/// The *Random Early Detection (RED)* algorithm works by proactively dropping
/// more and more input packets as the queue occupancy builds up. When the queue
/// is full or almost full, RED effectively works as *tail drop*. The *Weighted
/// RED* algorithm uses a separate set of RED thresholds for each packet color.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tm_cman_mode {
    RTE_TM_CMAN_TAIL_DROP = 0,
    RTE_TM_CMAN_HEAD_DROP = 1,
    RTE_TM_CMAN_WRED = 2,
}
/// Random Early Detection (RED) profile
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_red_params {
    /// Minimum queue threshold
    pub min_th: u16,
    /// Maximum queue threshold
    pub max_th: u16,
    /// Inverse of packet marking probability maximum value (maxp), i.e.
    /// maxp_inv = 1 / maxp
    pub maxp_inv: u16,
    /// Negated log2 of queue weight (wq), i.e. wq = 1 / (2 ^ wq_log2)
    pub wq_log2: u16,
}
#[test]
fn bindgen_test_layout_rte_tm_red_params() {
    assert_eq!(::std::mem::size_of::<rte_tm_red_params>() , 8usize , concat !
               ( "Size of: " , stringify ! ( rte_tm_red_params ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_red_params>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_tm_red_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_red_params ) ) . min_th as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_red_params ) ,
                "::" , stringify ! ( min_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_red_params ) ) . max_th as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_red_params ) ,
                "::" , stringify ! ( max_th ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_red_params ) ) . maxp_inv as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_red_params ) ,
                "::" , stringify ! ( maxp_inv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_red_params ) ) . wq_log2 as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_red_params ) ,
                "::" , stringify ! ( wq_log2 ) ));
}
impl Clone for rte_tm_red_params {
    fn clone(&self) -> Self { *self }
}
/// Weighted RED (WRED) profile
///
/// Multiple WRED contexts can share the same WRED profile. Each leaf node with
/// WRED enabled as its congestion management mode has zero or one private WRED
/// context (only one leaf node using it) and/or zero, one or several shared
/// WRED contexts (multiple leaf nodes use the same WRED context). A private
/// WRED context is used to perform congestion management for a single leaf
/// node, while a shared WRED context is used to perform congestion management
/// for a group of leaf nodes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_wred_params {
    /// One set of RED parameters per packet color
    pub red_params: [rte_tm_red_params; 3usize],
}
#[test]
fn bindgen_test_layout_rte_tm_wred_params() {
    assert_eq!(::std::mem::size_of::<rte_tm_wred_params>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( rte_tm_wred_params ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_wred_params>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( rte_tm_wred_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_wred_params ) ) . red_params as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_wred_params ) ,
                "::" , stringify ! ( red_params ) ));
}
impl Clone for rte_tm_wred_params {
    fn clone(&self) -> Self { *self }
}
/// Token bucket
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_token_bucket {
    /// Token bucket rate (bytes per second)
    pub rate: u64,
    /// Token bucket size (bytes), a.k.a. max burst size
    pub size: u64,
}
#[test]
fn bindgen_test_layout_rte_tm_token_bucket() {
    assert_eq!(::std::mem::size_of::<rte_tm_token_bucket>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rte_tm_token_bucket ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_token_bucket>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tm_token_bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_token_bucket ) ) . rate as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_token_bucket ) ,
                "::" , stringify ! ( rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_token_bucket ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_token_bucket ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for rte_tm_token_bucket {
    fn clone(&self) -> Self { *self }
}
/// Shaper (rate limiter) profile
///
/// Multiple shaper instances can share the same shaper profile. Each node has
/// zero or one private shaper (only one node using it) and/or zero, one or
/// several shared shapers (multiple nodes use the same shaper instance).
/// A private shaper is used to perform traffic shaping for a single node, while
/// a shared shaper is used to perform traffic shaping for a group of nodes.
///
/// Single rate shapers use a single token bucket. A single rate shaper can be
/// configured by setting the rate of the committed bucket to zero, which
/// effectively disables this bucket. The peak bucket is used to limit the rate
/// and the burst size for the current shaper.
///
/// Dual rate shapers use both the committed and the peak token buckets. The
/// rate of the peak bucket has to be bigger than zero, as well as greater than
/// or equal to the rate of the committed bucket.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_shaper_params {
    /// Committed token bucket
    pub committed: rte_tm_token_bucket,
    /// Peak token bucket
    pub peak: rte_tm_token_bucket,
    /// Signed value to be added to the length of each packet for the
    /// purpose of shaping. Can be used to correct the packet length with
    /// the framing overhead bytes that are also consumed on the wire (e.g.
    /// RTE_TM_ETH_FRAMING_OVERHEAD_FCS).
    pub pkt_length_adjust: i32,
}
#[test]
fn bindgen_test_layout_rte_tm_shaper_params() {
    assert_eq!(::std::mem::size_of::<rte_tm_shaper_params>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( rte_tm_shaper_params )
               ));
    assert_eq! (::std::mem::align_of::<rte_tm_shaper_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rte_tm_shaper_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_shaper_params ) ) . committed as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_shaper_params )
                , "::" , stringify ! ( committed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_shaper_params ) ) . peak as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_shaper_params )
                , "::" , stringify ! ( peak ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_shaper_params ) ) .
                pkt_length_adjust as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_tm_shaper_params )
                , "::" , stringify ! ( pkt_length_adjust ) ));
}
impl Clone for rte_tm_shaper_params {
    fn clone(&self) -> Self { *self }
}
/// Node parameters
///
/// Each non-leaf node has multiple inputs (its children nodes) and single output
/// (which is input to its parent node). It arbitrates its inputs using Strict
/// Priority (SP) and Weighted Fair Queuing (WFQ) algorithms to schedule input
/// packets to its output while observing its shaping (rate limiting)
/// constraints.
///
/// Algorithms such as Weighted Round Robin (WRR), Byte-level WRR, Deficit WRR
/// (DWRR), etc. are considered approximations of the WFQ ideal and are
/// assimilated to WFQ, although an associated implementation-dependent trade-off
/// on accuracy, performance and resource usage might exist.
///
/// Children nodes with different priorities are scheduled using the SP algorithm
/// based on their priority, with zero (0) as the highest priority. Children with
/// the same priority are scheduled using the WFQ algorithm according to their
/// weights. The WFQ weight of a given child node is relative to the sum of the
/// weights of all its sibling nodes that have the same priority, with one (1) as
/// the lowest weight. For each SP priority, the WFQ weight mode can be set as
/// either byte-based or packet-based.
///
/// Each leaf node sits on top of a TX queue of the current Ethernet port. Hence,
/// the leaf nodes are predefined, with their node IDs set to 0 .. (N-1), where N
/// is the number of TX queues configured for the current Ethernet port. The
/// non-leaf nodes have their IDs generated by the application.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_params {
    /// Shaper profile for the private shaper. The absence of the private
    /// shaper for the current node is indicated by setting this parameter
    /// to RTE_TM_SHAPER_PROFILE_ID_NONE.
    pub shaper_profile_id: u32,
    /// User allocated array of valid shared shaper IDs.
    pub shared_shaper_id: *mut u32,
    /// Number of shared shaper IDs in the *shared_shaper_id* array.
    pub n_shared_shapers: u32,
    pub __bindgen_anon_1: rte_tm_node_params__bindgen_ty_1,
    /// Mask of statistics counter types to be enabled for this node. This
    /// needs to be a subset of the statistics counter types available for
    /// the current node. Any statistics counter type not included in this
    /// set is to be disabled for the current node.
    /// @see enum rte_tm_stats_type
    pub stats_mask: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_params__bindgen_ty_1 {
    pub nonleaf: __BindgenUnionField<rte_tm_node_params__bindgen_ty_1__bindgen_ty_1>,
    pub leaf: __BindgenUnionField<rte_tm_node_params__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 4usize],
}
/// Parameters only valid for non-leaf nodes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 {
    /// WFQ weight mode for each SP priority. When NULL, it
    /// indicates that WFQ is to be used for all priorities.
    /// When non-NULL, it points to a pre-allocated array of
    /// *n_sp_priorities* values, with non-zero value for
    /// byte-mode and zero for packet-mode.
    pub wfq_weight_mode: *mut ::std::os::raw::c_int,
    /// Number of SP priorities.
    pub n_sp_priorities: u32,
}
#[test]
fn bindgen_test_layout_rte_tm_node_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 )
                ) . wfq_weight_mode as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( wfq_weight_mode ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 )
                ) . n_sp_priorities as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( n_sp_priorities ) ));
}
impl Clone for rte_tm_node_params__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/// Parameters only valid for leaf nodes.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 {
    /// Congestion management mode
    pub cman: rte_tm_cman_mode,
    pub wred: rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
/// WRED parameters (only valid when *cman* is set to
/// WRED).
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    /// WRED profile for private WRED context. The
    /// absence of a private WRED context for the
    /// current leaf node is indicated by value
    /// RTE_TM_WRED_PROFILE_ID_NONE.
    pub wred_profile_id: u32,
    /// User allocated array of shared WRED context
    /// IDs. When set to NULL, it indicates that the
    /// current leaf node should not currently be
    /// part of any shared WRED contexts.
    pub shared_wred_context_id: *mut u32,
    /// Number of elements in the
    /// *shared_wred_context_id* array. Only valid
    /// when *shared_wred_context_id* is non-NULL,
    /// in which case it should be non-zero.
    pub n_shared_wred_contexts: u32,
}
#[test]
fn bindgen_test_layout_rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ) . wred_profile_id as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( wred_profile_id ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ) . shared_wred_context_id as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( shared_wred_context_id ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ) . n_shared_wred_contexts as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( n_shared_wred_contexts ) ));
}
impl Clone for rte_tm_node_params__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_2>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_params__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 )
                ) . cman as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( cman ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 )
                ) . wred as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( wred ) ));
}
impl Clone for rte_tm_node_params__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_params__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_params__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( rte_tm_node_params__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_params__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                rte_tm_node_params__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params__bindgen_ty_1 ) ) .
                nonleaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1 ) , "::" , stringify ! (
                nonleaf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params__bindgen_ty_1 ) ) .
                leaf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rte_tm_node_params__bindgen_ty_1 ) , "::" , stringify ! ( leaf
                ) ));
}
impl Clone for rte_tm_node_params__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tm_node_params() {
    assert_eq!(::std::mem::size_of::<rte_tm_node_params>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( rte_tm_node_params ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_node_params>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rte_tm_node_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params ) ) .
                shaper_profile_id as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( rte_tm_node_params ) ,
                "::" , stringify ! ( shaper_profile_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params ) ) . shared_shaper_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_params ) ,
                "::" , stringify ! ( shared_shaper_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params ) ) . n_shared_shapers
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_params ) ,
                "::" , stringify ! ( n_shared_shapers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_node_params ) ) . stats_mask as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_node_params ) ,
                "::" , stringify ! ( stats_mask ) ));
}
impl Clone for rte_tm_node_params {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Verbose error types.
///
/// Most of them provide the type of the object referenced by struct
/// rte_tm_error::cause.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tm_error_type {
    RTE_TM_ERROR_TYPE_NONE = 0,
    RTE_TM_ERROR_TYPE_UNSPECIFIED = 1,
    RTE_TM_ERROR_TYPE_CAPABILITIES = 2,
    RTE_TM_ERROR_TYPE_LEVEL_ID = 3,
    RTE_TM_ERROR_TYPE_WRED_PROFILE = 4,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_GREEN = 5,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_YELLOW = 6,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_RED = 7,
    RTE_TM_ERROR_TYPE_WRED_PROFILE_ID = 8,
    RTE_TM_ERROR_TYPE_SHARED_WRED_CONTEXT_ID = 9,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE = 10,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_COMMITTED_RATE = 11,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_COMMITTED_SIZE = 12,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PEAK_RATE = 13,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PEAK_SIZE = 14,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_PKT_ADJUST_LEN = 15,
    RTE_TM_ERROR_TYPE_SHAPER_PROFILE_ID = 16,
    RTE_TM_ERROR_TYPE_SHARED_SHAPER_ID = 17,
    RTE_TM_ERROR_TYPE_NODE_PARENT_NODE_ID = 18,
    RTE_TM_ERROR_TYPE_NODE_PRIORITY = 19,
    RTE_TM_ERROR_TYPE_NODE_WEIGHT = 20,
    RTE_TM_ERROR_TYPE_NODE_PARAMS = 21,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHAPER_PROFILE_ID = 22,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHARED_SHAPER_ID = 23,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SHARED_SHAPERS = 24,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_WFQ_WEIGHT_MODE = 25,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SP_PRIORITIES = 26,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_CMAN = 27,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_WRED_PROFILE_ID = 28,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_SHARED_WRED_CONTEXT_ID = 29,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_N_SHARED_WRED_CONTEXTS = 30,
    RTE_TM_ERROR_TYPE_NODE_PARAMS_STATS = 31,
    RTE_TM_ERROR_TYPE_NODE_ID = 32,
}
/// Verbose error structure definition.
///
/// This object is normally allocated by applications and set by PMDs, the
/// message points to a constant string which does not need to be freed by
/// the application, however its pointer can be considered valid only as long
/// as its associated DPDK port remains configured. Closing the underlying
/// device or unloading the PMD invalidates it.
///
/// Both cause and message may be NULL regardless of the error type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_error {
    /// < Cause field and error type.
    pub type_: rte_tm_error_type,
    /// < Object responsible for the error.
    pub cause: *const ::std::os::raw::c_void,
    /// < Human-readable error message.
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_tm_error() {
    assert_eq!(::std::mem::size_of::<rte_tm_error>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rte_tm_error ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_error>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tm_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_error ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_error ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_error ) ) . cause as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_error ) , "::" ,
                stringify ! ( cause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_error ) ) . message as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_error ) , "::" ,
                stringify ! ( message ) ));
}
impl Clone for rte_tm_error {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Traffic manager get number of leaf nodes
///
/// Each leaf node sits on on top of a TX queue of the current Ethernet port.
/// Therefore, the set of leaf nodes is predefined, their number is always equal
/// to N (where N is the number of TX queues configured for the current port)
/// and their IDs are 0 .. (N-1).
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[out] n_leaf_nodes
/// Number of leaf nodes for the current port.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
    pub fn rte_tm_get_number_of_leaf_nodes(port_id: u8,
                                           n_leaf_nodes: *mut u32,
                                           error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node ID validate and type (i.e. leaf or non-leaf) get
///
/// The leaf nodes have predefined IDs in the range of 0 .. (N-1), where N is
/// the number of TX queues of the current Ethernet port. The non-leaf nodes
/// have their IDs generated by the application outside of the above range,
/// which is reserved for leaf nodes.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID value. Needs to be valid.
/// @param[out] is_leaf
/// Set to non-zero value when node is leaf and to zero otherwise (non-leaf).
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
    pub fn rte_tm_node_type_get(port_id: u8, node_id: u32,
                                is_leaf: *mut ::std::os::raw::c_int,
                                error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager capabilities get
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[out] cap
/// Traffic manager capabilities. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
    pub fn rte_tm_capabilities_get(port_id: u8, cap: *mut rte_tm_capabilities,
                                   error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager level capabilities get
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] level_id
/// The hierarchy level identifier. The value of 0 identifies the level of the
/// root node.
/// @param[out] cap
/// Traffic manager level capabilities. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
    pub fn rte_tm_level_capabilities_get(port_id: u8, level_id: u32,
                                         cap: *mut rte_tm_level_capabilities,
                                         error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node capabilities get
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[out] cap
/// Traffic manager node capabilities. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
    pub fn rte_tm_node_capabilities_get(port_id: u8, node_id: u32,
                                        cap: *mut rte_tm_node_capabilities,
                                        error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager WRED profile add
///
/// Create a new WRED profile with ID set to *wred_profile_id*. The new profile
/// is used to create one or several WRED contexts.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] wred_profile_id
/// WRED profile ID for the new profile. Needs to be unused.
/// @param[in] profile
/// WRED profile parameters. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_n_max
    pub fn rte_tm_wred_profile_add(port_id: u8, wred_profile_id: u32,
                                   profile: *mut rte_tm_wred_params,
                                   error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager WRED profile delete
///
/// Delete an existing WRED profile. This operation fails when there is
/// currently at least one user (i.e. WRED context) of this WRED profile.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] wred_profile_id
/// WRED profile ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_n_max
    pub fn rte_tm_wred_profile_delete(port_id: u8, wred_profile_id: u32,
                                      error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shared WRED context add or update
///
/// When *shared_wred_context_id* is invalid, a new WRED context with this ID is
/// created by using the WRED profile identified by *wred_profile_id*.
///
/// When *shared_wred_context_id* is valid, this WRED context is no longer using
/// the profile previously assigned to it and is updated to use the profile
/// identified by *wred_profile_id*.
///
/// A valid shared WRED context can be assigned to several hierarchy leaf nodes
/// configured to use WRED as the congestion management mode.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shared_wred_context_id
/// Shared WRED context ID
/// @param[in] wred_profile_id
/// WRED profile ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_shared_n_max
    pub fn rte_tm_shared_wred_context_add_update(port_id: u8,
                                                 shared_wred_context_id: u32,
                                                 wred_profile_id: u32,
                                                 error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shared WRED context delete
///
/// Delete an existing shared WRED context. This operation fails when there is
/// currently at least one user (i.e. hierarchy leaf node) of this shared WRED
/// context.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shared_wred_context_id
/// Shared WRED context ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_shared_n_max
    pub fn rte_tm_shared_wred_context_delete(port_id: u8,
                                             shared_wred_context_id: u32,
                                             error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shaper profile add
///
/// Create a new shaper profile with ID set to *shaper_profile_id*. The new
/// shaper profile is used to create one or several shapers.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shaper_profile_id
/// Shaper profile ID for the new profile. Needs to be unused.
/// @param[in] profile
/// Shaper profile parameters. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_n_max
    pub fn rte_tm_shaper_profile_add(port_id: u8, shaper_profile_id: u32,
                                     profile: *mut rte_tm_shaper_params,
                                     error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shaper profile delete
///
/// Delete an existing shaper profile. This operation fails when there is
/// currently at least one user (i.e. shaper) of this shaper profile.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shaper_profile_id
/// Shaper profile ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_n_max
    pub fn rte_tm_shaper_profile_delete(port_id: u8, shaper_profile_id: u32,
                                        error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shared shaper add or update
///
/// When *shared_shaper_id* is not a valid shared shaper ID, a new shared shaper
/// with this ID is created using the shaper profile identified by
/// *shaper_profile_id*.
///
/// When *shared_shaper_id* is a valid shared shaper ID, this shared shaper is
/// no longer using the shaper profile previously assigned to it and is updated
/// to use the shaper profile identified by *shaper_profile_id*.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shared_shaper_id
/// Shared shaper ID
/// @param[in] shaper_profile_id
/// Shaper profile ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_shared_n_max
    pub fn rte_tm_shared_shaper_add_update(port_id: u8, shared_shaper_id: u32,
                                           shaper_profile_id: u32,
                                           error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager shared shaper delete
///
/// Delete an existing shared shaper. This operation fails when there is
/// currently at least one user (i.e. hierarchy node) of this shared shaper.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] shared_shaper_id
/// Shared shaper ID. Needs to be the valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_shared_n_max
    pub fn rte_tm_shared_shaper_delete(port_id: u8, shared_shaper_id: u32,
                                       error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node add
///
/// Create new node and connect it as child of an existing node. The new node is
/// further identified by *node_id*, which needs to be unused by any of the
/// existing nodes. The parent node is identified by *parent_node_id*, which
/// needs to be the valid ID of an existing non-leaf node. The parent node is
/// going to use the provided SP *priority* and WFQ *weight* to schedule its new
/// child node.
///
/// This function has to be called for both leaf and non-leaf nodes. In the case
/// of leaf nodes (i.e. *node_id* is within the range of 0 .. (N-1), with N as
/// the number of configured TX queues of the current port), the leaf node is
/// configured rather than created (as the set of leaf nodes is predefined) and
/// it is also connected as child of an existing node.
///
/// The first node that is added becomes the root node and all the nodes that
/// are subsequently added have to be added as descendants of the root node. The
/// parent of the root node has to be specified as RTE_TM_NODE_ID_NULL and there
/// can only be one node with this parent ID (i.e. the root node). Further
/// restrictions for root node: needs to be non-leaf, its private shaper profile
/// needs to be valid and single rate, cannot use any shared shapers.
///
/// When called before rte_tm_hierarchy_commit() invocation, this function is
/// typically used to define the initial start-up hierarchy for the port.
/// Provided that dynamic hierarchy updates are supported by the current port (as
/// advertised in the port capability set), this function can be also called
/// after the rte_tm_hierarchy_commit() invocation.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be unused by any of the existing nodes.
/// @param[in] parent_node_id
/// Parent node ID. Needs to be the valid.
/// @param[in] priority
/// Node priority. The highest node priority is zero. Used by the SP algorithm
/// running on the parent of the current node for scheduling this child node.
/// @param[in] weight
/// Node weight. The node weight is relative to the weight sum of all siblings
/// that have the same priority. The lowest weight is one. Used by the WFQ
/// algorithm running on the parent of the current node for scheduling this
/// child node.
/// @param[in] level_id
/// Level ID that should be met by this node. The hierarchy level of the
/// current node is already fully specified through its parent node (i.e. the
/// level of this node is equal to the level of its parent node plus one),
/// therefore the reason for providing this parameter is to enable the
/// application to perform step-by-step checking of the node level during
/// successive invocations of this function. When not desired, this check can
/// be disabled by assigning value RTE_TM_NODE_LEVEL_ID_ANY to this parameter.
/// @param[in] params
/// Node parameters. Needs to be pre-allocated and valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see rte_tm_hierarchy_commit()
/// @see RTE_TM_UPDATE_NODE_ADD_DELETE
/// @see RTE_TM_NODE_LEVEL_ID_ANY
/// @see struct rte_tm_capabilities
    pub fn rte_tm_node_add(port_id: u8, node_id: u32, parent_node_id: u32,
                           priority: u32, weight: u32, level_id: u32,
                           params: *mut rte_tm_node_params,
                           error: *mut rte_tm_error) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node delete
///
/// Delete an existing node. This operation fails when this node currently has
/// at least one user (i.e. child node).
///
/// When called before rte_tm_hierarchy_commit() invocation, this function is
/// typically used to define the initial start-up hierarchy for the port.
/// Provided that dynamic hierarchy updates are supported by the current port (as
/// advertised in the port capability set), this function can be also called
/// after the rte_tm_hierarchy_commit() invocation.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see RTE_TM_UPDATE_NODE_ADD_DELETE
    pub fn rte_tm_node_delete(port_id: u8, node_id: u32,
                              error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node suspend
///
/// Suspend an existing node. While the node is in suspended state, no packet is
/// scheduled from this node and its descendants. The node exits the suspended
/// state through the node resume operation.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see rte_tm_node_resume()
/// @see RTE_TM_UPDATE_NODE_SUSPEND_RESUME
    pub fn rte_tm_node_suspend(port_id: u8, node_id: u32,
                               error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node resume
///
/// Resume an existing node that is currently in suspended state. The node
/// entered the suspended state as result of a previous node suspend operation.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see rte_tm_node_suspend()
/// @see RTE_TM_UPDATE_NODE_SUSPEND_RESUME
    pub fn rte_tm_node_resume(port_id: u8, node_id: u32,
                              error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager hierarchy commit
///
/// This function is called during the port initialization phase (before the
/// Ethernet port is started) to freeze the start-up hierarchy.
///
/// This function typically performs the following steps:
/// a) It validates the start-up hierarchy that was previously defined for the
/// current port through successive rte_tm_node_add() invocations;
/// b) Assuming successful validation, it performs all the necessary port
/// specific configuration operations to install the specified hierarchy on
/// the current port, with immediate effect once the port is started.
///
/// This function fails when the currently configured hierarchy is not supported
/// by the Ethernet port, in which case the user can abort or try out another
/// hierarchy configuration (e.g. a hierarchy with less leaf nodes), which can be
/// build from scratch (when *clear_on_fail* is enabled) or by modifying the
/// existing hierarchy configuration (when *clear_on_fail* is disabled).
///
/// Note that this function can still fail due to other causes (e.g. not enough
/// memory available in the system, etc), even though the specified hierarchy is
/// supported in principle by the current port.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] clear_on_fail
/// On function call failure, hierarchy is cleared when this parameter is
/// non-zero and preserved when this parameter is equal to zero.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see rte_tm_node_add()
/// @see rte_tm_node_delete()
    pub fn rte_tm_hierarchy_commit(port_id: u8,
                                   clear_on_fail: ::std::os::raw::c_int,
                                   error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node parent update
///
/// Restriction for root node: its parent cannot be changed.
///
/// This function can only be called after the rte_tm_hierarchy_commit()
/// invocation. Its success depends on the port support for this operation, as
/// advertised through the port capability set.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[in] parent_node_id
/// Node ID for the new parent. Needs to be valid.
/// @param[in] priority
/// Node priority. The highest node priority is zero. Used by the SP algorithm
/// running on the parent of the current node for scheduling this child node.
/// @param[in] weight
/// Node weight. The node weight is relative to the weight sum of all siblings
/// that have the same priority. The lowest weight is zero. Used by the WFQ
/// algorithm running on the parent of the current node for scheduling this
/// child node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see RTE_TM_UPDATE_NODE_PARENT_KEEP_LEVEL
/// @see RTE_TM_UPDATE_NODE_PARENT_CHANGE_LEVEL
    pub fn rte_tm_node_parent_update(port_id: u8, node_id: u32,
                                     parent_node_id: u32, priority: u32,
                                     weight: u32, error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node private shaper update
///
/// Restriction for the root node: its private shaper profile needs to be valid
/// and single rate.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[in] shaper_profile_id
/// Shaper profile ID for the private shaper of the current node. Needs to be
/// either valid shaper profile ID or RTE_TM_SHAPER_PROFILE_ID_NONE, with
/// the latter disabling the private shaper of the current node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_private_n_max
    pub fn rte_tm_node_shaper_update(port_id: u8, node_id: u32,
                                     shaper_profile_id: u32,
                                     error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node shared shapers update
///
/// Restriction for root node: cannot use any shared rate shapers.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[in] shared_shaper_id
/// Shared shaper ID. Needs to be valid.
/// @param[in] add
/// Set to non-zero value to add this shared shaper to current node or to zero
/// to delete this shared shaper from current node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::shaper_shared_n_max
    pub fn rte_tm_node_shared_shaper_update(port_id: u8, node_id: u32,
                                            shared_shaper_id: u32,
                                            add: ::std::os::raw::c_int,
                                            error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node enabled statistics counters update
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[in] stats_mask
/// Mask of statistics counter types to be enabled for the current node. This
/// needs to be a subset of the statistics counter types available for the
/// current node. Any statistics counter type not included in this set is to
/// be disabled for the current node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see enum rte_tm_stats_type
/// @see RTE_TM_UPDATE_NODE_STATS
    pub fn rte_tm_node_stats_update(port_id: u8, node_id: u32,
                                    stats_mask: u64, error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node WFQ weight mode update
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid leaf node ID.
/// @param[in] wfq_weight_mode
/// WFQ weight mode for each SP priority. When NULL, it indicates that WFQ is
/// to be used for all priorities. When non-NULL, it points to a pre-allocated
/// array of *n_sp_priorities* values, with non-zero value for byte-mode and
/// zero for packet-mode.
/// @param[in] n_sp_priorities
/// Number of SP priorities.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see RTE_TM_UPDATE_NODE_WFQ_WEIGHT_MODE
/// @see RTE_TM_UPDATE_NODE_N_SP_PRIORITIES
    pub fn rte_tm_node_wfq_weight_mode_update(port_id: u8, node_id: u32,
                                              wfq_weight_mode:
                                                  *mut ::std::os::raw::c_int,
                                              n_sp_priorities: u32,
                                              error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node congestion management mode update
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid leaf node ID.
/// @param[in] cman
/// Congestion management mode.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see RTE_TM_UPDATE_NODE_CMAN
    pub fn rte_tm_node_cman_update(port_id: u8, node_id: u32,
                                   cman: rte_tm_cman_mode,
                                   error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node private WRED context update
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid leaf node ID.
/// @param[in] wred_profile_id
/// WRED profile ID for the private WRED context of the current node. Needs to
/// be either valid WRED profile ID or RTE_TM_WRED_PROFILE_ID_NONE, with the
/// latter disabling the private WRED context of the current node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_private_n_max
    pub fn rte_tm_node_wred_context_update(port_id: u8, node_id: u32,
                                           wred_profile_id: u32,
                                           error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node shared WRED context update
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid leaf node ID.
/// @param[in] shared_wred_context_id
/// Shared WRED context ID. Needs to be valid.
/// @param[in] add
/// Set to non-zero value to add this shared WRED context to current node or
/// to zero to delete this shared WRED context from current node.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::cman_wred_context_shared_n_max
    pub fn rte_tm_node_shared_wred_context_update(port_id: u8, node_id: u32,
                                                  shared_wred_context_id: u32,
                                                  add: ::std::os::raw::c_int,
                                                  error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager node statistics counters read
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] node_id
/// Node ID. Needs to be valid.
/// @param[out] stats
/// When non-NULL, it contains the current value for the statistics counters
/// enabled for the current node.
/// @param[out] stats_mask
/// When non-NULL, it contains the mask of statistics counter types that are
/// currently enabled for this node, indicating which of the counters
/// retrieved with the *stats* structure are valid.
/// @param[in] clear
/// When this parameter has a non-zero value, the statistics counters are
/// cleared (i.e. set to zero) immediately after they have been read,
/// otherwise the statistics counters are left untouched.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see enum rte_tm_stats_type
    pub fn rte_tm_node_stats_read(port_id: u8, node_id: u32,
                                  stats: *mut rte_tm_node_stats,
                                  stats_mask: *mut u64,
                                  clear: ::std::os::raw::c_int,
                                  error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager packet marking - VLAN DEI (IEEE 802.1Q)
///
/// IEEE 802.1p maps the traffic class to the VLAN Priority Code Point (PCP)
/// field (3 bits), while IEEE 802.1q maps the drop priority to the VLAN Drop
/// Eligible Indicator (DEI) field (1 bit), which was previously named Canonical
/// Format Indicator (CFI).
///
/// All VLAN frames of a given color get their DEI bit set if marking is enabled
/// for this color; otherwise, their DEI bit is left as is (either set or not).
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] mark_green
/// Set to non-zero value to enable marking of green packets and to zero to
/// disable it.
/// @param[in] mark_yellow
/// Set to non-zero value to enable marking of yellow packets and to zero to
/// disable it.
/// @param[in] mark_red
/// Set to non-zero value to enable marking of red packets and to zero to
/// disable it.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::mark_vlan_dei_supported
    pub fn rte_tm_mark_vlan_dei(port_id: u8,
                                mark_green: ::std::os::raw::c_int,
                                mark_yellow: ::std::os::raw::c_int,
                                mark_red: ::std::os::raw::c_int,
                                error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager packet marking - IPv4 / IPv6 ECN (IETF RFC 3168)
///
/// IETF RFCs 2474 and 3168 reorganize the IPv4 Type of Service (TOS) field
/// (8 bits) and the IPv6 Traffic Class (TC) field (8 bits) into Differentiated
/// Services Codepoint (DSCP) field (6 bits) and Explicit Congestion
/// Notification (ECN) field (2 bits). The DSCP field is typically used to
/// encode the traffic class and/or drop priority (RFC 2597), while the ECN
/// field is used by RFC 3168 to implement a congestion notification mechanism
/// to be leveraged by transport layer protocols such as TCP and SCTP that have
/// congestion control mechanisms.
///
/// When congestion is experienced, as alternative to dropping the packet,
/// routers can change the ECN field of input packets from 2'b01 or 2'b10
/// (values indicating that source endpoint is ECN-capable) to 2'b11 (meaning
/// that congestion is experienced). The destination endpoint can use the
/// ECN-Echo (ECE) TCP flag to relay the congestion indication back to the
/// source endpoint, which acknowledges it back to the destination endpoint with
/// the Congestion Window Reduced (CWR) TCP flag.
///
/// All IPv4/IPv6 packets of a given color with ECN set to 2’b01 or 2’b10
/// carrying TCP or SCTP have their ECN set to 2’b11 if the marking feature is
/// enabled for the current color, otherwise the ECN field is left as is.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] mark_green
/// Set to non-zero value to enable marking of green packets and to zero to
/// disable it.
/// @param[in] mark_yellow
/// Set to non-zero value to enable marking of yellow packets and to zero to
/// disable it.
/// @param[in] mark_red
/// Set to non-zero value to enable marking of red packets and to zero to
/// disable it.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::mark_ip_ecn_tcp_supported
/// @see struct rte_tm_capabilities::mark_ip_ecn_sctp_supported
    pub fn rte_tm_mark_ip_ecn(port_id: u8, mark_green: ::std::os::raw::c_int,
                              mark_yellow: ::std::os::raw::c_int,
                              mark_red: ::std::os::raw::c_int,
                              error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Traffic manager packet marking - IPv4 / IPv6 DSCP (IETF RFC 2597)
///
/// IETF RFC 2597 maps the traffic class and the drop priority to the IPv4/IPv6
/// Differentiated Services Codepoint (DSCP) field (6 bits). Here are the DSCP
/// values proposed by this RFC:
///
/// <pre>                   Class 1    Class 2    Class 3    Class 4   </pre>
/// <pre>                 +----------+----------+----------+----------+</pre>
/// <pre>Low Drop Prec    |  001010  |  010010  |  011010  |  100010  |</pre>
/// <pre>Medium Drop Prec |  001100  |  010100  |  011100  |  100100  |</pre>
/// <pre>High Drop Prec   |  001110  |  010110  |  011110  |  100110  |</pre>
/// <pre>                 +----------+----------+----------+----------+</pre>
///
/// There are 4 traffic classes (classes 1 .. 4) encoded by DSCP bits 1 and 2,
/// as well as 3 drop priorities (low/medium/high) encoded by DSCP bits 3 and 4.
///
/// All IPv4/IPv6 packets have their color marked into DSCP bits 3 and 4 as
/// follows: green mapped to Low Drop Precedence (2’b01), yellow to Medium
/// (2’b10) and red to High (2’b11). Marking needs to be explicitly enabled
/// for each color; when not enabled for a given color, the DSCP field of all
/// packets with that color is left as is.
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[in] mark_green
/// Set to non-zero value to enable marking of green packets and to zero to
/// disable it.
/// @param[in] mark_yellow
/// Set to non-zero value to enable marking of yellow packets and to zero to
/// disable it.
/// @param[in] mark_red
/// Set to non-zero value to enable marking of red packets and to zero to
/// disable it.
/// @param[out] error
/// Error details. Filled in only on error, when not NULL.
/// @return
/// 0 on success, non-zero error code otherwise.
///
/// @see struct rte_tm_capabilities::mark_ip_dscp_supported
    pub fn rte_tm_mark_ip_dscp(port_id: u8, mark_green: ::std::os::raw::c_int,
                               mark_yellow: ::std::os::raw::c_int,
                               mark_red: ::std::os::raw::c_int,
                               error: *mut rte_tm_error)
     -> ::std::os::raw::c_int;
}
/// @internal Traffic manager node ID validate and type get
pub type rte_tm_node_type_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               is_leaf:
                                                   *mut ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager capabilities get
pub type rte_tm_capabilities_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               cap: *mut rte_tm_capabilities,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager level capabilities get
pub type rte_tm_level_capabilities_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               level_id: u32,
                                               cap:
                                                   *mut rte_tm_level_capabilities,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node capabilities get
pub type rte_tm_node_capabilities_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               cap:
                                                   *mut rte_tm_node_capabilities,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager WRED profile add
pub type rte_tm_wred_profile_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               wred_profile_id: u32,
                                               profile:
                                                   *mut rte_tm_wred_params,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager WRED profile delete
pub type rte_tm_wred_profile_delete_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               wred_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shared WRED context add
pub type rte_tm_shared_wred_context_add_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shared_wred_context_id: u32,
                                               wred_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shared WRED context delete
pub type rte_tm_shared_wred_context_delete_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shared_wred_context_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shaper profile add
pub type rte_tm_shaper_profile_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shaper_profile_id: u32,
                                               profile:
                                                   *mut rte_tm_shaper_params,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shaper profile delete
pub type rte_tm_shaper_profile_delete_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shaper_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shared shaper add/update
pub type rte_tm_shared_shaper_add_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shared_shaper_id: u32,
                                               shaper_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager shared shaper delete
pub type rte_tm_shared_shaper_delete_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               shared_shaper_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node add
pub type rte_tm_node_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               parent_node_id: u32,
                                               priority: u32, weight: u32,
                                               level_id: u32,
                                               params:
                                                   *mut rte_tm_node_params,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node delete
pub type rte_tm_node_delete_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node suspend
pub type rte_tm_node_suspend_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node resume
pub type rte_tm_node_resume_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager hierarchy commit
pub type rte_tm_hierarchy_commit_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               clear_on_fail:
                                                   ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node parent update
pub type rte_tm_node_parent_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               parent_node_id: u32,
                                               priority: u32, weight: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node shaper update
pub type rte_tm_node_shaper_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               shaper_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node shaper update
pub type rte_tm_node_shared_shaper_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               shared_shaper_id: u32,
                                               add: i32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node stats update
pub type rte_tm_node_stats_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32, stats_mask: u64,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node WFQ weight mode update
pub type rte_tm_node_wfq_weight_mode_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               wfq_weigth_mode:
                                                   *mut ::std::os::raw::c_int,
                                               n_sp_priorities: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node congestion management mode update
pub type rte_tm_node_cman_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               cman: rte_tm_cman_mode,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node WRED context update
pub type rte_tm_node_wred_context_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               wred_profile_id: u32,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager node WRED context update
pub type rte_tm_node_shared_wred_context_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               shared_wred_context_id: u32,
                                               add: ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager read stats counters for specific node
pub type rte_tm_node_stats_read_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               node_id: u32,
                                               stats: *mut rte_tm_node_stats,
                                               stats_mask: *mut u64,
                                               clear: ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager packet marking - VLAN DEI
pub type rte_tm_mark_vlan_dei_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mark_green:
                                                   ::std::os::raw::c_int,
                                               mark_yellow:
                                                   ::std::os::raw::c_int,
                                               mark_red:
                                                   ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager packet marking - IPv4/IPv6 ECN
pub type rte_tm_mark_ip_ecn_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mark_green:
                                                   ::std::os::raw::c_int,
                                               mark_yellow:
                                                   ::std::os::raw::c_int,
                                               mark_red:
                                                   ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
/// @internal Traffic manager packet marking - IPv4/IPv6 DSCP
pub type rte_tm_mark_ip_dscp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mark_green:
                                                   ::std::os::raw::c_int,
                                               mark_yellow:
                                                   ::std::os::raw::c_int,
                                               mark_red:
                                                   ::std::os::raw::c_int,
                                               error: *mut rte_tm_error)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tm_ops {
    /// Traffic manager node type get
    pub node_type_get: rte_tm_node_type_get_t,
    /// Traffic manager capabilities_get
    pub capabilities_get: rte_tm_capabilities_get_t,
    /// Traffic manager level capabilities_get
    pub level_capabilities_get: rte_tm_level_capabilities_get_t,
    /// Traffic manager node capabilities get
    pub node_capabilities_get: rte_tm_node_capabilities_get_t,
    /// Traffic manager WRED profile add
    pub wred_profile_add: rte_tm_wred_profile_add_t,
    /// Traffic manager WRED profile delete
    pub wred_profile_delete: rte_tm_wred_profile_delete_t,
    /// Traffic manager shared WRED context add/update
    pub shared_wred_context_add_update: rte_tm_shared_wred_context_add_update_t,
    /// Traffic manager shared WRED context delete
    pub shared_wred_context_delete: rte_tm_shared_wred_context_delete_t,
    /// Traffic manager shaper profile add
    pub shaper_profile_add: rte_tm_shaper_profile_add_t,
    /// Traffic manager shaper profile delete
    pub shaper_profile_delete: rte_tm_shaper_profile_delete_t,
    /// Traffic manager shared shaper add/update
    pub shared_shaper_add_update: rte_tm_shared_shaper_add_update_t,
    /// Traffic manager shared shaper delete
    pub shared_shaper_delete: rte_tm_shared_shaper_delete_t,
    /// Traffic manager node add
    pub node_add: rte_tm_node_add_t,
    /// Traffic manager node delete
    pub node_delete: rte_tm_node_delete_t,
    /// Traffic manager node suspend
    pub node_suspend: rte_tm_node_suspend_t,
    /// Traffic manager node resume
    pub node_resume: rte_tm_node_resume_t,
    /// Traffic manager hierarchy commit
    pub hierarchy_commit: rte_tm_hierarchy_commit_t,
    /// Traffic manager node parent update
    pub node_parent_update: rte_tm_node_parent_update_t,
    /// Traffic manager node shaper update
    pub node_shaper_update: rte_tm_node_shaper_update_t,
    /// Traffic manager node shared shaper update
    pub node_shared_shaper_update: rte_tm_node_shared_shaper_update_t,
    /// Traffic manager node stats update
    pub node_stats_update: rte_tm_node_stats_update_t,
    /// Traffic manager node WFQ weight mode update
    pub node_wfq_weight_mode_update: rte_tm_node_wfq_weight_mode_update_t,
    /// Traffic manager node congestion management mode update
    pub node_cman_update: rte_tm_node_cman_update_t,
    /// Traffic manager node WRED context update
    pub node_wred_context_update: rte_tm_node_wred_context_update_t,
    /// Traffic manager node shared WRED context update
    pub node_shared_wred_context_update: rte_tm_node_shared_wred_context_update_t,
    /// Traffic manager read statistics counters for current node
    pub node_stats_read: rte_tm_node_stats_read_t,
    /// Traffic manager packet marking - VLAN DEI
    pub mark_vlan_dei: rte_tm_mark_vlan_dei_t,
    /// Traffic manager packet marking - IPv4/IPv6 ECN
    pub mark_ip_ecn: rte_tm_mark_ip_ecn_t,
    /// Traffic manager packet marking - IPv4/IPv6 DSCP
    pub mark_ip_dscp: rte_tm_mark_ip_dscp_t,
}
#[test]
fn bindgen_test_layout_rte_tm_ops() {
    assert_eq!(::std::mem::size_of::<rte_tm_ops>() , 232usize , concat ! (
               "Size of: " , stringify ! ( rte_tm_ops ) ));
    assert_eq! (::std::mem::align_of::<rte_tm_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rte_tm_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_type_get as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_type_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . capabilities_get as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( capabilities_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . level_capabilities_get
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( level_capabilities_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_capabilities_get as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_capabilities_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . wred_profile_add as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( wred_profile_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . wred_profile_delete as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( wred_profile_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) .
                shared_wred_context_add_update as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shared_wred_context_add_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) .
                shared_wred_context_delete as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shared_wred_context_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . shaper_profile_add as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shaper_profile_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . shaper_profile_delete as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shaper_profile_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . shared_shaper_add_update
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shared_shaper_add_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . shared_shaper_delete as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( shared_shaper_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_add as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_delete as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_suspend as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_resume as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . hierarchy_commit as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( hierarchy_commit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_parent_update as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_parent_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_shaper_update as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_shaper_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) .
                node_shared_shaper_update as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_shared_shaper_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_stats_update as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_stats_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) .
                node_wfq_weight_mode_update as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_wfq_weight_mode_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_cman_update as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_cman_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_wred_context_update
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_wred_context_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) .
                node_shared_wred_context_update as * const _ as usize } ,
                192usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_shared_wred_context_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . node_stats_read as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( node_stats_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . mark_vlan_dei as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( mark_vlan_dei ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . mark_ip_ecn as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( mark_ip_ecn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tm_ops ) ) . mark_ip_dscp as * const
                _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( rte_tm_ops ) , "::" ,
                stringify ! ( mark_ip_dscp ) ));
}
impl Clone for rte_tm_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Get generic traffic manager operations structure from a port
///
/// @param[in] port_id
/// The port identifier of the Ethernet device.
/// @param[out] error
/// Error details
///
/// @return
/// The traffic manager operations structure associated with port_id on
/// success, NULL otherwise.
    pub fn rte_tm_ops_get(port_id: u8, error: *mut rte_tm_error)
     -> *const rte_tm_ops;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_elem {
    pub _address: u8,
}
impl Clone for malloc_elem {
    fn clone(&self) -> Self { *self }
}
